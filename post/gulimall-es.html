<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>谷粒商城-es篇 | 阿威的代码小站</title><meta name="author" content="fcw,3185087246@protonmail.com"><meta name="copyright" content="fcw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker删掉容器，之前的数据会不会没有。不会的，因为删除之前数据就保存在外部，重新映射就行 docker stop iddocker rm iddocker restart id 安装es和kinana# 1.拉取镜像,es存储检索 kibana主要提供可视化的操作docker pull elasticsearch:7.4.2docker pull kibana:7.4.2#2.创建挂载文件和">
<meta property="og:type" content="article">
<meta property="og:title" content="谷粒商城-es篇">
<meta property="og:url" content="https://risingrode.github.io/post/gulimall-es.html">
<meta property="og:site_name" content="阿威的代码小站">
<meta property="og:description" content="Docker删掉容器，之前的数据会不会没有。不会的，因为删除之前数据就保存在外部，重新映射就行 docker stop iddocker rm iddocker restart id 安装es和kinana# 1.拉取镜像,es存储检索 kibana主要提供可视化的操作docker pull elasticsearch:7.4.2docker pull kibana:7.4.2#2.创建挂载文件和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i0.hippopx.com/photos/583/885/292/tianjin-twilight-city-scenery-preview.jpg">
<meta property="article:published_time" content="2023-08-24T14:40:18.000Z">
<meta property="article:modified_time" content="2023-10-09T15:22:27.818Z">
<meta property="article:author" content="fcw">
<meta property="article:tag" content="es">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i0.hippopx.com/photos/583/885/292/tianjin-twilight-city-scenery-preview.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://risingrode.github.io/post/gulimall-es.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '谷粒商城-es篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-09 23:22:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="/live2d-widget-master/autoload.js"></script><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/girl.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 优质网站链接</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i0.hippopx.com/photos/583/885/292/tianjin-twilight-city-scenery-preview.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="阿威的代码小站"><span class="site-name">阿威的代码小站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 优质网站链接</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">谷粒商城-es篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-24T14:40:18.000Z" title="发表于 2023-08-24 22:40:18">2023-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-09T15:22:27.818Z" title="更新于 2023-10-09 23:22:27">2023-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/">谷粒商城</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="谷粒商城-es篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>删掉容器，之前的数据会不会没有。<br>不会的，因为删除之前数据就保存在外部，重新映射就行</p>
<p>docker stop id<br>docker rm id<br>docker restart id</p>
<h2 id="安装es和kinana"><a href="#安装es和kinana" class="headerlink" title="安装es和kinana"></a>安装es和kinana</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.拉取镜像,es存储检索 kibana主要提供可视化的操作</span></span><br><span class="line">docker pull elasticsearch:7.4.2</span><br><span class="line">docker pull kibana:7.4.2</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.创建挂载文件和配置</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mydata/elasticsearch/config</span><br><span class="line"><span class="built_in">mkdir</span> -p /mydata/elasticsearch/data</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.修改配置让es被远程连接</span></span><br><span class="line">vi /mydata/elasticsearch/config/elasticsearch.yml</span><br><span class="line">... <span class="string">&quot;http.host: 0.0.0.0&quot;</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.创建数据卷和容器</span></span><br><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e  <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">-e ES_JAVA_OPTS=<span class="string">&quot;-Xms64m -Xmx512m&quot;</span> \</span><br><span class="line">-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v  /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.这时候启动还不行</span></span><br><span class="line"><span class="comment"># 递归更改权限，es需要访问</span></span><br><span class="line"><span class="built_in">chmod</span> -R 777 /mydata/elasticsearch/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动elasticsearch</span></span><br><span class="line">docker update elasticsearch --restart=always</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查方式 ip+:9200 如果有es相关信息说明启动成功</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#这个-e IP地址是虚拟机主机地址</span></span><br><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.56.10:9200 -p 5601:5601 -d kibana:7.4.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动kibana</span></span><br><span class="line">docker update kibana  --restart=always</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[vagrant@localhost ~]$ sudo docker <span class="built_in">exec</span> -it elasticsearch /bin/bash</span><br><span class="line">[root@66718a266132 elasticsearch]<span class="comment"># pwd</span></span><br><span class="line">/usr/share/elasticsearch</span><br><span class="line">[root@66718a266132 elasticsearch]<span class="comment"># yum install wget</span></span><br><span class="line">[root@66718a266132 elasticsearch]<span class="comment"># wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip</span></span><br><span class="line">[root@66718a266132 elasticsearch]<span class="comment"># unzip elasticsearch-analysis-ik-7.4.2.zip -d ik</span></span><br><span class="line">[root@66718a266132 elasticsearch]<span class="comment"># mv ik plugins/</span></span><br><span class="line"><span class="built_in">chmod</span> -R 777 plugins/ik</span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure>

<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx:1.10</span><br><span class="line"><span class="comment"># 为了复制一个配置</span></span><br><span class="line">docker run -p 80:80 --name nginx -d nginx:1.10</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /mydata/nginx</span><br><span class="line">docker container <span class="built_in">cp</span> nginx:/etc/nginx .</span><br><span class="line">然后在外部 /mydata/nginx/nginx 有了一堆文件</span><br><span class="line"><span class="built_in">mv</span> /mydata/nginx/nginx /mydata/nginx/conf</span><br><span class="line"><span class="comment"># 停掉nginx</span></span><br><span class="line">docker stop nginx</span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的nginx</span></span><br><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">-v /mydata/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /mydata/nginx/logs:/var/log/nginx \</span><br><span class="line">-v /mydata/nginx/conf:/etc/nginx \</span><br><span class="line">-d nginx:1.10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意一下这个路径映射到了/usr/share/nginx/html，我们在nginx配置文件中是写/usr/share/nginx/html，不是写/mydata/nginx/html</span></span><br><span class="line">docker update nginx --restart=always</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="nested"><a href="#nested" class="headerlink" title="nested"></a>nested</h2><p>克服扁平化处理的副作用。</p>
<h1 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h1><h1 id="Jrebel配置"><a href="#Jrebel配置" class="headerlink" title="Jrebel配置"></a>Jrebel配置</h1><p>需要在:帮助-&gt;VM进行下面配置。<br>-Drebel.base&#x3D;D:\JAVA\Jrebel<br>-Duser.home&#x3D;D:\JAVA\Jrebel</p>
<h1 id="thmleft"><a href="#thmleft" class="headerlink" title="thmleft"></a>thmleft</h1><p>页面修改实时更新</p>
<h1 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h1><p>正向：科学上网，隐藏客户端信息<br>反向：屏蔽内网信息，负载均衡访问</p>
<p>nginx 进行反向代理</p>
<p>所有来自于gulimall.com的请求，都转到商品服务。</p>
<p>查看日志<br>docker logs nginx</p>
<p>:set number  #显示行号</p>
<h1 id="nginx-反向代理成功"><a href="#nginx-反向代理成功" class="headerlink" title="nginx 反向代理成功"></a>nginx 反向代理成功</h1><p>我使用的是虚拟机部署nginx ,不是docker部署。</p>
<p>监听80端口，设置proxy_pass代理.</p>
<p>进入安装好的目录 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</p>
<p>.&#x2F;nginx 启动<br>.&#x2F;nginx -s stop 快速停止<br>.&#x2F;nginx -s quit 优雅关闭，在退出前完成已经接受的连接请求<br>.&#x2F;nginx -s reload 重新加载配置</p>
<p>查看端口号：<br>netstat -ntlp</p>
<p>docker run -p 80:80 –name nginx -v &#x2F;mydata&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html -v &#x2F;mydata&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx -v &#x2F;mydata&#x2F;nginx&#x2F;conf:&#x2F;etc&#x2F;nginx -d nginx:1.10 </p>
<p>、安装nginx<br>随便启动一个 nginx 实例，只是为了复制出配置<br>docker run -p 80:80 –name nginx -d nginx:1.10</p>
<p>将容器内的配置文件拷贝到当前目录：docker container cp nginx:&#x2F;etc&#x2F;nginx .</p>
<p>别忘了后面的点</p>
<p>修改文件名称：mv nginx conf 把这个 conf 移动到&#x2F;mydata&#x2F;nginx 下</p>
<p>终止原容器：docker stop nginx</p>
<p>执行命令删除原容器：docker rm $ContainerId</p>
<p>创建新的 nginx；执行以下命令</p>
<h1 id="执行前确保上面的步骤执行了-创建了相关的配置文件-否则nginx无法启动"><a href="#执行前确保上面的步骤执行了-创建了相关的配置文件-否则nginx无法启动" class="headerlink" title="执行前确保上面的步骤执行了  创建了相关的配置文件 否则nginx无法启动"></a>执行前确保上面的步骤执行了  创建了相关的配置文件 否则nginx无法启动</h1><p>docker run -p 80:80 –name nginx <br>-v &#x2F;mydata&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html <br>-v &#x2F;mydata&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx <br>-v &#x2F;mydata&#x2F;nginx&#x2F;conf:&#x2F;etc&#x2F;nginx <br>-d nginx:1.10 </p>
<p>docker ID update –restart&#x3D;always</p>
<h1 id="P141-性能压测"><a href="#P141-性能压测" class="headerlink" title="P141- 性能压测"></a>P141- 性能压测</h1><h2 id="内存泄漏和并发与同步问题"><a href="#内存泄漏和并发与同步问题" class="headerlink" title="内存泄漏和并发与同步问题"></a>内存泄漏和并发与同步问题</h2><ul>
<li><p><strong>内存泄漏</strong>指的是程序在使用完内存后，没有释放它们，导致程序占用的内存越来越多，最终可能导致程序崩溃或者性能下降。</p>
</li>
<li><p><strong>并发与同步</strong>是指在多线程或多进程的程序中，如何确保不同部分的代码在资源访问上不会产生冲突，保证程序的正确性和稳定性。</p>
</li>
</ul>
<p>对于压力测试：</p>
<ol>
<li><p><strong>重复性</strong>：测试应该可以重复执行，以便确认结果的一致性。</p>
</li>
<li><p><strong>并发性</strong>：测试应该模拟多个用户或多个请求同时访问系统，以检查系统在负载下的性能表现。</p>
</li>
<li><p><strong>量级</strong>：测试应该覆盖各种量级，以确保系统在不同规模下的稳定性和性能。</p>
</li>
<li><p><strong>随机变化</strong>：通过引入随机性来模拟真实世界中的情况，以便发现系统可能存在的隐性问题。</p>
</li>
</ol>
<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ol>
<li><strong>响应时间（Response Time）</strong>：从发送请求到接收到响应的时间间隔。通常用毫秒（ms）或秒（s）来衡量。</li>
<li><strong>吞吐量（Throughput）</strong>：单位时间内处理的请求数量或事务数量。通常用每秒请求数（Requests Per Second，RPS）或每秒事务数（Transactions Per Second，TPS）来衡量。</li>
<li><strong>并发用户数（Concurrent Users）</strong>：同时访问系统的用户数量。对于网站或应用程序来说，这是一个重要的指标，影响着系统的性能。</li>
<li><strong>CPU 使用率（CPU Utilization）</strong>：CPU 在单位时间内被使用的百分比。高 CPU 使用率可能表示系统负载较高。</li>
<li><strong>内存使用率（Memory Utilization）</strong>：内存在单位时间内被使用的百分比。高内存使用率可能导致内存泄漏或需要优化。</li>
<li><strong>网络延迟（Network Latency）</strong>：数据在网络中传输的时间。通常用毫秒（ms）来衡量。</li>
<li><strong>错误率（Error Rate）</strong>：处理过程中出现错误的比例。这可以包括HTTP错误码、异常等。</li>
<li><strong>资源利用率（Resource Utilization）</strong>：其他硬件或软件资源（如数据库连接、磁盘I&#x2F;O）的使用情况。</li>
<li><strong>稳定性和可靠性（Stability and Reliability）</strong>：系统在一段时间内保持稳定和可靠的能力。</li>
<li><strong>容量（Capacity）</strong>：系统可以支持的最大负载或数据量。</li>
<li><strong>页面加载时间（Page Load Time）</strong>：网页从请求开始到完全加载完成的时间。</li>
<li><strong>事务成功率（Transaction Success Rate）</strong>：完成的事务中成功的比例。</li>
<li><strong>队列长度（Queue Length）</strong>：等待处理的请求或任务数量。</li>
<li><strong>数据吞吐量（Data Throughput）</strong>：单位时间内处理的数据量，通常用于数据库或存储系统。</li>
</ol>
<h2 id="P142-性能压测-压力测试-Apache-JMeter安装使用"><a href="#P142-性能压测-压力测试-Apache-JMeter安装使用" class="headerlink" title="P142 性能压测-压力测试-Apache JMeter安装使用"></a>P142 性能压测-压力测试-Apache JMeter安装使用</h2><ul>
<li>加大运行内存</li>
</ul>
<h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>1、有错误率同开发确认，确定是否允许错误的发生或者错误率允许在多大的范围内；<br>2、 Throughput 吞吐量每秒请求的数大于并发数，则可以慢慢的往上面增加；若在压测的机 器性能很好的情况下，出现吞吐量小于并发数，说明并发数不能再增加了，可以慢慢的 往下减，找到最佳的并发数；<br>3、压测结束，登陆相应的 web 服务器查看 CPU 等性能指标，进行数据的分析;<br>4、最大的 tps，不断的增加并发数，加到 tps 达到一定值开始出现下降，那么那个值就是 最大的 tps。<br>5、最大的并发数：最大的并发数和最大的 tps 是不同的概率，一般不断增加并发数，达到 一个值后，服务器出现请求超时，则可认为该值为最大的并发数。<br>6、压测过程出现性能瓶颈，若压力机任务管理器查看到的 cpu、网络和 cpu 都正常，未达到 90%以上，则可以说明服务器有问题，压力机没有问题。<br>7、影响性能考虑点包括： 数据库、应用程序、中间件（tomact、Nginx）、网络和操作系统等方面<br>8、首先考虑自己的应用属于 CPU 密集型还是 IO 密集型</p>
<p><code>docker stats</code> #命令可以监听dockers容器中的每一个容器的内存情况</p>
<h1 id="P144-对内存与垃圾回收"><a href="#P144-对内存与垃圾回收" class="headerlink" title="P144 对内存与垃圾回收"></a>P144 对内存与垃圾回收</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/gulimall-es/1.jpg"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>记录的是正在执行的虚拟机字节码指令的地址，</p>
<p>此内存区域是唯一一个在JAVA虚拟机规范中没有规定任何OutOfMemoryError的区域</p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>描述的是 JAVA 方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧, 用于存储局部变量表，操作数栈，动态链接，方法接口等信息</p>
<p>局部变量表存储了编译期可知的各种基本数据类型、对象引用</p>
<p>虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈</p>
<p>本地方法栈类似于虚拟机栈，只不过本地方法栈使用的是本地方法</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>几乎所有的对象实例都在堆上分配内存，所有的对象实例以及数组都要在堆上分配。堆是垃圾收集器管理的主要区域，也被称为“GC 堆”;<br>也是我们优化最多考虑的地方。 </p>
<p>分为老年代和新生代，Java8引入了元空间，替换了新生代，元空间里面存储的是整个类。</p>
<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p>内存不够了，存不下东西了。</p>
<h3 id="FULL-GC"><a href="#FULL-GC" class="headerlink" title="FULL GC"></a>FULL GC</h3><p>是指一种全局性的垃圾回收，它会尝试回收整个堆内存中的所有对象，包括年轻代和老年代的对象。</p>
<p>FULL GC 通常发生在以下情况下：</p>
<ol>
<li><p><strong>老年代空间不足</strong>：当老年代无法容纳新对象时，会触发一次 FULL GC，尝试回收老年代的内存。</p>
</li>
<li><p><strong>永久代或元空间空间不足</strong>：在早期的JVM版本中，当永久代（Permanent Generation）无法容纳新的类元信息时，会触发 FULL GC。在JDK 8及之后版本中，类元信息存储在元空间（Metaspace）中，FULL GC通常发生在元空间耗尽本地内存时。</p>
</li>
<li><p><strong>显式调用</strong>：程序员可以通过调用<code>System.gc()</code>或者使用诸如G1垃圾回收器的<code>jcmd</code>命令来触发 FULL GC。</p>
</li>
<li><p>**CMS回收器中的”Concurrent Mode Failure”**：在CMS（Concurrent Mark and Sweep）回收器中，如果并发标记过程中老年代空间不足，将触发 FULL GC。</p>
</li>
</ol>
<p>FULL GC 是一种代价高昂的操作，因为它会暂停整个应用程序的运行，导致停顿时间较长，可能会影响应用程序的响应性能。因此，尽管 FULL GC 是必要的，但尽量避免频繁触发 FULL GC 对于保持应用程序的稳定性和性能是很重要的。</p>
<blockquote>
<p>总结:老年代空间不足，新生代或者元空间内存不足，或者直接调用，都可以触发FGC。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/gulimall-es/2.jpg"></p>
<h1 id="P145-小工具说明"><a href="#P145-小工具说明" class="headerlink" title="P145 小工具说明"></a>P145 小工具说明</h1><h2 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h2><p>如果你的电脑，全局配置了JDK,<br>直接win+r, &gt;jconsole ,</p>
<h2 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h2><p>这个是上面的升级版</p>
<p>监控内存泄露，跟踪垃圾回收，执行时内存、cpu 分析，线程分析…</p>
<h1 id="P146-中间件指标"><a href="#P146-中间件指标" class="headerlink" title="P146 中间件指标"></a>P146 中间件指标</h1><ul>
<li>当前正在运行的线程数不能超过设定的最大值。一般情况下系统性能较好的情况下，线 程数最小值设置 50 和最大值设置 200 比较合适。</li>
<li>当前运行的 JDBC 连接数不能超过设定的最大值。一般情况下系统性能较好的情况下， JDBC 最小值设置 50 和最大值设置 200 比较合适。</li>
<li>GC频率不能频繁，特别是 FULL GC 更不能频繁，一般情况下系统性能较好的情况下，JVM 最小堆大小和最大堆大小分别设置 1024M 比较合适。</li>
</ul>
<h2 id="数据库指标"><a href="#数据库指标" class="headerlink" title="数据库指标"></a>数据库指标</h2><ul>
<li>SQL 耗时越小越好，一般情况下微秒级别。</li>
<li>命中率越高越好，一般情况下不能低于 95%。</li>
<li>锁等待次数越低越好，等待时间越短越好。</li>
</ul>
<h2 id="JVM-分析-amp-调优"><a href="#JVM-分析-amp-调优" class="headerlink" title="JVM 分析 &amp; 调优"></a>JVM 分析 &amp; 调优</h2><p>jvm 调优，调的是稳定，并不能带给你性能的大幅提升。服务稳定的重要性就不用多说了，保证服务的稳定，gc 永远会是 Java<br>程序员需要考虑的不稳定因素之一。复杂和高并发下的服务，必须保证每次 gc 不会出现性能下降，各种性能指标不会出现波动，gc 回收规律而且 干净，找到合适的<br>jvm 设置。Full gc 最会影响性能，根据代码问题，避免 full gc 频率。可以适当调大年轻代容量，让大对象可以在年轻代触发 yong<br>gc，调整大对象在年轻代的回收频次，尽可能保证大对象在年轻代回收，减小老年代缩短回收时间；</p>
<h2 id="优化吞吐量"><a href="#优化吞吐量" class="headerlink" title="优化吞吐量"></a>优化吞吐量</h2><ul>
<li>中间件越多，性能损失越大，大多都损失在网络交互了；</li>
<li>Db（MySQL 优化）</li>
<li>模板的渲染速度（缓存）</li>
<li>静态资源</li>
</ul>
<h2 id="nginx动静分离"><a href="#nginx动静分离" class="headerlink" title="nginx动静分离"></a>nginx动静分离</h2><p>把静态资源都放在Nginx那里,减轻服务的压力。</p>
<ul>
<li>Xmx:设置堆的最大大小</li>
<li>Xms:设置堆的初始大小</li>
<li>Xmn:设置堆的新生代大小</li>
</ul>
<h2 id="优化三级分类获取数据"><a href="#优化三级分类获取数据" class="headerlink" title="优化三级分类获取数据"></a>优化三级分类获取数据</h2><blockquote>
<p>优化前</p>
<blockquote>
<p>对二级菜单的每次遍历都需要查询数据库，浪费大量资源<br>优化后<br>仅查询一次数据库，剩下的数据通过遍历得到并封装</p>
</blockquote>
</blockquote>
<h1 id="P151-本地缓存-分布式缓存"><a href="#P151-本地缓存-分布式缓存" class="headerlink" title="P151 本地缓存-分布式缓存"></a>P151 本地缓存-分布式缓存</h1><p>在开发中，凡是放入缓存中的数据我们都应该指定过期时间，使其可以在系统即使没有主动更新数据也能自动触发数据加载进缓存的流程。避免业务崩溃导致的数据永久不一致问题。</p>
<h1 id="P153-修改三级缓存"><a href="#P153-修改三级缓存" class="headerlink" title="P153 修改三级缓存"></a>P153 修改三级缓存</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="title function_">getCatalogJson</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//给缓存中放JSON字符串，拿出来的JSON字符串，还用逆转为能用的额对象类型：【序列化与反序列化】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、加入缓存逻辑，缓存中存在的数据是JSON字符串（JSON夸语言，跨平台兼容）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catalogJSON</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;catalogJSON&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(catalogJSON))&#123;</span><br><span class="line">        <span class="comment">//2、缓存中没有  查询数据库</span></span><br><span class="line">        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; catalogJsonFromDb = getCatalogJsonFromDb();</span><br><span class="line">        <span class="comment">//3、查到数据在放入缓存，将对象转为JSON放入缓存中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(catalogJsonFromDb);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;catalogJSON&quot;</span>,s);</span><br><span class="line">        <span class="keyword">return</span> catalogJsonFromDb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转为我们指定的对象</span></span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = JSON.parseObject(catalogJSON, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;() &#123;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="title function_">getCatalogJsonFromDb</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;查询了数据库.....&quot;</span>);</span><br><span class="line">    List&lt;CategoryEntity&gt; selectList = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    List&lt;CategoryEntity&gt; level1Categorys = getParent_cid(selectList, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//2、封装数据</span></span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; parent_cid = level1Categorys.stream().collect(Collectors.toMap(k -&gt; k.getCatId().toString(), v -&gt; &#123;</span><br><span class="line">        <span class="comment">//1、每一个的一级分类，查到这个一级分类的二级分类</span></span><br><span class="line">        List&lt;CategoryEntity&gt; categoryEntities = getParent_cid(selectList, v.getCatId());</span><br><span class="line">        <span class="comment">//2、封装上面的结果</span></span><br><span class="line">        List&lt;Catelog2Vo&gt; catelog2Vos = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (categoryEntities != <span class="literal">null</span>) &#123;</span><br><span class="line">            catelog2Vos = categoryEntities.stream().map(l2 -&gt; &#123;</span><br><span class="line">                <span class="type">Catelog2Vo</span> <span class="variable">catelog2Vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Catelog2Vo</span>(v.getCatId().toString(), <span class="literal">null</span>, l2.getCatId().toString(), l2.getName());</span><br><span class="line">                <span class="comment">//1、找当前二级分类的三级分类封装成vo</span></span><br><span class="line">                List&lt;CategoryEntity&gt; level3Catelog = getParent_cid(selectList, l2.getCatId());</span><br><span class="line">                <span class="keyword">if</span> (level3Catelog != <span class="literal">null</span>) &#123;</span><br><span class="line">                    List&lt;Catelog2Vo.Catelog3Vo&gt; collect = level3Catelog.stream().map(l3 -&gt; &#123;</span><br><span class="line">                        <span class="comment">//2、封装成指定格式</span></span><br><span class="line">                        Catelog2Vo.<span class="type">Catelog3Vo</span> <span class="variable">catelog3Vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Catelog2Vo</span>.Catelog3Vo(l2.getCatId().toString(), l3.getCatId().toString(), l3.getName());</span><br><span class="line">                        <span class="keyword">return</span> catelog3Vo;</span><br><span class="line">                    &#125;).collect(Collectors.toList());</span><br><span class="line">                    catelog2Vo.setCatalog3List(collect);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> catelog2Vo;</span><br><span class="line">            &#125;).collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> catelog2Vos;</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">return</span> parent_cid;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="P154-内存溢出问题及其解决方案"><a href="#P154-内存溢出问题及其解决方案" class="headerlink" title="P154 内存溢出问题及其解决方案"></a>P154 内存溢出问题及其解决方案</h1><blockquote>
<p>内存溢出：OutOfDirectMemoryError</p>
</blockquote>
<p>解决方案：更换客户端</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="P155-缓存击穿-穿透-雪崩"><a href="#P155-缓存击穿-穿透-雪崩" class="headerlink" title="P155 缓存击穿-穿透-雪崩"></a>P155 缓存击穿-穿透-雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数据库也无此记录，我们没有将这次查询的 null<br>写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>
<p>在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。</p>
<p><code>解决方案</code>：<br>缓存空结果、并且设置短的过期时间。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。</p>
<p><code>解决方案</code>：<br>原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。</p>
<p>这个时候，需要考虑一个问题：如果这个 key 在大量请求同时进来前正好失效，那么所 有对这个 key 的数据查询都落到 db，我们称为缓存击穿。</p>
<p><code>解决方案</code>：<br>加锁</p>
<h1 id="P156-加锁解决缓存击穿问题"><a href="#P156-加锁解决缓存击穿问题" class="headerlink" title="P156 加锁解决缓存击穿问题"></a>P156 加锁解决缓存击穿问题</h1><h2 id="本地锁"><a href="#本地锁" class="headerlink" title="本地锁"></a>本地锁</h2><p>使用本地锁解决缓存击穿的问题，如果是一个单体应用，我们可以用本地锁：synchronized，JUC（Lock），并且锁也是单列的，比如如果用synchronized （this）{ } 来加锁，这个this必须是单列的否则无法锁住，在分布式情况下，想要锁住所有，必须使用分布式锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从数据库查询并封装分类数据</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="title function_">getCatalogJsonFromDbWithLocalLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//只要是同一把锁，就能锁住需要这个锁的所有线程</span></span><br><span class="line">    <span class="comment">//1、synchronized (this)：SpringBoot所有的组件在容器中都是单例的。</span></span><br><span class="line">    <span class="comment">//TODO 本地锁：synchronized，JUC（Lock），在分布式情况下，想要锁住所有，必须使用分布式锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//得到锁以后，我们应该再去缓存中确定一次，如果没有才需要继续查询</span></span><br><span class="line">        <span class="keyword">return</span> getDataFromDb();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在获取锁之后立马再去查询一次缓存，此时没有在去查询数据库，查询数据之后在把数据放入缓存，然后才能释放锁。</p>
<h1 id="P157-本地锁在分布式下的问题"><a href="#P157-本地锁在分布式下的问题" class="headerlink" title="P157 本地锁在分布式下的问题"></a>P157 本地锁在分布式下的问题</h1><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// synchronized 关键字用于保护临界区代码，确保只有一个线程能够进入该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// public synchronized void increment() &#123;</span></span><br><span class="line">    <span class="comment">//     count++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// public synchronized int getCount() &#123;</span></span><br><span class="line">    <span class="comment">//     return count;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockExample</span>();</span><br><span class="line">        <span class="comment">// 创建两个线程，分别对共享资源进行操作</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                example.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                example.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + example.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>原子性</code><br>原子性是指一个操作是不可分割的单元，要么完全执行，要么完全不执行。在多线程环境中，原子性可以保证某些操作不会被中断，从而避免了竞态条件和并发问题。</p>
<p>IDEA创建三个运行实例，修改一下端口号即可，然后都跑一下，运行三个实例，然后测试，要用nginx转发网关，显然这个三个实列都会查一次。。</p>
<blockquote>
<p>本地锁，只能锁住当前进程，所以我们需要分布式锁。</p>
</blockquote>
<h1 id="P157-分布式锁原理与使用"><a href="#P157-分布式锁原理与使用" class="headerlink" title="P157 分布式锁原理与使用"></a>P157 分布式锁原理与使用</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/gulimall-es/3-1.jpg"></p>
<blockquote>
<p>先去占位，占到就执行逻辑，占不到就等待，方法<code>自旋</code>。</p>
</blockquote>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><ol>
<li>多个客户端尝试获取锁，可以同时去一个公共地方（如 Redis、数据库）占坑。</li>
<li>如果占坑成功，表示获取了锁，可以执行后续逻辑。</li>
<li>如果占坑失败，表示锁已经被其他客户端占用，等待一段时间后再次尝试。</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="title function_">getCatalogJsonFromDbWithRedisLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1、占分布式锁。去redis占坑</span></span><br><span class="line">    <span class="comment">//跟`setnx()`差不多</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb = getDataFromDb();</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataFromDb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonFromDbwithRedisLock（）;<span class="comment">//自旋的方式、，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><ul>
<li><p>setnx占好了位,业务代码异常或者程序在页面过程中宕机。没有执行删除锁逻辑,这就造成了死锁。</p>
<blockquote>
<p>解决: 设置锁的自动过期，即使没有删除，会自动删除。</p>
</blockquote>
</li>
<li><p>setnx设置好，正要去设置过期时间，宕机。又死锁了。</p>
<blockquote>
<p>解决:设置过期时间和占位必须是原子的。 使用setnx ex</p>
</blockquote>
</li>
<li><p>如果由于业务时间很长，锁自己过期了,我们直接删除，有可能把别人正在持有的锁删除了。</p>
<blockquote>
<p>解决:占锁的时候，值指定为uuid, 每个人匹配是自己的锁才删除。</p>
</blockquote>
</li>
<li><p>如果正好判断是当前值，正要删除锁的时候，锁已经过期,别人已经设置到了新的值。那么我们删除的是别人的锁。</p>
<blockquote>
<p>删除锁必须保证原子性。使用redis+Lua脚本完成。</p>
</blockquote>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>总结:保证加锁[占位+过期时间]和删除锁[判断+删除]的原子性。更难的事情,锁的自动续期。</p>
<p><code>手写代码</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="title function_">getCatalogJson</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取分布式锁成功...&quot;</span>);</span><br><span class="line">        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dataFromDb = getCatalogJsonFromDb();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">lock1</span> <span class="operator">=</span> redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;Long&gt;(script, Long.class)</span><br><span class="line">                    , Arrays.asList(<span class="string">&quot;lock&quot;</span>), uuid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataFromDb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取分布式锁失败...等待重试&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getCatalogJson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setnx-与-ex"><a href="#setnx-与-ex" class="headerlink" title="setnx 与 ex"></a>setnx 与 ex</h2><ol>
<li><code>SETNX</code>: 用于设置一个键的值，但只在该键不存在的情况下才进行设置。如果键已经存在，那么 <code>SETNX</code> 命令将不会做任何操作。</li>
<li><code>EX</code>: 用于为键设置过期时间。可以与 <code>SET</code> 命令一起使用，以设置键的值并为其设置过期时间。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET key value EX 10</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>并发与并行</code><br>并发强调多个任务能够交替执行，而并行强调多个任务同时执行。</p>
<h1 id="P161、缓存-分布式锁"><a href="#P161、缓存-分布式锁" class="headerlink" title="P161、缓存-分布式锁"></a>P161、缓存-分布式锁</h1><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>当一个线程在持有锁的情况下，可以多次进入同步代码块或方法，而不会被阻塞，这个特性就叫做可重入（或递归）锁。这意味着线程可以反复地获得同一个锁，而不会因为自己已经持有锁而被阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Entering methodA&quot;</span>);</span><br><span class="line">        methodB();</span><br><span class="line">        System.out.println(<span class="string">&quot;Exiting methodA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside methodB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="锁的续期"><a href="#锁的续期" class="headerlink" title="锁的续期"></a>锁的续期</h2><p>大家都知道，如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内<br>部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>允许程序在进行某些耗时操作时不必等待操作完成，而是可以继续执行其他任务。在异步模型中，任务的执行不会阻塞程序的主线程，而是通过回调、事件处理等机制来处理任务的完成或者错误。</p>
<h2 id="看门狗"><a href="#看门狗" class="headerlink" title="看门狗()"></a>看门狗()</h2><p>自动延长锁的时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁以后10秒钟自动解锁，看门狗不续命</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步锁"><a href="#异步锁" class="headerlink" title="异步锁"></a>异步锁</h2><ol>
<li><p><code>lockAsync()</code> 方法会异步地获取锁，如果成功获取锁，返回一个 <code>Future</code> 对象，可以通过该对象来获取锁的状态。</p>
</li>
<li><p><code>lockAsync(10, TimeUnit.SECONDS)</code> 会在最多等待10秒的情况下异步获取锁，如果在指定时间内成功获取锁，也会返回一个 <code>Future</code> 对象。</p>
</li>
<li><p><code>tryLockAsync(100, 10, TimeUnit.SECONDS)</code> 会尝试在最多等待100毫秒的情况下异步获取锁，如果在指定时间内成功获取锁，也会返回一个 <code>Future</code> 对象，<code>Future</code> 的结果会是一个布尔值，表示是否成功获取锁。</p>
</li>
</ol>
<blockquote>
<p>RLock对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁</p>
</blockquote>
<h1 id="P162"><a href="#P162" class="headerlink" title="P162"></a>P162</h1><h2 id="tryLock-和-lock"><a href="#tryLock-和-lock" class="headerlink" title="tryLock() 和 lock()"></a><code>tryLock()</code> 和 <code>lock()</code></h2><ol>
<li><code>tryLock()</code> 是非阻塞的，它会立即返回获取锁的结果；</li>
<li>而 <code>lock()</code> 是阻塞的，如果锁被其他线程占用，它会一直等待直到获取到锁为止。</li>
</ol>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ol>
<li><strong>读锁</strong>：允许多个线程同时获得锁并读取共享资源，但在读取期间不允许其他线程获取写锁。读锁可以提高并发读取性能，适用于读操作频繁的场景。</li>
<li><strong>写锁</strong>：只允许一个线程获得锁并对共享资源进行写操作，其他线程在此期间无法获取读锁或写锁。写锁用于保护写操作的原子性和一致性。</li>
</ol>
<p>基本案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证一定能读到最新数据,修改期间，写锁是一个排他锁（互斥锁、独享锁）。读锁是一个共享锁</span></span><br><span class="line"><span class="comment">//写锁没释放读就必须等待</span></span><br><span class="line"><span class="comment">// 读 + 读： 相当于无锁，并发读，只会在redis中记录好，所有当前的读锁。他们都会同时加锁成功</span></span><br><span class="line"><span class="comment">// 写 + 读： 等待写锁释放</span></span><br><span class="line"><span class="comment">// 写 + 写： 阻塞方式</span></span><br><span class="line"><span class="comment">// 读 + 写： 有读锁。写也需要等待。</span></span><br><span class="line"><span class="comment">// 只要有写的存在，都必须等待</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/write&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">writeValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;rw-lock&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1、改数据加写锁，读数据加读锁</span></span><br><span class="line">        rLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;写锁加锁成功...&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        s = UUID.randomUUID().toString();</span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);<span class="comment">// 模仿执行服务</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;writeValue&quot;</span>,s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">// 最后必跑这个语句</span></span><br><span class="line">        rLock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;写锁释放&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/read&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;rw-lock&quot;</span>);</span><br><span class="line">    <span class="comment">//ReentrantReadWriteLock writeLock = new ReentrantReadWriteLock();</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//加读锁</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    rLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读锁加锁成功&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        s = redisTemplate.opsForValue().get(<span class="string">&quot;writeValue&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rLock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;读锁释放&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="P164-闭锁测试"><a href="#P164-闭锁测试" class="headerlink" title="P164 闭锁测试"></a>P164 闭锁测试</h1><h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放假，锁门</span></span><br><span class="line"><span class="comment"> * 5个班全部走完，我们可以锁大门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/lockDoor&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">lockDoor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">door</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;door&quot;</span>);</span><br><span class="line">    door.trySetCount(<span class="number">5</span>);<span class="comment">// 表示5个班</span></span><br><span class="line">    door.await(); <span class="comment">//等待闭锁都完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;放假了...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/gogogo/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">gogogo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">door</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;door&quot;</span>);</span><br><span class="line">    door.countDown();<span class="comment">//这个是内部函数，调用的话，就计数减一。</span></span><br><span class="line">    <span class="keyword">return</span> id+<span class="string">&quot;班的人都走了...&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="P165-信号量测试"><a href="#P165-信号量测试" class="headerlink" title="P165 信号量测试"></a>P165 信号量测试</h1><p>可以用于限流场景，一个请求过来先获取一个信号，比如设置了1000个则1000个请求完必须先等其他的释放之后才能操作。</p>
<p>信号量为存储在redis中的一个数字，当这个数字大于0时，即可以调用acquire()方法增加数量，也可以调用release()方法减少数量，但是当调用release()之后小于0的话方法就会阻塞，直到数字大于0</p>
<p><code>RSemaphore</code> 是 Redisson 提供的分布式信号量（Semaphore）实现。</p>
<ul>
<li><code>semaphore.acquire()</code>：获取信号量，如果当前可用的信号量数量不足，则会阻塞等待直到可以获取到信号量。</li>
<li><code>semaphore.acquireAsync()</code>：异步获取信号量，如果当前可用的信号量数量不足，则会异步等待直到可以获取到信号量。</li>
<li><code>semaphore.acquire(int permits)</code>：获取指定数量的信号量，参数 <code>permits</code> 指定了需要获取的信号量数量。</li>
<li><code>semaphore.tryAcquire()</code>：尝试获取信号量，如果当前可用的信号量数量足够，则会立即返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>semaphore.tryAcquireAsync()</code>：异步尝试获取信号量，如果当前可用的信号量数量足够，则会立即返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>semaphore.tryAcquire(int permits, long waitTime, TimeUnit unit)</code>：在指定的等待时间内尝试获取信号量，如果在等待时间内能够获取到信号量，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>semaphore.tryAcquireAsync(int permits, long waitTime, TimeUnit unit)</code>：异步在指定的等待时间内尝试获取信号量，如果在等待时间内能够获取到信号量，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>semaphore.release(int permits)</code>：释放指定数量的信号量，参数 <code>permits</code> 指定了需要释放的信号量数量。</li>
<li><code>semaphore.release()</code>：释放一个信号量。</li>
<li><code>semaphore.releaseAsync(int permits)</code>：异步释放指定数量的信号量，参数 <code>permits</code> 指定了需要释放的信号量数量。</li>
<li><code>semaphore.releaseAsync()</code>：异步释放一个信号量。</li>
</ul>
<h1 id="P166-缓存一致性问题"><a href="#P166-缓存一致性问题" class="headerlink" title="P166 缓存一致性问题"></a>P166 缓存一致性问题</h1><blockquote>
<p>如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢？</p>
</blockquote>
<p><code>解决方案</code></p>
<ol>
<li><p>先写缓存，再写数据库</p>
</li>
<li><p>先写数据库，再写缓存</p>
</li>
<li><p>先删缓存，再写数据库</p>
</li>
<li><p>先写数据库，再删缓存</p>
</li>
</ol>
<p>使用第四种方法。</p>
<h1 id="P167-SpringCache"><a href="#P167-SpringCache" class="headerlink" title="P167 SpringCache"></a>P167 SpringCache</h1><h1 id="bug日志"><a href="#bug日志" class="headerlink" title="bug日志"></a>bug日志</h1><p>8-25日，8：20,es配置好了，卡了10天。</p>
<p>9-25日，开始学习谷粒商城，从P139开始学习，目前遇到的困难是:nginx 搞不明白。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://risingrode.github.io">fcw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://risingrode.github.io/post/gulimall-es.html">https://risingrode.github.io/post/gulimall-es.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://risingrode.github.io" target="_blank">阿威的代码小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/es/">es</a></div><div class="post_share"><div class="social-share" data-image="https://i0.hippopx.com/photos/583/885/292/tianjin-twilight-city-scenery-preview.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9.html" title="面试高频考点"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/997/702/475/road-train-landscape-storm-thumb.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试高频考点</div></div></a></div><div class="next-post pull-right"><a href="/post/%E6%90%AD%E5%BB%BAvpn.html" title="搭建vpn"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">搭建vpn</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/girl.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">fcw</div><div class="author-info__description">一个收藏回忆与分享技术的地方！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Risingrode"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到cwRising的博客</div></div><div class="card-widget"><div class="item-headline"><i></i><span></span></div><div class="item-content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker"><span class="toc-number">1.</span> <span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85es%E5%92%8Ckinana"><span class="toc-number">1.1.</span> <span class="toc-text">安装es和kinana</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">分词器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85nginx"><span class="toc-number">1.3.</span> <span class="toc-text">安装nginx</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nested"><span class="toc-number">2.1.</span> <span class="toc-text">nested</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E4%BB%A3%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">Java代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Jrebel%E9%85%8D%E7%BD%AE"><span class="toc-number">4.</span> <span class="toc-text">Jrebel配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#thmleft"><span class="toc-number">5.</span> <span class="toc-text">thmleft</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">正向代理与反向代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%88%90%E5%8A%9F"><span class="toc-number">7.</span> <span class="toc-text">nginx 反向代理成功</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%89%8D%E7%A1%AE%E4%BF%9D%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E6%89%A7%E8%A1%8C%E4%BA%86-%E5%88%9B%E5%BB%BA%E4%BA%86%E7%9B%B8%E5%85%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E5%90%A6%E5%88%99nginx%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8"><span class="toc-number">8.</span> <span class="toc-text">执行前确保上面的步骤执行了  创建了相关的配置文件 否则nginx无法启动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P141-%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B"><span class="toc-number">9.</span> <span class="toc-text">P141- 性能压测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.</span> <span class="toc-text">内存泄漏和并发与同步问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">9.2.</span> <span class="toc-text">性能指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P142-%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-Apache-JMeter%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">P142 性能压测-压力测试-Apache JMeter安装使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-number">10.</span> <span class="toc-text">结果分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P144-%E5%AF%B9%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">11.</span> <span class="toc-text">P144 对内存与垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">11.2.</span> <span class="toc-text">虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">11.3.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OOM"><span class="toc-number">11.3.1.</span> <span class="toc-text">OOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FULL-GC"><span class="toc-number">11.3.2.</span> <span class="toc-text">FULL GC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P145-%E5%B0%8F%E5%B7%A5%E5%85%B7%E8%AF%B4%E6%98%8E"><span class="toc-number">12.</span> <span class="toc-text">P145 小工具说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jconsole"><span class="toc-number">12.1.</span> <span class="toc-text">jconsole</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvisualvm"><span class="toc-number">12.2.</span> <span class="toc-text">jvisualvm</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P146-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8C%87%E6%A0%87"><span class="toc-number">13.</span> <span class="toc-text">P146 中间件指标</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8C%87%E6%A0%87"><span class="toc-number">13.1.</span> <span class="toc-text">数据库指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E5%88%86%E6%9E%90-amp-%E8%B0%83%E4%BC%98"><span class="toc-number">13.2.</span> <span class="toc-text">JVM 分析 &amp; 调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">13.3.</span> <span class="toc-text">优化吞吐量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB"><span class="toc-number">13.4.</span> <span class="toc-text">nginx动静分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%B8%89%E7%BA%A7%E5%88%86%E7%B1%BB%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">13.5.</span> <span class="toc-text">优化三级分类获取数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P151-%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="toc-number">14.</span> <span class="toc-text">P151 本地缓存-分布式缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P153-%E4%BF%AE%E6%94%B9%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">15.</span> <span class="toc-text">P153 修改三级缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P154-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">16.</span> <span class="toc-text">P154 内存溢出问题及其解决方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P155-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9"><span class="toc-number">17.</span> <span class="toc-text">P155 缓存击穿-穿透-雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">17.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">17.2.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">17.3.</span> <span class="toc-text">缓存击穿</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P156-%E5%8A%A0%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">18.</span> <span class="toc-text">P156 加锁解决缓存击穿问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%94%81"><span class="toc-number">18.1.</span> <span class="toc-text">本地锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P157-%E6%9C%AC%E5%9C%B0%E9%94%81%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">19.</span> <span class="toc-text">P157 本地锁在分布式下的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">19.1.</span> <span class="toc-text">锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P157-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">20.</span> <span class="toc-text">P157 分布式锁原理与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">20.1.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">20.2.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">20.3.</span> <span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setnx-%E4%B8%8E-ex"><span class="toc-number">20.4.</span> <span class="toc-text">setnx 与 ex</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P161%E3%80%81%E7%BC%93%E5%AD%98-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">21.</span> <span class="toc-text">P161、缓存-分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">21.1.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%BB%AD%E6%9C%9F"><span class="toc-number">21.2.</span> <span class="toc-text">锁的续期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">21.3.</span> <span class="toc-text">异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-number">21.4.</span> <span class="toc-text">看门狗()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%94%81"><span class="toc-number">21.5.</span> <span class="toc-text">异步锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P162"><span class="toc-number">22.</span> <span class="toc-text">P162</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tryLock-%E5%92%8C-lock"><span class="toc-number">22.1.</span> <span class="toc-text">tryLock() 和 lock()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">22.2.</span> <span class="toc-text">读写锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P164-%E9%97%AD%E9%94%81%E6%B5%8B%E8%AF%95"><span class="toc-number">23.</span> <span class="toc-text">P164 闭锁测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E9%94%81"><span class="toc-number">23.1.</span> <span class="toc-text">闭锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P165-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%B5%8B%E8%AF%95"><span class="toc-number">24.</span> <span class="toc-text">P165 信号量测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P166-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">25.</span> <span class="toc-text">P166 缓存一致性问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P167-SpringCache"><span class="toc-number">26.</span> <span class="toc-text">P167 SpringCache</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bug%E6%97%A5%E5%BF%97"><span class="toc-number">27.</span> <span class="toc-text">bug日志</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/matlab.html" title="matlab复习题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/997/702/475/road-train-landscape-storm-thumb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="matlab复习题"/></a><div class="content"><a class="title" href="/post/matlab.html" title="matlab复习题">matlab复习题</a><time datetime="2023-10-09T10:16:07.000Z" title="发表于 2023-10-09 18:16:07">2023-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html" title="计算机组成原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/997/702/475/road-train-landscape-storm-thumb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机组成原理"/></a><div class="content"><a class="title" href="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html" title="计算机组成原理">计算机组成原理</a><time datetime="2023-10-09T02:14:32.000Z" title="发表于 2023-10-09 10:14:32">2023-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/os_class.html" title="操作系统复习题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/997/702/475/road-train-landscape-storm-thumb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统复习题"/></a><div class="content"><a class="title" href="/post/os_class.html" title="操作系统复习题">操作系统复习题</a><time datetime="2023-10-08T00:27:55.000Z" title="发表于 2023-10-08 08:27:55">2023-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C.html" title="图解网络"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/997/702/475/road-train-landscape-storm-thumb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图解网络"/></a><div class="content"><a class="title" href="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C.html" title="图解网络">图解网络</a><time datetime="2023-09-13T00:25:50.000Z" title="发表于 2023-09-13 08:25:50">2023-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" title="操作系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/997/702/475/road-train-landscape-storm-thumb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" title="操作系统">操作系统</a><time datetime="2023-09-12T00:03:50.000Z" title="发表于 2023-09-12 08:03:50">2023-09-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By fcw</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://risingrode.github.io/post/gulimall-es.html'
    this.page.identifier = '/post/gulimall-es.html'
    this.page.title = '谷粒商城-es篇'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><link rel="stylesheet" href="/dist/APlayer.min.css"> <div id="aplayer"></div> <script type="text/javascript" src="/dist/APlayer.min.js"></script> <script type="text/javascript" src="/js/aplayer/music.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>