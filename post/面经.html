<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>面经 | 阿威的代码小站</title><meta name="author" content="fcw,3185087246@protonmail.com"><meta name="copyright" content="fcw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面经请求一个网页链接的过程，要求越详细越好。以下是请求一个网页链接的详细过程：  DNS解析：  客户端（通常是Web浏览器）获取目标网页的URL（统一资源定位符）。 客户端提取URL中的域名部分，例如www.example.com。 客户端向本地DNS服务器发起域名解析请求，询问目标网页的IP地址。   TCP连接建立：  客户端通过本地DNS服务器获取目标网页的IP地址。 客户端使用目标网页的">
<meta property="og:type" content="article">
<meta property="og:title" content="面经">
<meta property="og:url" content="https://risingrode.github.io/post/%E9%9D%A2%E7%BB%8F.html">
<meta property="og:site_name" content="阿威的代码小站">
<meta property="og:description" content="面经请求一个网页链接的过程，要求越详细越好。以下是请求一个网页链接的详细过程：  DNS解析：  客户端（通常是Web浏览器）获取目标网页的URL（统一资源定位符）。 客户端提取URL中的域名部分，例如www.example.com。 客户端向本地DNS服务器发起域名解析请求，询问目标网页的IP地址。   TCP连接建立：  客户端通过本地DNS服务器获取目标网页的IP地址。 客户端使用目标网页的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg">
<meta property="article:published_time" content="2023-06-29T08:06:29.000Z">
<meta property="article:modified_time" content="2023-10-12T15:36:42.732Z">
<meta property="article:author" content="fcw">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://risingrode.github.io/post/%E9%9D%A2%E7%BB%8F.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面经',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-12 23:36:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="/live2d-widget-master/autoload.js"></script><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/girl.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 优质网站链接</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="阿威的代码小站"><span class="site-name">阿威的代码小站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 优质网站链接</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面经</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-29T08:06:29.000Z" title="发表于 2023-06-29 16:06:29">2023-06-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-12T15:36:42.732Z" title="更新于 2023-10-12 23:36:42">2023-10-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">25.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>76分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面经"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><h2 id="请求一个网页链接的过程，要求越详细越好。"><a href="#请求一个网页链接的过程，要求越详细越好。" class="headerlink" title="请求一个网页链接的过程，要求越详细越好。"></a>请求一个网页链接的过程，要求越详细越好。</h2><p>以下是请求一个网页链接的详细过程：</p>
<ol>
<li><p>DNS解析：</p>
<ul>
<li>客户端（通常是Web浏览器）获取目标网页的URL（统一资源定位符）。</li>
<li>客户端提取URL中的域名部分，例如<a target="_blank" rel="noopener" href="http://www.example.com./">www.example.com。</a></li>
<li>客户端向本地DNS服务器发起域名解析请求，询问目标网页的IP地址。</li>
</ul>
</li>
<li><p>TCP连接建立：</p>
<ul>
<li>客户端通过本地DNS服务器获取目标网页的IP地址。</li>
<li>客户端使用目标网页的IP地址与服务器建立TCP连接。</li>
<li>客户端向服务器发送一个TCP连接请求（称为三次握手），建立可靠的通信连接。</li>
</ul>
</li>
<li><p>发送HTTP请求：</p>
<ul>
<li>客户端向服务器发送一个HTTP请求报文，包括以下内容：<ul>
<li>请求行：包含请求方法（GET、POST等）和请求的资源路径。</li>
<li>请求头：包含附加的请求信息，如浏览器类型、语言偏好等。</li>
<li>请求体（对于POST请求）：包含提交的数据。</li>
</ul>
</li>
<li>客户端将HTTP请求报文发送到服务器端。</li>
</ul>
</li>
<li><p>服务器处理请求：</p>
<ul>
<li>服务器接收到客户端发送的HTTP请求。</li>
<li>服务器解析请求报文，获取请求的资源路径和其他相关信息。</li>
<li>服务器根据请求的资源路径和服务器配置，处理请求并生成相应的响应。</li>
</ul>
</li>
<li><p>服务器发送HTTP响应：</p>
<ul>
<li>服务器生成一个HTTP响应报文，包括以下内容：<ul>
<li>状态行：指示响应状态码（如200表示成功）和响应的文本描述。</li>
<li>响应头：包含附加的响应信息，如内容类型、日期等。</li>
<li>响应体：包含请求的资源或响应的数据。</li>
</ul>
</li>
<li>服务器将HTTP响应报文发送回客户端。</li>
</ul>
</li>
<li><p>客户端接收HTTP响应：</p>
<ul>
<li>客户端接收到服务器发送的HTTP响应。</li>
<li>客户端解析响应报文，提取响应状态码、响应头和响应体等信息。</li>
</ul>
</li>
<li><p>渲染和显示网页：</p>
<ul>
<li>如果响应状态码为200（成功），客户端将根据响应的内容类型（如HTML、CSS、JavaScript等）对响应体进行解析。</li>
<li>客户端渲染并显示网页内容，将HTML解析为可视化的网页，执行JavaScript代码，加载和显示网页中的资源（如图像、样式表等）。</li>
</ul>
</li>
<li><p>关闭TCP连接：</p>
<ul>
<li>客户端和服务器之间的数据传输完成后，客户端和服务器通过TCP连接进行握手，关闭连接。</li>
</ul>
</li>
</ol>
<p>以上是一个典型的网页链接请求的详细过程。每个步骤都是为了确保客户端能够与服务器建立可靠的通信连接，并成功请求和接收网页内容。</p>
<h2 id="Redis-将数据存储在内存中，mysql把数据存在哪里？"><a href="#Redis-将数据存储在内存中，mysql把数据存在哪里？" class="headerlink" title="Redis 将数据存储在内存中，mysql把数据存在哪里？"></a>Redis 将数据存储在内存中，mysql把数据存在哪里？</h2><p>MySQL将数据存储在磁盘上。它使用文件系统来管理数据文件，将数据持久地存储在硬盘上的文件中。MySQL的数据文件通常被称为表空间（tablespace），包括系统表空间和用户表空间。</p>
<p>系统表空间包含了MySQL的系统表和共享表数据。这些表存储了关于数据库和表结构的元数据信息。</p>
<p>用户表空间用于存储用户创建的表和数据。每个数据库都有一个对应的用户表空间，其中包含该数据库中所有表的数据。</p>
<p>在用户表空间中，每个表都有对应的表文件，用于存储表的数据和索引。这些表文件通常以<code>.frm</code>扩展名的文件存储表的定义，以及<code>.ibd</code>扩展名的文件存储表的数据和索引。</p>
<p>MySQL还使用日志文件来记录数据库的修改操作，包括事务日志和重做日志。这些日志文件位于磁盘上，用于保证数据的一致性和持久性。</p>
<p>需要注意的是，MySQL也可以配置为使用内存表（Memory Table），这种表将数据存储在内存中，但是它们的数据不是持久的，会在MySQL重启或关闭时丢失。而Redis则是一种基于内存的键值存储系统，它将数据完全存储在内存中，并通过持久化机制将数据定期写入磁盘以保证数据的持久性。</p>
<h2 id="内存与磁盘的区别"><a href="#内存与磁盘的区别" class="headerlink" title="内存与磁盘的区别"></a>内存与磁盘的区别</h2><p>内存（RAM）和磁盘（硬盘或固态硬盘）是计算机中用于存储数据的两个主要组件，它们在以下几个方面有着明显的区别：</p>
<ol>
<li><p>工作原理：内存是计算机中的临时存储介质，用于存储正在运行的程序和数据。它通过电子电荷在集成电路中的状态变化来存储和访问数据，数据在断电后会被清空。磁盘是永久存储介质，用于长期存储数据。它利用磁性材料上的磁场来存储和读取数据，数据在断电后仍然保留。</p>
</li>
<li><p>速度：内存的读写速度非常快，可以以纳秒级别的速度访问数据。这使得内存非常适合于需要快速访问的数据和程序。磁盘的读写速度相对较慢，以毫秒级别甚至更长的时间访问数据。</p>
</li>
<li><p>容量：内存的容量通常比较有限，以几千兆字节（GB）为单位。磁盘的容量相对较大，可以达到几十到几千或更多的千兆字节（TB）。</p>
</li>
<li><p>成本：内存的成本相对较高，以每千兆字节（GB）为单位计算。磁盘的成本相对较低，以每千兆字节（GB）或每千兆位（GB）为单位计算。</p>
</li>
<li><p>数据持久性：内存是易失性存储，断电后数据会丢失。磁盘是非易失性存储，断电后数据仍然保留。</p>
</li>
</ol>
<p>基于这些区别，内存通常用于临时存储正在运行的程序和数据，以提供快速访问速度。磁盘用于长期存储大量数据和文件，但相对访问速度较慢。计算机系统通常会使用内存作为缓存，将经常访问的数据存储在内存中，以提高整体性能。</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树（B-tree）是一种自平衡的搜索树数据结构，广泛应用于文件系统、数据库和文件索引等领域。它具有高效的插入、删除和查找操作，同时适应大规模数据集的存储和访问。</p>
<p>B树的特点包括：</p>
<ol>
<li><p>多路搜索树：B树是一种多路搜索树，每个节点可以存储多个键值对。相比于二叉搜索树，B树的节点可以拥有更多的子节点，从而减少树的高度，提高搜索效率。</p>
</li>
<li><p>自平衡：B树通过保持树的平衡性来保证高效的操作。在插入和删除操作后，B树会进行自动的平衡调整，确保树的高度在可接受的范围内，避免数据倾斜和性能下降。</p>
</li>
<li><p>有序存储：B树的节点中的键值对按照特定的顺序进行存储。这使得B树在范围查询和顺序遍历方面表现出良好的性能。</p>
</li>
<li><p>多级索引：B树支持多级索引结构，通过根节点、内部节点和叶节点的层次结构，可以快速定位和访问存储在树中的数据。</p>
</li>
<li><p>磁盘友好：B树的节点大小通常与磁盘页的大小相匹配。这意味着在磁盘上读取或写入一个节点时，可以一次性处理更多的键值对，减少磁盘I&#x2F;O操作次数，提高性能。</p>
</li>
</ol>
<p>总体而言，B树通过自平衡和多路搜索的特性，在处理大规模数据和频繁的插入、删除、查找操作时表现出较好的性能。它是许多常见数据存储系统的核心组件之一，用于高效地管理和访问数据。</p>
<h2 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h2><p>HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是用于在网络上传输数据的两种协议。它们之间的主要区别在于安全性和数据传输方式：</p>
<ol>
<li><p>安全性：HTTP是明文传输协议，数据在传输过程中不经过加密处理，容易被恶意攻击者截获和窃听。HTTPS使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对通信进行加密，确保数据在传输过程中的机密性和完整性，使得数据更加安全。</p>
</li>
<li><p>加密方式：HTTP不使用加密，数据以纯文本形式传输。HTTPS使用SSL或TLS协议对数据进行加密，使数据在传输过程中变得不可读。</p>
</li>
<li><p>端口号：HTTP默认使用80端口进行通信，而HTTPS默认使用443端口。这样使得网络服务器能够根据端口号来区分处理HTTP请求和HTTPS请求。</p>
</li>
<li><p>证书要求：HTTPS需要通过数字证书来验证服务器的身份。数字证书由可信任的第三方机构（如CA机构）签发，用于证明服务器的身份和确保通信的安全性。而HTTP不需要证书验证。</p>
</li>
<li><p>性能：HTTPS的加密和解密过程需要消耗更多的计算资源，因此比起HTTP会稍微慢一些。然而，随着计算机处理能力的提升，HTTPS的性能差距逐渐缩小。</p>
</li>
</ol>
<p>综上所述，HTTPS相较于HTTP在数据传输过程中提供了更高的安全性和保护用户隐私的能力。因此，对于处理敏感信息和需要保密性的场景，使用HTTPS是更为推荐的选择。</p>
<h2 id="Socket是什么"><a href="#Socket是什么" class="headerlink" title="Socket是什么"></a>Socket是什么</h2><p>Socket（套接字）是计算机网络中用于实现网络通信的编程接口或抽象层。它允许应用程序通过网络发送和接收数据，实现不同设备之间的通信。</p>
<p>Socket提供了一种标准化的方式，使得应用程序能够通过网络进行数据传输。它基于网络协议栈（例如TCP&#x2F;IP协议栈）来实现数据的分割、传输和重组。</p>
<p>通过使用Socket，应用程序可以创建一个网络套接字（socket），并通过该套接字与其他设备建立连接、发送和接收数据。套接字可以在不同设备之间的不同计算机上进行通信，允许客户端和服务器之间的双向数据传输。</p>
<p>在网络编程中，Socket通常使用一组API函数来进行操作，这些函数包括创建套接字、绑定套接字到特定的IP地址和端口、监听连接请求、接受连接、发送和接收数据等。</p>
<p>不同类型的套接字可以支持不同的网络协议和通信模式，例如TCP套接字用于可靠的面向连接的通信，UDP套接字用于无连接的不可靠通信。</p>
<p>总结来说，Socket是一种网络编程接口，允许应用程序通过网络进行数据传输和通信。它提供了一种标准化的方式来实现网络通信，使得应用程序能够在不同设备之间进行数据交换。</p>
<hr>
<ol>
<li>GET和POST区别：</li>
</ol>
<ul>
<li>GET用于获取资源，POST用于提交资源。</li>
<li>GET请求的参数会附加在URL的后面，以查询字符串的形式传递，而POST请求的参数在请求体中传递，不会在URL中显示。</li>
<li>GET请求对数据长度有限制，一般在URL长度上限范围内，而POST请求对数据长度没有限制。</li>
<li>GET请求的数据会被保存在浏览器的历史记录中，而POST请求的数据不会保存。</li>
<li>GET请求会被浏览器主动缓存，POST请求不会被缓存，需要再次确认是否提交。</li>
</ul>
<ol start="2">
<li>HTTP和HTTPS区别：</li>
</ol>
<ul>
<li>HTTP是明文传输协议，数据在传输过程中不经过加密处理，容易被截获和窃听。HTTPS使用SSL&#x2F;TLS协议对通信进行加密，保证数据的机密性和完整性。</li>
<li>HTTP默认使用80端口进行通信，而HTTPS默认使用443端口。</li>
<li>HTTP不需要证书验证，而HTTPS需要通过数字证书验证服务器的身份。</li>
<li>HTTPS的安全性更高，但相对而言会消耗更多的计算资源，性能稍低于HTTP。</li>
</ul>
<ol start="3">
<li>十进制和二进制的转换：</li>
</ol>
<ul>
<li>十进制转二进制：将十进制数不断除以2，直到商为0，然后将每次的余数从下往上依次排列，即为二进制表示。</li>
<li>二进制转十进制：将二进制数从右往左依次乘以2的幂，对应位置上为1的位对应的幂相加，得到的和即为十进制表示。</li>
</ul>
<ol start="4">
<li><p>数字反转：将给定的数从个位开始逐位取出，然后按相反的顺序组合起来。</p>
</li>
<li><p>判断一个数是否为2的幂：一个数如果是2的幂，则其二进制表示中只有一个1，其他位都是0。可以使用位运算进行判断，如果数n满足 n &amp; (n-1) &#x3D;&#x3D;<br>0，则它是2的幂。</p>
</li>
<li><p>MySQL调优：</p>
</li>
</ol>
<ul>
<li>使用索引来加速查询。</li>
<li>优化SQL语句，避免全表扫描和不必要的连接。</li>
<li>适当调整数据库的参数设置，如缓冲区大小、连接数等。</li>
<li>避免使用过多的触发器和存储过程，以减少数据库的负载。</li>
<li>合理设计数据库表结构，避免冗余和重复数据。</li>
<li>定期进行数据库备份和优化，清理无用数据和日志。</li>
</ul>
<ol start="7">
<li><p>IO多路复用：<br>IO多路复用是一种通过单个线程来监听多个IO事件的机制，它可以同时监视多个文件描述符的可读、可写等事件状态。常见的IO多路复用模型包括select、poll和epoll。它可以提高程序的并发性能，避免使用多线程或多进程处理大量的并发连接。</p>
</li>
<li><p>HAVING和WHERE区别：</p>
</li>
</ol>
<ul>
<li>WHERE用于在查询中指定条件筛选行，它在对表进行分组之前过滤数据。</li>
<li>HAVING用于在查询的结果集上指定条件，它在对分组后的结果进行过滤。</li>
</ul>
<ol start="9">
<li>Redis数据类型和数据结构：<br>Redis支持多种数据类型，包括字符串（String）、哈希（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set）和位图（Bitmap）等。</li>
</ol>
<ul>
<li>有序集合（Sorted Set）使用跳表（Skip List）和字典（Hash Table）两种数据结构，跳表用于提供有序性，字典用于提供快速的成员查找和删除操作。</li>
<li>跳表是一种特殊的链表结构，通过在每个节点上增加多个指针来实现快速的查找和插入操作。</li>
</ul>
<ol start="10">
<li>第K大算法：<br>可以使用快速选择（QuickSelect）算法来找到数组中第K大的元素，其基本思想是选取一个基准元素，将数组划分为两部分，使得左边的元素都大于基准元素，右边的元素都小于基准元素。如果基准元素的位置等于K，则找到了第K大的元素；如果基准元素的位置大于K，则在左边继续查找；如果基准元素的位置小于K，则在右边继续查找。通过递归地进行划分和查找，最终可以找到第K大的元素。</li>
</ol>
<hr>
<ol start="5">
<li>MySQL索引情景题轰炸：</li>
</ol>
<ul>
<li>什么是索引？</li>
<li>索引的作用是什么？</li>
<li>什么情况下应该创建索引？</li>
<li>索引对查询和插入操作的影响是什么？</li>
<li>联合索引和单列索引有何区别？</li>
<li>索引对于排序和分组操作的影响是什么？</li>
</ul>
<ol start="6">
<li>MySQL默认引擎，解决了什么问题：</li>
</ol>
<ul>
<li>MySQL的默认存储引擎是InnoDB。</li>
<li>InnoDB引擎解决了多版本并发控制（MVCC）的问题，实现了更好的并发性能。</li>
<li>它支持事务处理和ACID属性（原子性、一致性、隔离性和持久性），提供了更高的数据完整性和可靠性。</li>
<li>InnoDB还提供了行级锁定和外键约束等功能。</li>
</ul>
<ol start="7">
<li>MySQL表的大小该多大合适，为什么：</li>
</ol>
<ul>
<li>表的大小适合应根据具体业务需求和数据库服务器的资源来确定。</li>
<li>表的大小过小可能会导致性能损失，因为查询的数据量较小，无法充分利用数据库服务器的资源。</li>
<li>表的大小过大可能会导致性能下降，因为需要更多的时间来扫描和处理大量的数据。</li>
<li>应根据数据库服务器的硬件配置、性能需求和数据增长率等因素来评估表的大小。</li>
</ul>
<ol start="8">
<li><p>MySQL写一个死锁场景：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 会话1</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话2</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>上述场景中，会话1获取了table1的行锁并等待table2的行锁，同时会话2获取了table2的行锁并等待table1的行锁，从而造成死锁。</p>
</li>
<li><p>一组有序可重复数组找到某个最后出现的数的索引（二分）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_last_index</span>(<span class="params">arr, target</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    index = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:</span><br><span class="line">            index = mid</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure>
<p>上述代码使用二分查找算法，在有序可重复数组中找到某个最后出现的数的索引。如果找到目标数，则更新索引并继续在右侧查找；如果目标数较大，则在右侧继续查找；如果目标数较小，则在左侧继续查找。最终返回最后出现的数的索引。</p>
</li>
<li><p>有1、3、9、27克的砝码各一个，能称出多重的物品，后追问如果添加81克、273克等（3的幂）各一个，能称出500克：<br>可以使用贪心算法解决该问题。首先，将重量为1的砝码放在一边，然后将剩下的砝码按从小到大的顺序放在另一边，将需要称重的物品放在一边，并根据需要逐步使用较大的砝码进行称重。如果添加了81克、273克等砝码，仍然可以按照相同的方法进行称重，因为这些额外的砝码是3的幂，可以覆盖到其他重量范围。这样，可以称出500克的物品。</p>
</li>
</ol>
<hr>
<ol start="3">
<li>HTTPS（CA机构）：<br>HTTPS（HyperText Transfer Protocol Secure）是基于HTTP协议的加密通信协议。它使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议来对通信进行加密和身份验证，确保数据的机密性和完整性。</li>
</ol>
<p>CA（Certificate Authority）机构是负责颁发和管理数字证书的机构。在HTTPS通信中，服务器需要使用数字证书来证明自己的身份，并对通信进行加密。CA机<br>构是可信任的第三方机构，负责验证服务器的身份，并签发数字证书。客户端在与服务器建立连接时，会验证服务器的数字证书的合法性和有效性，确保通信的安<br>全性。</p>
<ol start="4">
<li>线程安全机制：<br>线程安全是指在多线程环境下，多个线程同时访问共享资源时，保证对共享资源的操作能够正确执行而不会出现数据不一致或不确定的结果。</li>
</ol>
<p>常见的线程安全机制包括：</p>
<ul>
<li>互斥锁（Mutex）：通过锁机制保证在同一时刻只有一个线程可以访问共享资源。</li>
<li>信号量（Semaphore）：用于控制同时访问共享资源的线程数量。</li>
<li>条件变量（Condition Variable）：用于线程之间的通信和同步，允许线程等待某个条件的发生。</li>
<li>原子操作（Atomic Operation）：保证特定操作在执行过程中不会被中断，确保数据的原子性。</li>
</ul>
<ol start="5">
<li>JVM类加载：<br>JVM（Java Virtual Machine）类加载是指将Java字节码文件加载到内存中，并解析成可执行的Java类的过程。<br>JVM采用了三级类加载器体系：启动类加载器（Bootstrap Class<br>Loader）、扩展类加载器（Extension Class Loader）和应用程序类加载器（Application Class Loader）。</li>
</ol>
<p>类加载的过程包括：</p>
<ul>
<li>加载（Loading）：将字节码文件加载到内存中，通常从磁盘或网络中获取字节码文件。</li>
<li>验证（Verification）：验证字节码文件的格式、结构和语义的正确性。</li>
<li>准备（Preparation）：为类的静态变量分配内存空间，并设置默认初始值。</li>
<li>解析（Resolution）：将符号引用替换为直接引用，解析类之间的关系。</li>
<li>初始化（Initialization）：执行类的初始化代码，包括静态变量的赋值和静态块的执行。</li>
</ul>
<ol start="6">
<li>TCP&#x2F;IP如何实现可靠的数据传输：<br>TCP&#x2F;IP协议通过以下方式实现可靠的数据传输：</li>
</ol>
<ul>
<li>应用数据被分割成小的数据块（Segment），每个数据块都有序号。</li>
<li>TCP使用滑动窗口机制来管理发送和接收数据的缓冲区大小。</li>
<li>接收方会对收到的数据进行确认，并发送确认消息给发送方，以确认数据的接收。</li>
<li>发送方在一定时间内未收到确认消息，则认为数据丢失，并重新发送未收到确认的数据。</li>
<li>TCP使用序号和确认号来保证数据的有序性和完整性。</li>
<li>TCP使用流量控制和拥塞控制机制来控制数据的发送速率，避免网络拥塞和数据丢失。</li>
</ul>
<ol start="7">
<li>CAS（Compare and Swap）：<br>CAS是一种并发编程中的原子操作，用于实现无锁并发算法。它通过比较内存中的值与预期值是否相等，如果相等则将新值写入内存，否则不进行任何操作。</li>
</ol>
<p>CAS操作包括三个参数：内存地址（或称为变量的引用）、预期值和新值。它的执行过程如下：</p>
<ul>
<li>读取内存地址中的值，与预期值进行比较。</li>
<li>如果相等，则将新值写入内存地址，操作成功。</li>
<li>如果不相等，则表示其他线程已经修改了内存中的值，CAS操作失败。</li>
</ul>
<p>CAS操作在并发环境下可以保证数据的一致性和线程安全性，避免了锁的使用，减少了线程切换和调度的开销。然而，CAS操作也存在ABA问题，即在操作过程中可能发生其他线程修改了值并恢复成原来的值，导致CAS操作无法感知这种变化。为了解决ABA问题，通常会使用版本号或标记来增加额外的判断。</p>
<hr>
<ol start="2">
<li>static关键字：</li>
</ol>
<ul>
<li>static关键字可以用于修饰类的成员（属性和方法），也可以用于修饰局部变量。</li>
<li>当static关键字用于类的成员时，表示该成员属于类级别，而不是实例级别。类的所有实例共享同一个static成员。</li>
<li>静态成员可以通过类名直接访问，不需要创建类的实例。</li>
<li>静态属性在内存中只有一份拷贝，对于所有的实例都是共享的。</li>
<li>静态方法不能访问非静态成员，只能访问静态成员。</li>
</ul>
<ol start="3">
<li>垃圾回收算法和常用的垃圾回收器：</li>
</ol>
<ul>
<li>垃圾回收算法是指用于自动回收不再使用的内存资源的算法。</li>
<li>常见的垃圾回收算法包括引用计数、标记-清除、复制、标记-整理等。</li>
<li>垃圾回收器是实现垃圾回收算法的具体实现，常见的垃圾回收器有串行垃圾回收器、并行垃圾回收器、并发垃圾回收器和分代垃圾回收器等。</li>
<li>Java中常用的垃圾回收器包括Serial GC、Parallel GC、CMS GC、G1 GC等。</li>
</ul>
<ol start="4">
<li>类加载机制：</li>
</ol>
<ul>
<li>类加载是指将类的字节码文件加载到内存中，并在JVM中生成对应的Class对象的过程。</li>
<li>类加载机制分为加载、验证、准备、解析和初始化五个阶段。</li>
<li>加载阶段：通过类加载器将字节码文件加载到内存中。</li>
<li>验证阶段：验证字节码文件的正确性和安全性。</li>
<li>准备阶段：为类的静态变量分配内存空间，并设置默认初始值。</li>
<li>解析阶段：将符号引用替换为直接引用，建立类之间的关系。</li>
<li>初始化阶段：执行类的初始化代码，包括静态变量的赋值和静态块的执行。</li>
</ul>
<ol start="5">
<li>反射：</li>
</ol>
<ul>
<li>反射是指在运行时动态地获取类的信息，并能够操作类或对象的属性、方法和构造函数。</li>
<li>通过反射，可以在运行时创建对象、调用方法、获取和设置属性等，即使在编译时无法确定具体的类。</li>
<li>反射提供了灵活性和扩展性，但由于涉及到动态解析和调用，性能上相对较低。</li>
</ul>
<ol start="6">
<li>HashMap：</li>
</ol>
<ul>
<li>HashMap是Java中的一种数据结构，用于存储键值对。</li>
<li>它基于哈希表实现，可以快速地进行插入、删除和查找操作。</li>
<li>HashMap允许null键和null值，</li>
</ul>
<p>但键不能重复（相同的键只能存在一个）。</p>
<ul>
<li>HashMap的底层数据结构是数组和链表（或红黑树），通过哈希算法将键映射到数组的索引位置，解决哈希冲突的键值对通过链表（或红黑树）形成一个链表（或红黑树）节点。</li>
<li>HashMap的查找和插入操作的平均时间复杂度是O(1)，但在最坏情况下可能会达到O(n)。</li>
</ul>
<ol start="8">
<li>TCP和UDP的区别及介绍：</li>
</ol>
<ul>
<li>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是网络通信中常用的两种传输协议。</li>
<li>TCP是面向连接的协议，提供可靠的数据传输，保证数据的有序性和完整性，但传输效率相对较低。</li>
<li>UDP是无连接的协议，不提供可靠性保证，传输速度较快，但对数据的有序性和完整性没有保证。</li>
<li>TCP使用三次握手和四次挥手来建立和关闭连接，保证数据的可靠传输。</li>
<li>UDP适用于实时性要求高、数据量较小、丢失一些数据不影响的场景，例如音视频传输、实时游戏等。</li>
</ul>
<ol start="9">
<li>TCP如何保证可靠的数据传输：</li>
</ol>
<ul>
<li>TCP使用以下机制保证数据的可靠传输：<ul>
<li>序号和确认号：TCP使用序号对数据进行编号，接收方通过确认号告知发送方已接收到的数据，确保数据的有序性和完整性。</li>
<li>窗口机制：TCP使用滑动窗口机制控制发送和接收数据的窗口大小，根据网络的拥塞情况动态调整数据传输速率。</li>
<li>确认机制：接收方在接收到数据后发送确认消息给发送方，以确认数据的接收。如果发送方在一定时间内未收到确认消息，则认为数据丢失，重新发送未收到<br>确认的数据。</li>
<li>超时重传：如果发送方在一定时间内未收到确认消息，则认为数据丢失，会重新发送未收到确认的数据，确保数据的可靠传输。</li>
<li>拥塞控制：TCP使用拥塞控制机制来避免网络拥塞，通过动态调整窗口大小和发送速率来控制数据的传输。</li>
</ul>
</li>
</ul>
<ol start="11">
<li><p>项目相关（难点）：<br>这个问题需要根据实际项目经验来回答，因不了解您的具体项目，无法给出详细的回答。</p>
</li>
<li><p>给定一个数组，然后一个正数k，判断数组中是否存在子数组，使得子数组之和可以被正数K整除。<br>思路：使用前缀和的思想，使用一个Set容器存储前缀和与k的余数，当计算完每个位置的前缀和并取余后，<br>如果发现Set中存在该余数，则证明一定存在一个子数组之和可以被k整除。这是因为如果两个位置的前缀和的余数相同，<br>那么这两个位置之间的子数组之和必然是k的倍数。</p>
</li>
<li><p>说一下数组和列表是什么，以及区别？</p>
</li>
</ol>
<p>数组和列表都是数据结构用于存储和组织一组数据的容器，但它们在实现方式和特性上有一些区别。</p>
<p>数组（Array）：</p>
<ul>
<li>数组是一种固定大小的数据结构，它由相同类型的元素组成，这些元素在内存中是连续存储的。</li>
<li>数组的访问是通过索引来实现的，可以通过索引快速访问和修改数组中的元素。</li>
<li>数组的大小在创建时确定，并且通常不可更改。如果需要调整大小，需要创建一个新的数组，并将原数组的元素复制到新数组中。</li>
<li>数组适合用于对元素的随机访问和修改，但在插入和删除元素时效率较低。</li>
</ul>
<p>列表（List）：</p>
<ul>
<li>列表是一种动态大小的数据结构，它可以容纳不同类型的元素，并且元素在内存中不一定是连续存储的。</li>
<li>列表的访问可以通过索引或迭代器来实现，可以按需访问和修改列表中的元素。</li>
<li>列表的大小可以根据需要动态调整，可以方便地插入和删除元素。</li>
<li>列表适合用于需要频繁插入和删除元素的场景，但在随机访问元素时效率较低。</li>
</ul>
<p>区别：</p>
<ol>
<li>存储方式：数组中的元素在内存中是连续存储的，而列表中的元素在内存中不一定是连续存储的。</li>
<li>大小调整：数组的大小在创建时确定，并且通常不可更改，而列表的大小可以根据需要动态调整。</li>
<li>元素类型：数组要求存储的元素类型必须相同，而列表可以容纳不同类型的元素。</li>
<li>插入和删除操作：数组在插入和删除元素时效率较低，需要移动其他元素，而列表在插入和删除元素时效率较高，不需要移动其他元素。</li>
<li>随机访问效率：数组可以通过索引进行快速随机访问，而列表在随机访问元素时效率较低。</li>
</ol>
<p>根据具体的使用场景和需求，选择适合的数据结构可以提高程序的效率和性能。</p>
<ol>
<li><p>spring bean生命周期</p>
</li>
<li><p>springboot starter .factorys文件</p>
</li>
<li><p>mysql三个范式 举了个场景题 怎么建索引 怎么查询</p>
</li>
<li><p>mysql 事物四大特性 具体如何实现</p>
</li>
<li><p>redis缓存穿透 缓存击穿 缓存雪崩怎么解决?</p>
</li>
<li><p>redis怎么实现分布式锁 set nx命令有什么问题 如何解决？</p>
</li>
<li><p>讲一讲cms</p>
</li>
<li><p>什么时候会发生full gc</p>
</li>
<li><p>可以在代码中捕获oom异常吗</p>
</li>
<li><p>算法：二维数组 逐行自增 快速查找target</p>
</li>
<li><p>Spring Bean 生命周期：</p>
</li>
</ol>
<ul>
<li>实例化：当容器加载Bean定义时，会实例化Bean对象。</li>
<li>属性赋值：容器将属性值和对其他Bean的引用注入到Bean实例中。</li>
<li>初始化：在Bean实例化和属性赋值完成后，可以执行自定义的初始化逻辑，例如调用自定义的初始化方法或实现InitializingBean接口。</li>
<li>使用：Bean可以被容器或其他Bean使用。</li>
<li>销毁：当容器关闭时，会销毁Bean对象，可以执行自定义的销毁逻辑，例如调用自定义的销毁方法或实现DisposableBean接口。</li>
</ul>
<ol start="2">
<li>Spring Boot Starter .factorys文件：</li>
</ol>
<ul>
<li>在Spring Boot中，自动配置的实现是通过Spring Boot Starter模块来实现的。</li>
<li>在Starter模块的META-INF目录下，有一个名为spring.factories的文件，其中列出了自动配置类的全限定名。</li>
<li>Spring Boot在启动时，会根据spring.factories文件加载配置的自动配置类，并将其纳入到应用上下文中。</li>
</ul>
<ol start="3">
<li>MySQL三个范式和索引建立与查询：</li>
</ol>
<ul>
<li>第一范式（1NF）要求数据表中的每一列都是不可分割的最小数据单位，确保每个数据都是原子性的。</li>
<li>第二范式（2NF）要求数据表中的非主键列完全依赖于主键，即每个非主键列都必须完全依赖于主键而不是部分依赖。</li>
<li>第三范式（3NF）要求数据表中的非主键列之间没有传递依赖关系，即非主键列不依赖于其他非主键列。</li>
</ul>
<p>在建立索引时，可以根据查询的需求和表的特点进行如下考虑：</p>
<ul>
<li>选择适当的列作为索引列，通常是那些经常用于查询的列。</li>
<li>考虑使用组合索引来覆盖多个查询条件。</li>
<li>避免对频繁进行更新的列创建索引，以减少索引维护的开销。</li>
<li>注意索引的选择性，选择性越高，索引效果越好。</li>
</ul>
<ol start="4">
<li>MySQL事务的四大特性：ACID</li>
</ol>
<ul>
<li>原子性（Atomicity）：事务是一个原子操作，要么全部执行成功，要么全部回滚到事务开始前的状态。</li>
<li>一致性（Consistency）：事务在执行前后，数据的完整性必须保持一致，即满足预定义的规则和约束。</li>
<li>隔离性（Isolation）：多个并发事务之间应该相互隔离，每个事务都应该感觉不到其他事务的存在。</li>
<li>持久性（Durability）：一旦事务提交，对数据库的修改应该永久保存，即使系统故障也不应该丢失提交的事务。</li>
</ul>
<p>具体实现事务的方式包括使用事务管理器、在代码中使用@Transactional注解等。</p>
<ol start="5">
<li>Redis缓存穿透、缓存击穿和缓存雪崩的解决方法：</li>
</ol>
<ul>
<li>缓存穿透：指查询一个不存在于缓存和数据库中的数据，导致每次查询都穿透到数据库。解决方法包括在查询时进行空值缓存、布隆过滤器等。</li>
<li>缓存击穿：指一个热点数据失效或被删除，导致大量请求直接打到数据库上。解决方法包括设置热点数据永不过期、互斥锁等。</li>
<li>缓存雪崩：指缓存中的大量数据在同一时间失效，导致大量请求直接打到数据库上。解决方法包括设置缓存数据的随机过期时间、使用分布式缓存等。</li>
</ul>
<ol start="6">
<li>Redis实现分布式锁和解决set nx命令的问题：</li>
</ol>
<ul>
<li>使用Redis实现分布式锁可以利用Redis的原子性操作，通过设置一个特定的键来实现锁的获取和释放。</li>
<li>在使用<code>SET</code>命令设置分布式锁时，可以设置<code>NX</code>（只在键不存在时才设置）和<code>EX</code>（设置键的过期时间）选项。</li>
<li>问题：在分布式环境下，如果获取锁和设置过期时间两个操作不是原子性的，可能导致锁无法正常释放。</li>
<li>解决方法：可以使用<code>SET</code>命令的<code>NX</code>、<code>EX</code>和<code>PX</code>选项组合，或者使用Redis的Lua脚本来保证获取锁和设置过期时间的原子性。</li>
</ul>
<ol start="7">
<li>CMS（Concurrent Mark Sweep）：</li>
</ol>
<ul>
<li>CMS是一种基于标记-清除算法的垃圾回收器，用于减少垃圾回收的停顿时间。</li>
<li>CMS采用并发标记和并发清除的方式进行垃圾回收，允许垃圾回收与应用程序并发执行，以减少停顿时间。</li>
<li>CMS的主要目标是减少垃圾回收的停顿时间，但可能会牺牲一些吞吐量。</li>
<li>CMS在进行垃圾回收时，会产生一些碎片，可能会导致内存空间的浪费。</li>
</ul>
<ol start="8">
<li>Full GC的发生时机：</li>
</ol>
<ul>
<li>Full GC（Full Garbage Collection）指的是对整个堆内存进行垃圾回收的过程。</li>
<li>Full GC的发生时机包括：<ul>
<li>当老年代空间不足以容纳新生成的对象时，会触发Full GC。</li>
<li>当调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>显式触发垃圾回收时，可能会触发Full GC。</li>
<li>当永久代或元空间（在不同的Java版本中）空间不足时，会触发Full GC。</li>
</ul>
</li>
</ul>
<ol start="9">
<li>在代码中捕获OOM异常：</li>
</ol>
<ul>
<li>OOM（OutOfMemoryError）是Java中的错误（Error），而不是异常（Exception），表示内存溢出错误。</li>
<li>OOM通常发生在JVM无法分配足够的内存给对象使用时。</li>
<li>由于OOM是错误而不是异常，它表示JVM处于不可恢复的状态，无法被捕获和处理。</li>
</ul>
<ol start="10">
<li>算法题：二维数组逐行自增快速查找target：</li>
</ol>
<ul>
<li>可以使用二分查找的思想进行解答。</li>
<li>对于逐行自增的二维数组，可以将其看作是一个按顺序排列的一维数组。</li>
<li>首先确定目标值在哪一行，然后在该行进行二分查找。</li>
<li>如果找到目标值，返回true；否则，返回false。</li>
</ul>
<p>以上是对您提出的问题的简要回答，可能还有更详细和全面的答案。</p>
<ol>
<li><p>ArrayList的并发修改异常了解吗？单线程情况下会发生吗？</p>
</li>
<li><p>介绍下Java的happens before？为什么要有happens before？</p>
</li>
<li><p>Redis：持久化机制。AOF和RDB分别说下。</p>
</li>
<li><p>redis集群方案了解吗 -</p>
</li>
<li><p>Spring是IOC容器，这个IOC容器的作用是什么？</p>
</li>
<li><p>看简历里说对spring有自己的理解，可以说说有哪些理解。</p>
</li>
<li><p>适配器、装饰器、代理模式有什么区别</p>
</li>
<li><p>TCP&#x2F;IP四层模型</p>
</li>
<li><p>三次握手，四次挥手机制</p>
</li>
<li><p>Http的请求由哪几部分构成。http2了解吗？</p>
</li>
<li><p>看到你提到了RabbitMQ，能说说消息队列的作用吗？有了解RabbitMQ的设计吗，比如交换机、路由键。</p>
</li>
<li><p>做题 最长无重复子串</p>
</li>
<li><p>ArrayList的并发修改异常（ConcurrentModificationException）：</p>
</li>
</ol>
<ul>
<li>当使用迭代器遍历ArrayList时，如果在遍历过程中通过集合的add、remove等方法修改了集合的结构（增加或删除元素），就会抛出ConcurrentModificationException异常。</li>
<li>单线程情况下不会发生并发修改异常，因为在单线程环境下，遍历和修改操作是串行执行的。</li>
</ul>
<ol start="2">
<li>Java的happens-before：</li>
</ol>
<ul>
<li>Happens-before是Java内存模型中的概念，用于定义操作之间的可见性和顺序关系。</li>
<li>Happens-before规则规定了在多线程环境下，对共享变量的写操作对于后续的读操作是可见的。</li>
<li>Happens-before关系保证了程序的顺序性和一致性，避免了由于指令重排等因素导致的数据不一致问题。</li>
</ul>
<ol start="3">
<li>Redis的持久化机制：</li>
</ol>
<ul>
<li>AOF（Append-Only<br>File）持久化：将每个写操作追加到AOF文件中，恢复时重新执行AOF文件中的命令。AOF持久化可以通过配置进行自动化的定期写入或者根据数据变化的时候执行。</li>
<li>RDB（Redis<br>Database）持久化：将当前时刻的内存数据快照保存到磁盘上的二进制文件。RDB持久化可以通过手动执行SAVE或者BGSAVE命令，或者根据配置定期自动执行。</li>
</ul>
<ol start="4">
<li>Redis集群方案：</li>
</ol>
<ul>
<li>Redis集群通过数据分片和复制来提供高可用性和可扩展性。</li>
<li>Redis Cluster使用分片来水平拆分数据到多个节点，每个节点负责管理其中的一部分数据。</li>
<li>Redis Cluster使用Gossip协议来进行节点之间的通信和信息交换，实现节点的自动发现和故障转移。</li>
<li>集群模式下，Redis客户端会根据哈希算法将数据分散存储到不同的节点上，从而实现负载均衡和数据的高可用性。</li>
</ul>
<ol start="5">
<li>Spring的IOC容器的作用：</li>
</ol>
<ul>
<li>IOC（Inversion of Control）是一种设计模式，它将对象的创建和依赖关系的管理交给容器来处理。</li>
<li>Spring的IOC容器负责创建、装配和管理应用程序中的对象（Bean），通过配置文件或注解的方式来描述对象之间的依赖关系。</li>
<li>IOC容器的作用是实现对象之间的解耦，使得应用程序的组件更加灵活、可维护和可测试。</li>
</ul>
<ol start="6">
<li>对Spring的理解：</li>
</ol>
<ul>
<li>Spring是一个开源的、轻量级的企业级应用开发框架。</li>
<li>Spring提供了一个IOC容器和AOP等核心特性，以简化Java开发过程。</li>
<li>Spring可以用于构建各种类型的应</li>
</ul>
<p>用程序，包括Web应用、RESTful服务、批处理应用等。</p>
<ul>
<li>Spring提供了丰富的功能和扩展，如事务管理、安全性、缓存、消息传递等。</li>
</ul>
<ol start="7">
<li>适配器、装饰器和代理模式的区别：</li>
</ol>
<ul>
<li>适配器模式：用于将一个类的接口转换成另一个客户端所期望的接口，使得原本不兼容的类能够协同工作。</li>
<li>装饰器模式：动态地给对象添加额外的功能，通过包装（装饰）原始对象，而不是通过继承来扩展功能。</li>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。代理类和被代理类实现相同的接口，通过代理类来控制和管理被代理类的访问。</li>
</ul>
<ol start="8">
<li>TCP&#x2F;IP四层模型：</li>
</ol>
<ul>
<li>应用层：提供应用程序之间的通信和数据交换，包括HTTP、FTP、SMTP等协议。</li>
<li>传输层：负责端到端的数据传输，包括TCP和UDP协议。</li>
<li>网络层：处理网络中的数据包路由和转发，包括IP协议。</li>
<li>数据链路层：负责物理链路的传输，包括以太网、WiFi等。</li>
</ul>
<ol start="9">
<li>三次握手和四次挥手：</li>
</ol>
<ul>
<li>三次握手是建立TCP连接的过程，用于确认双方的通信能力和同步连接序列号。</li>
<li>四次挥手是关闭TCP连接的过程，用于双方协商断开连接并确认最后的数据传输。</li>
</ul>
<ol start="10">
<li>HTTP请求的构成：</li>
</ol>
<ul>
<li>HTTP请求由请求行、请求头和请求体组成。请求行包括请求方法、URL和协议版本。</li>
<li>请求头包括一些附加的信息，如请求头字段和值，用于传递请求的相关信息。</li>
<li>请求体（可选）包含要发送给服务器的数据，例如表单数据或请求体内容。</li>
</ul>
<ol start="11">
<li>消息队列的作用和RabbitMQ的设计：</li>
</ol>
<ul>
<li>消息队列用于解耦和异步处理系统中的组件，提供了可靠的消息传递机制。</li>
<li>RabbitMQ是一种开源的消息队列系统，它实现了AMQP（高级消息队列协议），提供了可靠的消息传递、消息路由和消息排队等功能。</li>
<li>RabbitMQ的设计包括交换机（Exchange）、队列（Queue）和绑定（Binding），通过交换机和绑定规则将消息发送到特定的队列中。</li>
</ul>
<ol start="12">
<li>最长无重复子串算法：</li>
</ol>
<ul>
<li>最长无重复子串算法可以通过滑动窗口的方式来实现。</li>
<li>使用两个指针表示滑动窗口的左右边界，遍历整</li>
</ul>
<p>个字符串。</p>
<ul>
<li>当右指针遇到重复字符时，移动左指针到重复字符的下一个位置，更新窗口的大小。</li>
<li>在遍历过程中记录最大的窗口大小，即为最长无重复子串的长度。</li>
</ul>
<p>什么是遍历和修改操作是串行执行</p>
<p>当说到遍历和修改操作是串行执行时，意味着在单线程环境中，这两个操作是按顺序依次执行的，不会发生并发或并行的情况。</p>
<p>具体来说，在单线程中执行遍历操作时，会按照集合的顺序依次访问每个元素，直到遍历完所有元素或满足某个条件。期间不会有其他线程干扰或修改集合的结构。</p>
<p>同样，在单线程中执行修改操作时，会依次对集合的元素进行修改，例如添加、删除或更新元素。在修改操作执行期间，也不会有其他线程同时对集合进行修改。</p>
<p>因此，在单线程环境下，遍历和修改操作是串行执行的，保证了操作的顺序性和一致性。但是需要注意的是，在多线程环境下，遍历和修改操作可能会引发并发修改异常（ConcurrentModificationException），需要使用相应的并发控制手段来保证线程安全性。</p>
<p>什么是快照</p>
<p>在计算机科学和数据库领域，快照（Snapshot）是指某一时刻系统或数据的静态副本或状态的表示。</p>
<p>在操作系统中，快照可以是对文件系统或虚拟机的状态的拍摄，记录了某一时刻文件系统或虚拟机中所有文件、目录和内存的状态。这样的快照可以用于备份和还原，以及系统恢复和故障排除。</p>
<p>在数据库中，快照是数据库在某一时刻的一致性视图。它是数据库在特定时间点的数据副本，反映了数据库中所有表、记录和索引的状态。数据库快照可以用于数据恢复、数据分析和并发控制。</p>
<p>快照的关键特点是它是在某个确定的时间点捕获的，因此它反映了该时间点系统或数据的准确状态。快照可以被用于恢复系统到该时间点的状态，或者作为参考点进行数据分析和比较。</p>
<p>需要注意的是，快照通常是只读的，即不能对快照进行修改。任何对原始系统或数据的修改都不会影响已经捕获的快照。因此，快照常常用于数据保护和故障恢复的目的。</p>
<p>IOC</p>
<p>IOC（Inversion of Control）是一种软件设计原则，也是Spring框架的核心概念之一。它实现了控制反转，即将对象的创建、依赖关系的管理和对象的生命周期的控制权从应用程序代码中转移到了容器（框架）中。</p>
<p>在传统的编程模型中，应用程序代码通常负责创建对象、解决对象之间的依赖关系以及管理对象的生命周期。这导致了代码的紧耦合和复杂性，使得代码难以维护、测试和扩展。</p>
<p>而IOC容器则通过将对象的创建和依赖关系的管理委托给容器来解决这些问题。应用程序只需要描述对象之间的依赖关系，而不需要直接处理对象的创建和管理。容器根据配置文件或注解来实现对象的创建、依赖注入和生命周期管理，从而实现了对象之间的解耦和灵活性。</p>
<p>IOC容器的工作原理是通过反射、配置文件或注解来实现对象的实例化和依赖注入。它可以根据配置文件或注解中的信息，自动创建对象，并将依赖的对象注入到目标对象中。这样，对象之间的依赖关系由容器来管理，应用程序代码只需要使用这些对象即可。</p>
<p>通过使用IOC容器，我们可以实现以下优势：</p>
<ul>
<li>松耦合：对象之间的依赖关系由容器来管理，减少了对象之间的直接耦合，提高了代码的可维护性和可测试性。</li>
<li>可扩展性：通过配置文件或注解，可以很容易地添加、修改或替换对象的实现，而不需要修改应用程序的代码。</li>
<li>简化开发：IOC容器自动处理对象的创建和依赖注入，减少了开发人员的工作量，提高了开发效率。</li>
</ul>
<p>Spring框架是一个基于IOC容器的应用框架，它提供了强大的IOC功能以及其他丰富的特性，如AOP（面向切面编程）、事务管理、安全性等，使得开发者可以更轻松地开发复杂的企业应用。</p>
<p>为什么要有异步这个东西，解决了什么问题，举个代码例子</p>
<p>异步编程是一种编程范式，用于解决在某些情况下同步执行会导致性能问题或阻塞的情况。它可以提高系统的响应性能、资源利用率和并发处理能力。</p>
<p>异步编程的主要目的是通过将耗时的操作（如网络请求、文件读写、数据库查询等）放在后台进行，不阻塞主线程或其他任务的执行。这样可以使程序在等待这些操作完成的同时继续执行其他任务，提高了程序的吞吐量和响应速度。</p>
<p>异步编程可以解决以下问题：</p>
<ol>
<li>阻塞问题：当程序需要等待耗时操作完成时，同步执行会导致阻塞，影响程序的执行效率和响应性能。异步编程通过非阻塞的方式处理耗时操作，允许程序继续执行其他任务，提高了程序的并发处理能力。</li>
<li>响应性能问题：在需要响应用户请求的应用中，同步执行可能导致用户长时间等待，给用户带来不良的体验。异步编程可以在后台处理耗时操作，使得系统能够更快地响应用户请求。</li>
<li>资源利用率问题：同步执行时，如果一个线程在等待耗时操作完成期间空闲，资源得不到充分利用。异步编程可以在等待时释放线程，使其能够执行其他任务，提高了资源的利用率。</li>
</ol>
<p>以下是一个简单的Java代码例子，展示了如何使用异步编程（基于Java 8 CompletableFuture）进行网络请求的并发处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 执行第一个网络请求</span></span><br><span class="line">            <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Result from Request 1&quot;</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 执行第二个网络请求</span></span><br><span class="line">            <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Result from Request 2&quot;</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步等待两个请求都完成</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; combinedFuture = CompletableFuture.allOf(future1, future2);</span><br><span class="line"></span><br><span class="line">        combinedFuture.thenRun(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 当两个请求都完成时执行的操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Both requests completed.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Result 1: &quot;</span> + future1.join());</span><br><span class="line">            System.out.println(<span class="string">&quot;Result 2: &quot;</span> + future2.join());</span><br><span class="line">            <span class="comment">// 可以继续执行其他任务</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在上述代码中，我们使用<code>CompletableFuture</code>创建两个异步任务，分别模拟两个网络请求的耗时操作。然后，使用<code>CompletableFuture.allOf</code>等待两个任务都完成，然后执行后续操作。这样可以并发地处理多个网络请求，提高了程序的并发性能。</p>
<p>什么是编程范式</p>
<p>编程范式是一种编程的方法论或编程的风格，它规定了程序员在解决问题时应遵循的原则和思维方式。不同的编程范式强调不同的概念、原则和思想，以实现特定的目标和效果。</p>
<p>常见的编程范式包括：</p>
<ol>
<li>命令式编程范式：以算法为中心，通过编写一系列的命令来指导计算机执行任务。常见的命令式编程语言有C、Java等。</li>
<li>声明式编程范式：以描述问题的逻辑为中心，通过声明式语句来描述问题的解决方式，而不是直接指定计算机的执行步骤。常见的声明式编程范式包括函数式编程和逻辑编程。</li>
<li>函数式编程范式：将计算视为数学函数的求值过程，强调函数的纯粹性和不可变性。函数式编程语言如Haskell、Scala和Lisp属于这种范式。</li>
<li>面向对象编程范式：以对象为中心，将数据和操作封装在对象中，并通过对象之间的交互来解决问题。面向对象编程语言如Java、C++和Python属于这种范式。</li>
<li>面向过程编程范式：将程序看作是一系列的过程或函数，通过顺序执行这些过程来实现任务。C语言常用这种范式。</li>
<li>并发编程范式：用于处理并发和多线程编程的范式，例如使用锁、线程、消息传递等机制来实现并发任务。并发编程语言和框架如Java的并发包、Go和Erlang等属于这种范式。</li>
<li>泛型编程范式：通过参数化类型和抽象数据类型的概念，实现可重用和通用的代码。C++的模板和Java的泛型就是泛型编程的范式。</li>
</ol>
<p>不同的编程范式适用于不同的问题领域和需求，程序员可以根据具体情况选择合适的编程范式来解决问题。有时候，也可以结合多种编程范式来编写代码，以充分利用各种范式的优点。</p>
<p>Spring Bean 是什么</p>
<p>在Spring框架中，Bean是一个由Spring容器管理的对象。Bean代表了应用程序中的一个组件，它可以是一个实例化的类对象、一个配置的数据源、一个服务等。</p>
<p>Spring Bean的特点和作用包括：</p>
<ol>
<li>实例化和管理：Spring容器负责创建和管理Bean的生命周期，包括实例化、依赖注入、初始化、销毁等过程。</li>
<li>依赖注入：Spring容器通过依赖注入将Bean所需的依赖关系自动注入到Bean中，实现了松耦合和可测试性。</li>
<li>配置灵活性：Spring Bean的配置信息可以通过XML配置文件、注解或Java代码等方式进行定义和修改，提供了灵活的配置选项。</li>
<li>AOP支持：Spring框架提供了面向切面编程（AOP）的支持，可以在Bean中定义切面和通知，实现横切关注点的解耦和复用。</li>
<li>事务管理：Spring框架提供了事务管理的功能，可以通过配置将事务应用到Bean的方法中，实现数据的一致性和事务的管理。</li>
<li>生命周期管理：Spring容器管理Bean的生命周期，包括初始化方法和销毁方法的回调，可以通过配置自定义Bean的初始化和销毁逻辑。</li>
</ol>
<p>通过Spring Bean的管理和依赖注入，开发人员可以更加专注于业务逻辑的实现，而无需关注对象的创建和管理细节。同时，Spring Bean的配置灵活性也使得应用程序的组件可以方便地进行扩展和修改，提供了更好的可维护性和可测试性。</p>
<p>RESTful</p>
<p>RESTful是一种设计风格或架构风格，用于构建网络应用程序，特别是基于HTTP协议的Web服务。REST是Representational State Transfer的缩写，它强调将应用程序的功能以资源的形式进行建模，通过HTTP协议中的各种方法对资源进行操作和交互。</p>
<p>以下是RESTful的一些关键概念和原则：</p>
<ol>
<li>资源（Resource）：在RESTful架构中，所有的功能被视为资源，每个资源都可以通过一个唯一的URI进行标识，例如&#x2F;users、&#x2F;products等。</li>
<li>表述（Representation）：资源的表述是指资源的具体数据表示形式，可以是JSON、XML、HTML等。客户端可以通过HTTP方法（GET、POST、PUT、DELETE等）对资源的表述进行操作。</li>
<li>统一接口（Uniform Interface）：RESTful架构通过使用统一的接口规范，包括使用HTTP方法进行资源操作（GET、POST、PUT、DELETE）以及对资源的URI进行标识和访问。</li>
<li>状态无关（Stateless）：RESTful架构是无状态的，每个请求都包含了足够的信息，服务器不需要存储客户端的状态信息。</li>
<li>超媒体驱动（HATEOAS）：通过在响应中提供资源间的链接，客户端可以动态地发现和操作可用的资源，实现应用程序的自描述性和可扩展性。</li>
</ol>
<p>使用RESTful架构设计的Web服务具有良好的可扩展性、可维护性和松耦合性。它能够提供清晰的接口设计、灵活的资源交互方式和统一的状态管理，使得不同系统之间的通信更加简洁和高效。同时，RESTful架构也符合Web标准，能够充分利用HTTP协议的各种功能和特性。</p>
<p>GET、POST、PUT、DELETE</p>
<p>GET、POST、PUT和DELETE是HTTP协议中定义的常用请求方法，用于对服务器资源进行不同类型的操作。</p>
<ol>
<li><p>GET：用于从服务器获取资源，常用于获取数据。GET请求是幂等的，即多次执行相同的GET请求应该返回相同的结果，不应该对服务器产生副作用。GET请求的参数可以通过URL的查询字符串传递，也可以通过请求体传递（例如在RESTful API中使用JSON格式的请求体）。</p>
</li>
<li><p>POST：用于向服务器提交数据，常用于创建新的资源。POST请求不是幂等的，即多次执行相同的POST请求可能会创建多个资源。POST请求的参数通常包含在请求体中，用于传递需要提交的数据。</p>
</li>
<li><p>PUT：用于更新服务器上的资源，常用于更新已存在的资源。PUT请求是幂等的，即多次执行相同的PUT请求应该产生相同的结果。PUT请求通常需要提供完整的资源表示，即需要将所有的属性值都传递给服务器。</p>
</li>
<li><p>DELETE：用于删除服务器上的资源，常用于删除不再需要的资源。DELETE请求是幂等的，即多次执行相同的DELETE请求应该产生相同的结果。DELETE请求的URI通常包含要删除的资源的唯一标识，例如”&#x2F;users&#x2F;1”表示删除ID为1的用户。</p>
</li>
</ol>
<p>这些请求方法在RESTful API设计中起着重要的作用，它们定义了对资源的不同操作类型，使得客户端能够以统一和标准的方式与服务器进行交互。根据具体的应用场景和需求，选择合适的请求方法来进行资源操作。</p>
<p>什么是BEAN</p>
<p>在计算机编程领域，”Bean”一词通常用于表示可重用的软件组件，特别是在Java编程语言中。在Java中，Bean是指符合一定规范的Java对象，它具有以下特征：</p>
<ol>
<li>具有私有的成员变量（属性）：Bean通常定义了一组私有的成员变量，用于存储对象的状态。</li>
<li>提供公共的访问方法：Bean通过公共的getter和setter方法，提供对成员变量的访问和修改。</li>
<li>符合JavaBean规范：JavaBean是一种特殊类型的Bean，它需要满足一些规范，如具有无参构造函数、实现可序列化接口等。</li>
</ol>
<p>Bean的概念旨在提供一种可重用和可组合的编程模型，通过封装对象的状态和行为，使得开发人员能够更加方便地进行代码复用和模块化开发。在Java中，Bean通常用于描述业务逻辑、数据模型、服务组件等，它们可以被其他代码引用和调用。</p>
<p>在Java的开发框架中，比如Spring框架，Bean是指由Spring容器管理的对象，它们通过配置文件或注解的方式进行声明和创建。Spring Bean具有生命周期管理、依赖注入等特性，可以被动态地创建、初始化、销毁，并通过容器进行管理和协调。Spring框架通过Bean的管理和依赖注入，实现了松耦合、可测试性和可扩展性，提供了强大的面向对象编程支持。</p>
<p>什么是松耦合</p>
<p>松耦合（Loose coupling）是软件设计中的一个原则，用于描述模块或组件之间的关系。它指的是模块或组件之间的依赖关系应该尽量减少或降低，使得它们能够独立地进行修改、扩展和测试，而不会对其他模块或组件造成过大的影响。</p>
<p>松耦合的设计具有以下特点：</p>
<ol>
<li><p>低依赖性：模块之间的依赖应该尽量减少，避免直接依赖于具体的实现细节。模块之间的通信应该基于抽象接口或协议，而不是依赖具体的类或对象。</p>
</li>
<li><p>接口隔离：模块之间的接口应该是精简的，只包含必要的方法和属性，避免暴露不必要的细节。每个模块都应该有清晰的职责和接口定义，避免对其他模块的实现细节产生依赖。</p>
</li>
<li><p>解耦合：模块之间应该尽量解耦，即减少相互之间的直接关联性。通过中间层、消息传递、事件驱动等方式，实现模块之间的解耦，使得模块能够独立地进行修改和演化。</p>
</li>
<li><p>可扩展性：松耦合的设计能够更好地支持系统的扩展和修改。当需要添加新的功能或模块时，可以通过新增模块、替换组件等方式进行扩展，而不会对其他模块产生较大的影响。</p>
</li>
</ol>
<p>通过实现松耦合的设计，可以提高系统的可维护性、可测试性和可扩展性。松耦合的模块更易于理解、修改和重用，同时也降低了代码之间的耦合度，使得系统更加灵活和可靠。</p>
<p>举个例子</p>
<p>假设我们有一个简单的订单管理系统，包含订单模块和库存模块。下面是一个例子来说明松耦合的概念：</p>
<p>在紧耦合的设计中，订单模块和库存模块可能直接依赖于彼此的实现细节，相互之间存在强耦合关系。例如，订单模块可能直接调用库存模块的方法来查询库存情况，并根据库存数量进行一些处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderModule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> InventoryModule inventory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderModule</span><span class="params">()</span> &#123;</span><br><span class="line">        inventory = <span class="keyword">new</span> <span class="title class_">InventoryModule</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取库存数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> inventory.getQuantity(order.getProduct());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据库存情况进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (quantity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 下单逻辑...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 库存不足逻辑...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，订单模块直接依赖于库存模块的实现，并且直接调用了库存模块的方法。这种紧耦合的设计存在以下问题：</p>
<ul>
<li>当库存模块的实现发生变化时，订单模块也需要相应地进行修改。</li>
<li>难以对订单模块和库存模块进行单独的测试，因为它们之间的关联性很高。</li>
</ul>
<p>相反，在松耦合的设计中，订单模块和库存模块之间通过接口进行通信，彼此之间不存在直接的依赖关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InventoryService</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getQuantity</span><span class="params">(String product)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderModule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> InventoryService inventory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderModule</span><span class="params">(InventoryService inventory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inventory = inventory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取库存数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> inventory.getQuantity(order.getProduct());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据库存情况进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (quantity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 下单逻辑...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 库存不足逻辑...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，订单模块通过依赖注入的方式获取库存模块的实现，而不是直接实例化库存模块。这种松耦合的设计带来了以下好处：</p>
<ul>
<li>订单模块和库存模块之间解耦，它们可以独立地进行修改和扩展。</li>
<li>可以通过实现不同的<code>InventoryService</code>接口来切换不同的库存服务，而不会对订单模块的实现造成影响。</li>
<li>可以更方便地对订单模块和库存模块进行单独的测试，因为它们之间的关联性降低。</li>
</ul>
<p>这个例子展示了松耦合设计的思想，通过接口抽象和依赖注入等方式，实现了模块之间的解耦，提高</p>
<p>了系统的可维护性和扩展性。</p>
<p>什么是事务</p>
<p>事务（Transaction）是指一组数据库操作组成的逻辑单位，它要么全部执行成功，要么全部失败回滚。事务具有以下特性，通常被称为 ACID 特性：</p>
<ol>
<li><p>原子性（Atomicity）：事务中的操作要么全部执行成功，要么全部失败回滚，不存在部分执行的情况。如果事务中的任意操作失败，系统将撤销已经执行的操作，回滚到事务开始前的状态。</p>
</li>
<li><p>一致性（Consistency）：事务执行前和执行后，数据库的完整性约束没有被破坏。即使事务中的操作可能改变数据库中的数据状态，但是这些变化必须满足预定义的规则，确保数据库的一致性。</p>
</li>
<li><p>隔离性（Isolation）：并发执行的事务之间相互隔离，一个事务的执行不应该影响其他事务的结果。每个事务都应该感觉到自己是在独占地使用数据库，不会被其他事务干扰。</p>
</li>
<li><p>持久性（Durability）：一旦事务提交成功，其结果应该持久保存在数据库中，并且对于系统故障或崩溃的情况下也能够恢复。持久性保证了事务的结果不会因为系统故障而丢失。</p>
</li>
</ol>
<p>事务通常通过以下四个关键操作来管理：</p>
<ol>
<li><p>开始事务（BEGIN）：标记事务的开始，事务中的操作将被记录并可以进行回滚。</p>
</li>
<li><p>提交事务（COMMIT）：将事务中的操作应用到数据库，并使其成为永久性的更改。</p>
</li>
<li><p>回滚事务（ROLLBACK）：撤销事务中的操作，将数据库恢复到事务开始前的状态。</p>
</li>
<li><p>设置保存点（SAVEPOINT）：在事务中设置一个保存点，可以在回滚时将事务回滚到该保存点之前的状态。</p>
</li>
</ol>
<p>事务的使用可以确保数据库操作的一致性和完整性，特别是在并发环境下，可以避免数据的混乱和冲突。常见的数据库管理系统如 MySQL、Oracle、PostgreSQL 等都支持事务的概念和相关操作。在应用开发中，事务的正确使用可以保证数据的可靠性和一致性。</p>
<p>什么是分布式</p>
<p>分布式（Distributed）是指在多台计算机或多个节点上协同工作的系统或应用程序。在分布式系统中，多个计算节点通过网络相互连接，共同完成任务或提供服务，形成一个整体。</p>
<p>分布式系统的设计目标通常包括以下几个方面：</p>
<ol>
<li><p>可扩展性：能够方便地增加或减少计算节点，以应对负载的变化，实现水平扩展。</p>
</li>
<li><p>高可用性：通过冗余和故障转移机制，保证系统在部分节点或组件故障的情况下仍然可用。</p>
</li>
<li><p>容错性：分布式系统能够容忍节点或组件的故障，并且能够自动进行故障恢复。</p>
</li>
<li><p>性能：利用分布式计算资源，提高系统的计算、存储和网络性能。</p>
</li>
<li><p>数据一致性：在分布式环境下，保证数据在不同节点之间的一致性，避免数据的冲突和不一致。</p>
</li>
</ol>
<p>分布式系统面临的挑战和问题包括：</p>
<ol>
<li><p>通信和网络延迟：分布式系统依赖于网络进行节点之间的通信，网络延迟和不可靠性可能会影响系统的性能和可靠性。</p>
</li>
<li><p>数据一致性：在分布式环境下，多个节点可能并发地读写数据，需要采取合适的机制来保证数据的一致性。</p>
</li>
<li><p>并发控制：多个节点并发地进行计算和操作，需要解决并发访问共享资源的冲突问题。</p>
</li>
<li><p>故障处理：分布式系统中的节点可能会发生故障，需要采取故障检测和故障转移机制来保证系统的可用性。</p>
</li>
</ol>
<p>常见的分布式系统包括分布式数据库系统、分布式文件系统、分布式缓存系统等。分布式系统的设计和实现涉及到分布式算法、一致性协议、负载均衡、故障恢复等技术。分布式系统的优势在于提供高性能、可伸缩性和可靠性，但也增加了系统设计和管理的复杂性。</p>
<p>分布式数据库系统、分布式文件系统、分布式缓存系</p>
<p>分布式数据库系统（Distributed Database System）是一种将数据存储和处理分布在多个计算节点上的数据库系统。它允许数据在多个节点之间进行分片存储，并提供分布式查询和事务处理能力。</p>
<p>分布式数据库系统的设计目标是提高数据的可扩展性、可用性和性能。它通常具有以下特点：</p>
<ol>
<li><p>数据分片：将数据划分为多个分片，每个分片存储在不同的节点上，实现数据的分布存储。分片可以按照不同的策略进行，如范围分片、哈希分片等。</p>
</li>
<li><p>数据复制：为了提高数据的可用性和容错性，分布式数据库系统通常会对数据进行复制，并将副本存储在多个节点上。数据的复制可以采用同步复制或异步复制的方式。</p>
</li>
<li><p>数据一致性：在分布式环境下，确保数据的一致性是一个重要的挑战。分布式数据库系统通常使用一致性协议和机制来解决数据一致性的问题，如基于副本的一致性协议、分布式事务协议等。</p>
</li>
<li><p>查询优化和路由：分布式数据库系统需要考虑将查询请求路由到合适的节点上进行处理，并进行查询优化，以提高查询性能。</p>
</li>
</ol>
<p>分布式文件系统（Distributed File System）是一种将文件数据存储在多个计算节点上的文件系统。它将文件划分为多个块（Block），并将块分布存储在不同的节点上，实现文件的分布式存储和访问。</p>
<p>分布式文件系统的设计目标是提供高可用性、可扩展性和容错性。它通常具有以下特点：</p>
<ol>
<li><p>数据分布和复制：文件数据被划分为多个块，并将块分布存储在多个节点上。为了提高可用性和容错性，文件块通常会进行多次复制，并存储在不同的节点上。</p>
</li>
<li><p>文件访问和路由：分布式文件系统提供文件访问接口，可以通过文件名或文件路径进行文件的读取和写入操作。文件系统需要考虑将文件访问请求路由到存储了相应块的节点上。</p>
</li>
<li><p>一致性和一致性协议：分布式文件系统需要考虑多个节点之间的数据一致性问题。通常使用一致性协议和副本管理策略来保证数据的一致性。</p>
</li>
</ol>
<p>分布式缓存系统（Distributed Cache System）是一种将数据缓存分布在多个计算节点上的缓存系统。它通过在节点上存储一部分热点数据，以提高数据访问的性能和响应速度。</p>
<p>分布式缓存系统的设计目标是提供高速的数据访问和低延迟。它通常具有以下特点：</p>
<ol>
<li><p>数据分片和路由：缓存数据被分片存储在多个节点上，根据数据的键（Key）进行路由和访问。这样可以将缓存数据均匀分布在多个节点上，避免单个节点的负载过高。</p>
</li>
<li><p>缓存更新和失效：分布式缓存系统需要考虑缓存数据的更新和失效问题。当数据发生变化时，需要及时更新缓存数据；当数据过期或失效时，需要从后端数据源重新加载数据。</p>
</li>
<li><p>缓存一致性：在分布式缓存系统中，多个节点上的缓存数据需要保持一致。通常使用缓存一致性协议和缓存失效策略来解决数据一致性的问题。</p>
</li>
</ol>
<p>这些分布式系统在大规模、高并发的应用场景中发挥着重要作用，提供了可扩展性、高可用性和性能等方面的优势。它们的设计和实现涉及到分布式算法、一致性协议、数据分片和复制、负载均衡等技术。</p>
<p>希尔排序，c++</p>
<p>下面是一个使用C++实现的希尔排序算法示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希尔排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义步长序列</span></span><br><span class="line">    <span class="type">int</span> gap = n / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每个步长进行插入排序</span></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在当前步长下进行插入排序</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新步长</span></span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前的数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">shellSort</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码演示了如何使用C++实现希尔排序算法。在希尔排序中，通过不断缩小步长并对子序列进行插入排序，最终实现对整个序列的排序。该算法具有较高的效率和较好的平均时间复杂度。</p>
<p>1、cpu三级缓存，每层干什么<br>2、进程线程区别，进程通信方式<br>3、http长连接如何实现<br>4、get post区别，get请求参数过长如何解决<br>5、用户态，内核态区别，java线程属于哪一个状态原因，如何实现读写并发，读写内存<br>6、java常见集合类，线程安全的map<br>7、锁的实现方式，公平非公平锁优缺点<br>8、CAS，优缺点，缺点的解决<br>9、线程池核心参数<br>10、jvm类加载过程<br>11、聚簇索引，非聚簇索引，如何避免回表查找<br>12、最左匹配，行锁<br>13、常见事务隔离级别，生产环境使用哪个，隔离级别的影响<br>14、redis常用数据结构，排行榜使用什么<br>15、缓存穿透，雪崩，如何解决<br>16、你做项目最有收获的地方？<br>17、订单多次创建，幂等性问题</p>
<ol>
<li><p>CPU三级缓存的作用如下：</p>
<ul>
<li>第一级缓存（L1 Cache）：位于CPU内部，与CPU核心紧密相连，速度最快。用于存储最常用的数据和指令。</li>
<li>第二级缓存（L2 Cache）：位于CPU内部，较大容量，速度较快。用于存储CPU频繁访问但不在L1 Cache中的数据和指令。</li>
<li>第三级缓存（L3 Cache）：位于CPU外部，容量更大，速度较慢。用于存储CPU访问次数较少但仍然需要快速访问的数据和指令。</li>
</ul>
<p>CPU缓存的目的是提高CPU的数据访问速度，通过将常用的数据和指令存储在高速缓存中，减少了对主内存的访问次数，从而加快程序的执行速度。</p>
</li>
<li><p>进程和线程的区别：</p>
<ul>
<li>进程是程序的执行实例，是操作系统进行资源分配和调度的基本单位。每个进程都拥有独立的内存空间，包括代码、数据和堆栈等。</li>
<li>线程是进程的执行单元，一个进程可以包含多个线程。线程共享进程的内存空间，包括代码、数据和堆栈等，因此线程之间的数据共享较为方便。</li>
</ul>
<p>进程间通信的方式包括管道、信号量、共享内存、消息队列等。</p>
</li>
<li><p>HTTP长连接的实现是通过在一个TCP连接上进行多次HTTP请求和响应，而不是每次请求都建立和关闭一次TCP连接。在HTTP请求头中使用<code>Connection: keep-alive</code>来表示使用长连接。</p>
</li>
<li><p>GET和POST是HTTP协议中的两种常见请求方法：</p>
<ul>
<li>GET请求用于获取资源，参数通过URL的查询字符串传递，有长度限制，一般用于查询数据。</li>
<li>POST请求用于提交数据，参数通过请求体传递，没有长度限制，一般用于提交表单数据或上传文件。</li>
</ul>
<p>如果GET请求的参数过长，可以将参数放在请求体中进行POST请求，或者使用分段请求等方式将参数拆分为多个请求。</p>
</li>
<li><p>用户态和内核态是CPU执行指令时的两种工作模式：</p>
<ul>
<li>用户态：程序运行在用户空间，只能访问受限资源，无法直接访问硬件和操作系统内核。</li>
<li>内核态：操作系统运行在内核空间，可以访问系统的所有资源和硬件。</li>
</ul>
<p>Java线程属于用户态，因为Java虚拟机（JVM）是运行在用户空间的，Java线程的调度和管理是由JVM负责的。</p>
<p>读写并发可以通过使用锁机制（如读写锁</p>
</li>
</ol>
<p>）或使用线程安全的数据结构来实现。读操作可以并发执行，写操作需要互斥进行。</p>
<ol start="6">
<li><p>Java常见的集合类包括ArrayList、LinkedList、HashMap、HashSet等。线程安全的Map有ConcurrentHashMap。</p>
</li>
<li><p>锁的实现方式包括悲观锁和乐观锁。公平锁和非公平锁是悲观锁的两种实现方式：</p>
<ul>
<li>公平锁：按照申请锁的顺序来获取锁，遵循先来先得的原则。</li>
<li>非公平锁：不保证按照申请锁的顺序来获取锁，允许插队。</li>
</ul>
<p>公平锁的优点是保证了资源的公平性，缺点是可能导致线程频繁切换。非公平锁的优点是效率较高，缺点是可能会导致某些线程长时间无法获取锁。</p>
</li>
<li><p>CAS（Compare and Swap）是一种无锁算法，用于实现多线程环境下的原子操作。CAS操作包括读取一个内存位置的值、比较该值与预期值、根据比较结果来更新内存位置的值。</p>
<p>CAS的优点是无锁、高效，可以避免线程的切换和阻塞等开销。缺点是当多个线程同时执行CAS操作时，只有一个线程能成功，其他线程需要重新尝试，可能导致性能下降。</p>
<p>CAS的缺点可以通过使用自旋锁或者将CAS操作转化为有锁的操作来解决。</p>
</li>
<li><p>线程池的核心参数包括线程池大小、核心线程数、最大线程数、线程空闲时间等。线程池的大小决定了可以同时执行的任务数量，核心线程数是线程池中保持活动状态的线程数，最大线程数是线程池中允许存在的最大线程数，线程空闲时间是线程在无任务可执行时保持活动状态的时间。</p>
</li>
<li><p>JVM的类加载过程包括加载、验证、准备、解析和初始化五个阶段。加载阶段将类的字节码加载到内存中，验证阶段验证字节码的正确性，准备阶段为类的静态变量分配内存并初始化默认值，解析阶段将符号引用转换为直接引用，初始化阶段执行类的初始化代码，包括静态变量的赋值和静态代码块的执行。</p>
</li>
<li><p>聚簇索引是将数据行存储在磁盘上物理上相邻的位置，非聚簇索引是将索引项存储在磁盘上物理上相邻的位置。为了避免</p>
</li>
</ol>
<p>回表查找，可以将需要的列都包含在索引中，这样就可以通过索引直接获取所需数据，而不需要再次访问表。</p>
<ol start="12">
<li><p>最左匹配指的是在查询条件中使用多列索引时，索引列的顺序对查询的效率有影响，查询条件中使用的索引列的顺序要与索引定义的列的顺序一致，才能发挥最佳的索引效果。行锁是数据库中的锁机制，用于保证并发操作的一致性和数据的完整性。</p>
</li>
<li><p>常见的事务隔离级别有读未提交、读已提交、可重复读和串行化。在生产环境中一般使用读已提交（Read Committed）隔离级别。事务隔离级别的选择会影响并发性能和数据的一致性。</p>
</li>
<li><p>Redis常用的数据结构有字符串（String）、哈希表（Hash）、列表（List）、集合（Set）和有序集合（Sorted Set）。排行榜可以使用有序集合来实现，将每个成员作为排名对象，分数作为排名标准。</p>
</li>
<li><p>缓存穿透是指缓存和数据库中都没有需要的数据，导致每次请求都穿透缓存访问数据库，解决方式可以使用布隆过滤器过滤不存在的数据。缓存击穿是指某个热点数据失效，导致大量请求同时访问数据库，解决方式可以使用互斥锁或者设置短暂的缓存过期时间。缓存雪崩是指大量缓存同时失效，导致所有请求都直接访问数据库，解决方式可以设置随机的缓存过期时间或使用分布式缓存方案。</p>
</li>
<li><p>在项目中最有收获的地方可以是技术的成长、解决复杂问题的经验、与团队合作的能力提升等。</p>
</li>
<li><p>订单多次创建可能导致幂等性问题，即多次创建的结果不一致。可以通过在创建订单时使用唯一标识符（如订单号）来确保幂等性，当重复创建时，检查该标识符是否已存在，如果已存在则不执行重复创建操作。</p>
</li>
</ol>
<p>学校的主要课程（说了一堆，他问我有没有学过数据结构，我说有）<br>归并排序的原理？<br>快排的原理？<br>你刚刚说到快排取中间值，怎么取的？<br>为什么快排要取随机值？<br>快排在最坏的情况下和冒泡比谁快，为什么？<br>时间复杂度是怎么算的？（不会）<br>数据库了解多少（说了mysql、redis、mongoDB、elasticsearch，说对mysql和redis比较熟悉）<br>mysql有多少种索引（他说我在背书）<br>你平时是怎么用索引的<br>存储过程和函数知道吗，分别是什么<br>redis的特性<br>redis集群有搭建过吗（我说没有搭建过，他直接不问了，这个背了的，下次直接说搭建过）<br>DDD是什么，全称是什么，怎么理解DDD？<br>有没有不是学习的项目（没懂什么意思问了下，我说青训营项目和学校比赛的，他说这只能算学习项目。然后说了下在公司做的项目，介绍了下公司的项目的背景和做的事情）<br>前端了解多少，vue能用到什么水平，jQuery会用吗？<br>我们有两个base上海和广东，你更倾向哪个？（广东）<br>你对自己怎么定义，期望薪资多少（定义：只想干后端，纯后端）</p>
<p>学校的主要课程可以包括数据结构、算法设计与分析、操作系统、数据库系统、计算机网络、软件工程等。</p>
<p>归并排序的原理是将待排序的序列不断分割成较小的子序列，然后将这些子序列进行合并，合并过程中按照顺序将元素进行比较和排序，最终得到一个有序的序列。</p>
<p>快速排序的原理是选择一个基准元素，通过将待排序序列分割成左右两个子序列，使得左边的序列元素都小于等于基准元素，右边的序列元素都大于等于基准元素。然后对左右子序列递归地进行快速排序，最终得到一个有序的序列。</p>
<p>快排取中间值是指在选择基准元素时，取待排序序列的中间位置的元素作为基准元素。</p>
<p>快排要取随机值是为了避免最坏情况的发生，即待排序序列已经是有序的或者近乎有序的情况下，如果每次选择的基准元素都是最大或最小值，快排的效率会降低。通过随机选择基准元素，可以增加快排的平均性能。</p>
<p>快排在最坏的情况下比冒泡排序更快，因为快排采用分治的思想，将序列分割成较小的子序列进行排序，可以减少比较和交换的次数，而冒泡排序是通过相邻元素的比较和交换进行排序，所以在最坏情况下，快排的时间复杂度要低于冒泡排序。</p>
<p>时间复杂度是一种衡量算法运行时间与输入规模的关系的度量方式。通常使用大O表示法来表示时间复杂度，例如O(n)、O(n^2)等。时间复杂度可以通过分析算法的执行次数或基本操作的执行次数来推导得出。</p>
<p>数据库方面，我对MySQL和Redis比较熟悉。MySQL是一种关系型数据库，常用于存储结构化数据，具有良好的事务支持和丰富的查询功能。Redis是一种基于内存的键值存储系统，常用于缓存和高速读写场景。</p>
<p>MySQL有多种索引，包括主键索引、唯一索引、普通索引、全文索引等。索引的作用是提高数据的查询效率，通过创建索引可以快速定位到符合条件的数据行。</p>
<p>我在使用索引时，会根据查询的条件和字段的选择性来决定是否创建索引。对于经常被查询的字段或常用作查询条件的字段，可以</p>
<p>考虑创建索引以提高查询性能。但同时也需要注意索引的维护成本和对更新操作的影响。</p>
<p>存储过程和函数是数据库中的两种可执行的程序单元。存储过程是一组预编译的SQL语句集合，可接受参数和返回结果。函数是一个具有输入参数和返回值的可执行程序单元。它们都可以封装一些复杂的业务逻辑，在数据库端执行，减少网络开销和提高执行效率。</p>
<p>Redis具有高性能、高并发、持久化、发布订阅、主从复制、集群等特性。它是一种基于键值对的内存数据库，常用于缓存、队列、计数器等场景。</p>
<p>关于Redis集群，我虽然没有具体搭建过，但我对Redis集群的原理和搭建方式有一定的了解。Redis集群采用分布式的方式存储数据，通过数据分片和节点间的数据复制来实现数据的高可用性和扩展性。可以通过在多个Redis节点之间进行数据的分布和复制来实现数据的负载均衡和容错性。</p>
<p>什么是mysql的索引</p>
<p>MySQL的索引是一种数据结构，用于提高数据库查询操作的效率。索引是在表中某一列或多列上创建的，它们包含了对数据行的引用，以便可以快速定位到满足特定条件的数据行。</p>
<p>MySQL的索引可以分为以下几种类型：</p>
<ol>
<li><p>主键索引（Primary Key Index）：用于唯一标识表中的每一行数据。主键索引在创建表时可以指定，如果没有显式指定，则会自动创建一个隐藏的主键索引。</p>
</li>
<li><p>唯一索引（Unique Index）：用于保证索引列的值在表中是唯一的。唯一索引可以包含空值，但每个非空值只能出现一次。</p>
</li>
<li><p>普通索引（Normal Index）：也称为非唯一索引，用于加快查询速度。多个行可以具有相同的索引值。</p>
</li>
<li><p>全文索引（Full-text Index）：用于在文本数据上执行全文搜索。全文索引适用于大量文本内容的查询，支持关键词搜索和自然语言搜索。</p>
</li>
<li><p>组合索引（Composite Index）：由多个列组合而成的索引，用于加快多列条件查询的速度。组合索引的顺序很重要，根据查询的列顺序来决定是否能够有效使用索引。</p>
</li>
</ol>
<p>索引可以提高查询的速度，因为它们可以减少需要扫描的数据量。然而，索引也会增加数据插入、更新和删除的成本，因为每次修改数据时都需要更新索引。因此，在设计数据库时，需要根据查询的频率和更新的频率来合理地选择索引，以平衡查询性能和数据维护的开销。</p>
<p>有序集合（Sorted Set）</p>
<p>有序集合（Sorted Set）是Redis中的一种数据结构，它类似于集合（Set），但每个元素都关联着一个”分数”（score），通过分数的排序可以将元素按照一定顺序进行存储和访问。</p>
<p>有序集合的特点包括：</p>
<ol>
<li><p>元素的唯一性：每个元素在有序集合中是唯一的，不会存在重复元素。</p>
</li>
<li><p>元素的排序：每个元素都有一个关联的分数，通过分数进行排序。分数可以是浮点数或整数，根据分数的值来决定元素的顺序。</p>
</li>
<li><p>快速的插入、删除和查找：有序集合使用了内部的数据结构（跳表和哈希表）来实现高效的插入、删除和查找操作。</p>
</li>
</ol>
<p>有序集合在实际应用中有广泛的用途，例如：</p>
<ul>
<li><p>排行榜：可以使用有序集合来存储用户的得分，并根据得分进行排名和排序。</p>
</li>
<li><p>计数器：可以使用有序集合来存储计数器的值，每次增减操作都可以更新对应元素的分数。</p>
</li>
<li><p>范围查找：可以根据分数的范围进行查找操作，快速找到满足条件的元素。</p>
</li>
<li><p>任务调度：可以使用有序集合来存储任务的执行时间，按照时间顺序获取需要执行的任务。</p>
</li>
</ul>
<p>有序集合提供了一种灵活且高效的数据结构，能够满足多种场景下的排序和查找需求。在Redis中，可以使用一系列的命令对有序集合进行操作，如添加元素、删除元素、按照分数范围查找等。</p>
<p>底层是什么</p>
<p>在Redis中，有序集合（Sorted Set）的底层数据结构是一个叫做”跳跃表”（Skip List）的数据结构。跳跃表是一种有序的数据结构，通过在普通链表的基础上添加多级索引，提供了快速的查找和插入操作。</p>
<p>跳跃表的特点包括：</p>
<ol>
<li><p>有序性：跳跃表中的元素按照一定的顺序进行排列，可以根据元素的分数进行快速的有序查找。</p>
</li>
<li><p>多级索引：跳跃表通过添加多级索引来加速查找操作，索引层数越高，查找速度越快。每一层索引都是一个有序链表，其中每个节点保存了下一层索引的指针。</p>
</li>
<li><p>空间效率：跳跃表在维持有序性的同时，也要尽量减少额外的空间消耗。相比于平衡树等其他数据结构，跳跃表具有较好的空间效率。</p>
</li>
</ol>
<p>跳跃表是一种高效的数据结构，适用于需要有序性和快速查找的场景。在Redis中，有序集合使用跳跃表作为底层数据结构，使得有序集合具备了快速插入、删除和按分数范围查找的能力。</p>
<p>怎么解决死锁</p>
<p>死锁是多线程或多进程程序中常见的一个问题，它发生在两个或多个线程或进程相互等待对方释放资源的情况下，导致程序无法继续执行。解决死锁问题需要采取一些策略和技术，以下是一些常见的方法：</p>
<ol>
<li><p><strong>避免死锁</strong>：通过合理地设计系统和资源分配策略，避免进程或线程陷入死锁的状态。这可以通过合理的资源分配顺序、资源申请的限制和超时机制等来实现。</p>
</li>
<li><p><strong>使用资源分配图</strong>：通过绘制资源分配图，可以分析出哪些资源被哪些进程或线程占用，从而更好地了解可能导致死锁的情况。根据图中的信息，可以调整资源分配策略以避免死锁。</p>
</li>
<li><p><strong>引入超时机制</strong>：在等待资源时，引入超时机制，如果等待时间过长，可以放弃当前请求，释放已占用的资源，避免进程或线程一直等待而导致死锁。</p>
</li>
<li><p><strong>按序申请资源</strong>：确保进程或线程按照特定的顺序申请资源，避免出现循环等待的情况。</p>
</li>
<li><p><strong>使用资源分级</strong>：将资源划分为不同的等级，确保进程或线程只能按照一定顺序申请资源，避免相互等待。</p>
</li>
<li><p><strong>采用死锁检测和恢复机制</strong>：实现死锁检测算法，及时检测出死锁的发生，然后采取恢复措施，比如回退资源分配、终止部分进程等。</p>
</li>
<li><p><strong>精心规划资源释放策略</strong>：在申请资源后，规划好资源的释放策略，避免长时间持有资源而阻塞其他进程。</p>
</li>
<li><p><strong>使用同步原语</strong>：合理使用锁、信号量等同步原语，确保资源的访问是有序的，从而避免死锁。</p>
</li>
<li><p><strong>引入资源预约</strong>：资源预约机制可以使进程在申请资源之前提前预约所需资源，从而降低死锁的可能性。</p>
</li>
<li><p><strong>监控和报警系统</strong>：实现监控系统，及时发现死锁问题并触发警报，便于及时处理。</p>
</li>
</ol>
<p>解决死锁是一个复杂的问题，需要根据具体情况采取不同的策略和方法。在编写多线程或多进程程序时，需要充分考虑资源分配和释放的顺序，以及合理地设计同步机制，从而避免死锁问题的发生。</p>
<p>你提出了许多问题，我会逐一回答：</p>
<ol>
<li><p><strong>MySQL的binlog和redolog如何保证一致性？</strong></p>
<ul>
<li>MySQL的binlog和redolog都是用于事务的持久化和恢复，但它们服务于不同的目的。Redo log是在事务提交前记录，以保证事务的持久性。Binlog记录的是逻辑日志，可以用于复制和恢复。</li>
<li>一致性是通过在事务提交前将操作记录到redo log，并在事务提交后再记录到binlog，来保证的。如果在提交前出现问题，MySQL可以通过redo log进行恢复。如果在提交后出现问题，binlog可以用于恢复。</li>
</ul>
</li>
<li><p><strong>类加载时class文件加载到JVM的什么区域？</strong></p>
<ul>
<li>类加载时的class文件会加载到JVM的方法区（Metaspace）中。方法区存储类的结构信息、静态变量、常量池等。</li>
</ul>
</li>
<li><p><strong>父类加载器能访问子类加载器吗？反过来呢？</strong></p>
<ul>
<li>父类加载器可以访问子类加载器加载的类，但反过来是不行的。这是由类加载器的双亲委派模型所决定的。</li>
</ul>
</li>
<li><p><strong>父类怎么访问子类？</strong></p>
<ul>
<li>父类无法直接访问子类，因为子类可能在不同的类加载器命名空间中。如果需要进行类的转型操作，应该在具体使用的位置进行。</li>
</ul>
</li>
<li><p><strong>OOM实际解决过吗？看过MySQL和Redis源码吗？</strong></p>
<ul>
<li>这是多个问题，是的，我可以帮助解决OOM问题。我也熟悉MySQL和Redis的基本工作原理，但可能并不深入。</li>
</ul>
</li>
<li><p><strong>喜欢研究算法还是工程？</strong></p>
<ul>
<li>我是一个AI模型，没有情感，但我能够处理算法和工程问题。</li>
</ul>
</li>
<li><p><strong>抽奖系统设计题：怎么保证中奖者一定能收到奖品？考虑发奖失败的情况？高概率的热门奖品怎么处理？库存hotkey遇到超高并发怎么办？</strong></p>
<ul>
<li>这是一个比较复杂的设计问题，需要考虑分布式事务、消息队列等方案，以确保中奖者能够收到奖品，同时保证系统的可用性和一致性。</li>
</ul>
</li>
<li><p><strong>synchronized实现底层？</strong></p>
<ul>
<li><code>synchronized</code> 的实现底层是通过对象头中的标志位来实现的，当线程进入同步块时会尝试获取锁，如果锁已被其他线程占用，线程会被阻塞，直到锁被释放。</li>
</ul>
</li>
<li><p><strong>什么叫死锁？写出SQL模拟一个死锁。</strong></p>
<ul>
<li>死锁是指两个或多个进程（线程）在互相等待对方持有的资源，从而造成的一种僵局。例如：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Session 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> table1 <span class="keyword">SET</span> column1 <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Session 2</span></span><br><span class="line"><span class="keyword">UPDATE</span> table2 <span class="keyword">SET</span> column2 <span class="operator">=</span> <span class="number">2</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Session 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> table2 <span class="keyword">SET</span> column2 <span class="operator">=</span> <span class="number">2</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>; <span class="comment">-- 等待 table2 的锁</span></span><br><span class="line"><span class="comment">-- Session 2</span></span><br><span class="line"><span class="keyword">UPDATE</span> table1 <span class="keyword">SET</span> column1 <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 等待 table1 的锁</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>保证分布式一致性的所有方法？</strong></p>
<ul>
<li>一致性算法如 Paxos、Raft，分布式锁，分布式事务，消息队列，分布式数据存储等。</li>
</ul>
</li>
<li><p><strong>一条Java代码执行会发生什么，说得越底层越好。</strong></p>
<ul>
<li>一条Java代码的执行包括：编译为字节码、类加载、字节码解释、即时编译（JIT）等阶段。字节码解释和JIT编译会生成本地机器码，进而被CPU执行。</li>
</ul>
</li>
<li><p><strong>实习过程中干什么最有成就感？</strong></p>
<ul>
<li>我没有情感，但通常实习过程中完成一个复杂的任务、解决一个难题或者看到自己的工作产生实际影响会带来成就感。</li>
</ul>
</li>
<li><p><strong>觉得设计模式的意义是什么，真的必要吗？</strong></p>
<ul>
<li>设计模式是为了解决软件设计中的常见问题而提出的一些通用解决方案。在合适的情况下，设计模式可以使代码更具可读性、可维护性和扩展性，但并不是所有情况都需要使用设计模式。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://risingrode.github.io">fcw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://risingrode.github.io/post/%E9%9D%A2%E7%BB%8F.html">https://risingrode.github.io/post/面经.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://risingrode.github.io" target="_blank">阿威的代码小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><div class="post_share"><div class="social-share" data-image="https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/java%E9%9B%86%E5%90%88.html" title="java集合"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java集合</div></div></a></div><div class="next-post pull-right"><a href="/post/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-%E6%84%9F%E6%82%9F.html" title="认知觉醒-感悟"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">认知觉醒-感悟</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/girl.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">fcw</div><div class="author-info__description">一个收藏回忆与分享技术的地方！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Risingrode"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到cwRising的博客</div></div><div class="card-widget"><div class="item-headline"><i></i><span></span></div><div class="item-content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E7%BB%8F"><span class="toc-number">1.</span> <span class="toc-text">面经</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%A6%81%E6%B1%82%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD%E3%80%82"><span class="toc-number">1.1.</span> <span class="toc-text">请求一个网页链接的过程，要求越详细越好。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8Cmysql%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">Redis 将数据存储在内存中，mysql把数据存在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E%E7%A3%81%E7%9B%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">内存与磁盘的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-number">1.4.</span> <span class="toc-text">B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%92%8Chttps%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">http和https区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.6.</span> <span class="toc-text">Socket是什么</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96.html" title="缓存优化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/11/22/QUNpGAm1nozKJ7s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="缓存优化"/></a><div class="content"><a class="title" href="/post/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96.html" title="缓存优化">缓存优化</a><time datetime="2023-11-24T04:27:47.000Z" title="发表于 2023-11-24 12:27:47">2023-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/redis.html" title="redis"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/11/22/Y65fK7QPnFLEzjs.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis"/></a><div class="content"><a class="title" href="/post/redis.html" title="redis">redis</a><time datetime="2023-11-24T04:23:56.000Z" title="发表于 2023-11-24 12:23:56">2023-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/nginx.html" title="nginx"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/11/22/Y65fK7QPnFLEzjs.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nginx"/></a><div class="content"><a class="title" href="/post/nginx.html" title="nginx">nginx</a><time datetime="2023-11-24T04:19:16.000Z" title="发表于 2023-11-24 12:19:16">2023-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/Linux.html" title="Linux"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/11/22/vn34S5LkA1BwDgH.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux"/></a><div class="content"><a class="title" href="/post/Linux.html" title="Linux">Linux</a><time datetime="2023-11-24T04:06:04.000Z" title="发表于 2023-11-24 12:06:04">2023-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/Typora%E8%AF%B4%E6%98%8E.html" title="Typora说明"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/11/22/vn34S5LkA1BwDgH.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Typora说明"/></a><div class="content"><a class="title" href="/post/Typora%E8%AF%B4%E6%98%8E.html" title="Typora说明">Typora说明</a><time datetime="2023-11-24T01:43:36.000Z" title="发表于 2023-11-24 09:43:36">2023-11-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By fcw</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://risingrode.github.io/post/%E9%9D%A2%E7%BB%8F.html'
    this.page.identifier = '/post/%E9%9D%A2%E7%BB%8F.html'
    this.page.title = '面经'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><link rel="stylesheet" href="/dist/APlayer.min.css"> <div id="aplayer"></div> <script type="text/javascript" src="/dist/APlayer.min.js"></script> <script type="text/javascript" src="/js/aplayer/music.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>