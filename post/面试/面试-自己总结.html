<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>面试高频考点 | 代码有点萌</title><meta name="author" content="fcw,3185087246@protonmail.com"><meta name="copyright" content="fcw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言根据一个大佬的收集整理而来  链接网站：http://localhost:4000/post/csdn.html  对JVM的理解(8-24)JDK包括什么Java Development Kit (JDK) 是用于开发和编译 Java 应用程序的软件包。  编译器（javac）： 它将 Java 源代码编译成 Java 字节码，这是 Java 虚拟机（JVM）可以理解和执行的中间代码。 运行">
<meta property="og:type" content="article">
<meta property="og:title" content="面试高频考点">
<meta property="og:url" content="https://risingrode.github.io/post/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95-%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93.html">
<meta property="og:site_name" content="代码有点萌">
<meta property="og:description" content="前言根据一个大佬的收集整理而来  链接网站：http://localhost:4000/post/csdn.html  对JVM的理解(8-24)JDK包括什么Java Development Kit (JDK) 是用于开发和编译 Java 应用程序的软件包。  编译器（javac）： 它将 Java 源代码编译成 Java 字节码，这是 Java 虚拟机（JVM）可以理解和执行的中间代码。 运行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i0.hippopx.com/photos/997/702/475/road-train-landscape-storm-thumb.jpg">
<meta property="article:published_time" content="2023-08-24T14:47:14.000Z">
<meta property="article:modified_time" content="2023-12-21T08:11:23.920Z">
<meta property="article:author" content="fcw">
<meta property="article:tag" content="面试高频考点">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i0.hippopx.com/photos/997/702/475/road-train-landscape-storm-thumb.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://risingrode.github.io/post/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95-%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试高频考点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-21 16:11:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="/live2d-widget-master/autoload.js"></script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/girl.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 优质网站链接</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i0.hippopx.com/photos/997/702/475/road-train-landscape-storm-thumb.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="代码有点萌"><span class="site-name">代码有点萌</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 优质网站链接</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试高频考点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-24T14:47:14.000Z" title="发表于 2023-08-24 22:47:14">2023-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-21T08:11:23.920Z" title="更新于 2023-12-21 16:11:23">2023-12-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试高频考点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://i0.hippopx.com/photos/997/702/475/road-train-landscape-storm-thumb.jpg');"></div><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>根据一个大佬的收集整理而来</p>
<blockquote>
<p>链接网站：<a target="_blank" rel="noopener" href="http://localhost:4000/post/csdn.html">http://localhost:4000/post/csdn.html</a></p>
</blockquote>
<h1 id="对JVM的理解-8-24"><a href="#对JVM的理解-8-24" class="headerlink" title="对JVM的理解(8-24)"></a>对JVM的理解(8-24)</h1><h2 id="JDK包括什么"><a href="#JDK包括什么" class="headerlink" title="JDK包括什么"></a>JDK包括什么</h2><p>Java Development Kit (JDK) 是用于开发和编译 Java 应用程序的软件包。</p>
<ol>
<li><strong>编译器（javac）：</strong> 它将 Java 源代码编译成 Java 字节码，这是 Java 虚拟机（JVM）可以理解和执行的中间代码。</li>
<li><strong>运行时环境（JRE）：</strong> JRE 包括了 JVM 以及 Java 标准库，允许你运行已编译的 Java 程序。</li>
</ol>
<h2 id="JVM包括什么"><a href="#JVM包括什么" class="headerlink" title="JVM包括什么"></a>JVM包括什么</h2><p>主要分为下面五个部分：</p>
<ul>
<li>类加载器（Class Loader）：加载字节码文件到内存。</li>
<li>运行时数据区（Runtime Data Area）：JVM 核心内存空间结构模型。</li>
<li>执行引擎（Execution Engine）：对 JVM 指令进行解析，翻译成机器码，解析完成后提交到操作系统中。</li>
<li>本地库接口（Native Interface）：供 Java 调用的融合了不同开发语言的原生库。</li>
<li>本地方法库（Native Libraies）：Java 本地方法的具体实现。</li>
</ul>
<p>这其中最复杂的是运行时数据区，它也是 JVM 内存结构最重要的部分。运行时数据区又可以分为方法区、虚拟机栈、本地方法栈、堆以及程序计数器，并且方法区和堆是线程共享的，虚拟机栈、本地方法栈、程序计数器是线程隔离的。下面详细讲解运行时数据区的各个组成部分。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区存储虚拟机加载的类信息、常量、静态变量以及即时编译器编译后的代码等数据。方法区是一种规范，它的其中一种实现是永久代。JDK 7 以前的版本字符串常量池是放在永久代中的，JDK 7 将字符串常量池移动到了堆中，JDK 8 直接删除了永久代，改用元空间替代永久代。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与 Java 栈的作用和原理基本相同，都可以用来执行方法，不同点在于 Java 栈执行的是 Java 方法，本地方法栈执行的是本地方法。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器占用的内存空间较小，是当前线程所执行的字节码行号指示器，通过改变这个计数器的值来选取下一条需要执行的字节码指令。多个线程之间的程序计数器相互独立，为了保证每个线程恢复后都可以找到具体的执行位置。</p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>Java 堆用来存放实例化对象，它被所有线程共享，在虚拟机启动时创建，用来存放对象实例，其占用了 Java 内存的大部分空间，是 GC 的主要管理区域，又可分为年轻代、老年代、永久代。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>Java 栈中存放的是多个栈帧，每个栈帧对应一个被调用的方法，主要包括局部变量表、操作数栈、动态链接、方法返回地址（方法出口）。每一个方法的执行，JVM 都会创建一个栈帧，并且将栈帧压入 Java 栈，方法执行完毕，该栈帧出栈。也就是说，每个方法的执行都是一个栈帧的入栈和出栈过程，Java 虚拟机栈用来存储栈帧，方法调用结束之后，帧会被销毁。</p>
<h2 id="为什么编译成字节码"><a href="#为什么编译成字节码" class="headerlink" title="为什么编译成字节码"></a>为什么编译成字节码</h2><ol>
<li><p><strong>跨平台性（平台无关性）：</strong> Java 字节码具有跨平台性，也就是说，一旦将源代码编译成字节码，它就可以在任何支持 Java 虚拟机（JVM）的平台上运行，而不需要重新编译。这使得 Java 成为一种具有很高可移植性的编程语言。</p>
</li>
<li><p><strong>动态执行：</strong> Java 字节码由 JVM 解释和执行。这意味着字节码可以在运行时动态加载和执行，而不需要在编译时确定所有细节。这种灵活性使得 Java 支持许多动态特性，如反射、动态代理等。</p>
</li>
</ol>
<h2 id="面向对象、面向过程"><a href="#面向对象、面向过程" class="headerlink" title="面向对象、面向过程"></a>面向对象、面向过程</h2><p><strong>面向对象：</strong><br>考虑一个图书馆管理系统，其中有图书、读者和图书管理员。在面向对象编程中，我们可以创建三个类：<code>Book</code>（图书类）、<code>Reader</code>（读者类）和<code>Librarian</code>（图书管理员类）。每个类都有自己的属性和方法。例如，<code>Book</code> 类可以有属性如书名、作者、出版日期等，以及方法如借阅和归还。通过创建这些类，我们可以创建图书对象、读者对象和图书管理员对象，并通过它们的交互来模拟图书馆管理系统。</p>
<p><strong>面向过程：</strong><br>考虑一个简单的计算器程序，它可以执行加法、减法、乘法和除法操作。在面向过程编程中，我们可以编写不同的函数来执行每个操作，例如 <code>add(a, b)</code>、<code>subtract(a, b)</code>、<code>multiply(a, b)</code> 和 <code>divide(a, b)</code>。然后，我们可以按照需要调用这些函数，以便完成计算器的功能。</p>
<p>面向对象编程将程序组织为对象的集合，强调对象之间的关系和交互。而面向过程编程将程序组织为一系列的步骤或过程，强调问题解决的步骤和顺序。</p>
<h1 id="内存溢出和内存泄漏的区别-8-28"><a href="#内存溢出和内存泄漏的区别-8-28" class="headerlink" title="内存溢出和内存泄漏的区别(8-28)"></a>内存溢出和内存泄漏的区别(8-28)</h1><blockquote>
<p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。<br>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>
</blockquote>
<blockquote>
<p>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。</p>
</blockquote>
<ol>
<li>常发性内存泄漏。发生内存泄漏的代码会被多次执行到，<code>每执行一次都会导致一块内存泄漏</code>。 </li>
<li>偶发性内存泄漏。发生内存泄漏的代码只有<code>在某些特定环境或操作过程下</code>才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以<code>测试环境</code>和测试方法对检测内存泄漏至关重要。 </li>
<li>一次性内存泄漏。<code>发生内存泄漏的代码只会被执行一次</code>，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 </li>
<li>隐式内存泄漏。<code>程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存</code>。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。</li>
</ol>
<p>自己的理解：溢出：空间不足。泄露：不去释放。</p>
<hr>
<h1 id="JDK1-7和JDK1-8的内存模型比较"><a href="#JDK1-7和JDK1-8的内存模型比较" class="headerlink" title="JDK1.7和JDK1.8的内存模型比较"></a>JDK1.7和JDK1.8的内存模型比较</h1><h1 id="java一日游"><a href="#java一日游" class="headerlink" title="java一日游"></a>java一日游</h1><p><a target="_blank" rel="noopener" href="http://t.csdn.cn/EMBz3">点我</a></p>
<h1 id="Hello-World-是如何运行的"><a href="#Hello-World-是如何运行的" class="headerlink" title="Hello World 是如何运行的"></a>Hello World 是如何运行的</h1><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1012907?areaId=106001">点我</a></p>
<h1 id="链接推荐"><a href="#链接推荐" class="headerlink" title="链接推荐"></a>链接推荐</h1><p><a target="_blank" rel="noopener" href="http://t.csdnimg.cn/ed69B">点我</a></p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>一种无锁算法，用于实现多线程环境下的原子操作</p>
<p>可能会有CPU空转情况，解决方法是：自适应自旋锁。</p>
<p>普通自旋锁是一直进行忙等待，自适应自旋锁是先空转到一定次数后，进行阻塞等待。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cwrisingblog.oss-cn-beijing.aliyuncs.com/blog/20231201192516.png"></p>
<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交</td>
<td align="center">可能</td>
<td align="center">可能</td>
<td>可能</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center">无</td>
<td align="center">可能</td>
<td>可能</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">无</td>
<td align="center">无</td>
<td>可能</td>
</tr>
<tr>
<td align="center">串行化</td>
<td align="center">无</td>
<td align="center">无</td>
<td>无</td>
</tr>
</tbody></table>
<ul>
<li><strong>脏读（Dirty Read）：</strong> 一个事务读取到另一个事务未提交的数据。</li>
<li><strong>不可重复读（Non-Repeatable Read）：</strong> 在同一事务中，两次读取到的数据不一致，通常是由于其他事务的更新导致的。</li>
<li><strong>幻读（Phantom Read）：</strong> 在同一事务中，两次查询的结果集不一致，通常是由于其他事务的插入或删除导致的。</li>
</ul>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cwrisingblog.oss-cn-beijing.aliyuncs.com/blog/20231201194728.png"></p>
<p>跳表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cwrisingblog.oss-cn-beijing.aliyuncs.com/blog/20231201195349.png"></p>
<p><a target="_blank" rel="noopener" href="http://t.csdnimg.cn/GABAu">这个</a></p>
<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>在 MySQL 中，索引是一种用于提高数据库查询性能的数据结构。它类似于书籍的目录，允许数据库系统快速地定位并访问特定行的数据，而不必扫描整个表。通过使用索引，可以显著加速数据的检索和查询操作。</p>
<ol>
<li><p><strong>主键索引（Primary Key Index）：</strong> 主键是一列或一组列，其值用于唯一标识表中的每一行。MySQL 自动为主键创建索引，确保表中的每一行都可以快速被唯一标识。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>唯一索引（Unique Index）：</strong> 类似于主键索引，但允许有空值，确保列中的值在整个表中是唯一的。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table (</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>普通索引（Normal Index）：</strong> 基本的索引类型，用于加速检索操作。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table (</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    INDEX idx_age (age)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>全文索引（Full-Text Index）：</strong> 用于全文搜索，通常在包含文本数据的列上创建，以提高搜索效率。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_table (</span><br><span class="line">    text_column TEXT,</span><br><span class="line">    FULLTEXT INDEX idx_text (text_column)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul>
<li>破坏互斥条件：把只能互斥使用的资源改成允许共享使用的资源，例如spooLing技术，将独占设备在逻辑上改造成共享设备</li>
<li>破坏不可剥夺条件：当某个进程请求新资源无法得到满足时，就立即释放保持的所有资源，待以后需要再重新申请</li>
<li>破坏请求和保持条件：非阻塞加锁，加不上锁则释放已有的锁。采用静态分配方法，即进程在运行前一次申请完它所需要的的资源，在它资源未满足前，不让他运行，一旦运行，这些资源都归它所有，此时不会在请求其他资源</li>
<li>破坏循环等待条件：保证加锁解锁顺序一致。采用顺序资源分配法，首先给系统中的资源进行编号，规定进程必须按编号递增的顺序请求资源。例如一个进程只有已占有小编号资源时，才可以申请更大编号的资源</li>
</ul>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cwrisingblog.oss-cn-beijing.aliyuncs.com/blog/20231203233602.png">



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cwrisingblog.oss-cn-beijing.aliyuncs.com/blog/20231203233727.png">





<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>在Java中，<code>HashMap</code>、<code>TreeMap</code>和<code>LinkedHashMap</code>是<code>Map</code>接口的不同实现，它们之间有一些关键的差异，主要涉及到存储顺序、性能特征和适用场景。</p>
<h3 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h3><ul>
<li><p><strong>存储顺序：</strong> <code>HashMap</code> 不保证存储顺序，元素的存储顺序是由键的哈希码（<code>hashCode</code>）决定的。</p>
</li>
<li><p><strong>性能特征：</strong> <code>HashMap</code> 具有良好的性能，常数时间复杂度的查找、插入和删除操作。</p>
</li>
<li><p><strong>适用场景：</strong> 适用于大多数情况，不要求有序性，对性能要求较高。</p>
</li>
</ul>
<h3 id="2-TreeMap"><a href="#2-TreeMap" class="headerlink" title="2. TreeMap"></a>2. TreeMap</h3><ul>
<li><p><strong>存储顺序：</strong> <code>TreeMap</code> 会对键进行排序，可以按照键的自然顺序或者通过自定义比较器进行排序。</p>
</li>
<li><p><strong>性能特征：</strong> <code>TreeMap</code> 的性能相对较差，因为它维护了一棵红黑树，查找、插入和删除的时间复杂度为对数级别。</p>
</li>
<li><p><strong>适用场景：</strong> 适用于需要有序键值对的情况，对有序性要求较高。</p>
</li>
</ul>
<h3 id="3-LinkedHashMap"><a href="#3-LinkedHashMap" class="headerlink" title="3. LinkedHashMap"></a>3. LinkedHashMap</h3><ul>
<li><p><strong>存储顺序：</strong> <code>LinkedHashMap</code> 会保留元素插入的顺序，即按照元素插入的顺序来维护键值对的顺序。</p>
</li>
<li><p><strong>性能特征：</strong> <code>LinkedHashMap</code> 的性能较好，查找、插入和删除的时间复杂度为常数级别，略低于 <code>HashMap</code>。</p>
</li>
<li><p><strong>适用场景：</strong> 适用于需要有序性，且希望保留元素插入顺序的情况。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>使用 <code>HashMap</code> 适用于大多数情况，无序性、性能要求较高。</li>
<li>使用 <code>TreeMap</code> 适用于需要有序键值对，对有序性要求较高的情况。</li>
<li>使用 <code>LinkedHashMap</code> 适用于需要有序性，且希望保留元素插入顺序的情况，性能介于 <code>HashMap</code> 和 <code>TreeMap</code> 之间。</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cwrisingblog.oss-cn-beijing.aliyuncs.com/ustl_acm/20231204220518.png">



<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cwrisingblog.oss-cn-beijing.aliyuncs.com/blog/20231220213644.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cwrisingblog.oss-cn-beijing.aliyuncs.com/blog/20231220213706.png"></p>
<p><a target="_blank" rel="noopener" href="http://t.csdnimg.cn/iojbo">JVM-csdn</a></p>
<h1 id="synchronized、volatile-、-Lock"><a href="#synchronized、volatile-、-Lock" class="headerlink" title="synchronized、volatile 、 Lock"></a><code>synchronized</code>、<code>volatile</code> 、 <code>Lock</code></h1><p><code>synchronized</code>、<code>volatile</code> 和 <code>Lock</code> 都是 Java 中用于处理多线程同步的机制，但它们在实现方式、应用场景和使用方法上有一些区别。</p>
<h3 id="1-synchronized（同步方法、同步块）"><a href="#1-synchronized（同步方法、同步块）" class="headerlink" title="1. synchronized（同步方法、同步块）"></a>1. <code>synchronized</code>（同步方法、同步块）</h3><h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><p><code>synchronized</code> 是 Java 中最基本的同步机制，可以用于方法和代码块。它依赖于对象的内部锁（Intrinsic Lock）或者称为监视器锁（Monitor Lock）。</p>
<h4 id="区别与注意事项："><a href="#区别与注意事项：" class="headerlink" title="区别与注意事项："></a>区别与注意事项：</h4><ul>
<li><code>synchronized</code> 依赖于对象锁，当线程获得锁时，其他线程会被阻塞。</li>
<li>一个线程在执行同步代码块时，其他线程不能执行相同对象的其他同步代码块，但可以执行该对象的非同步代码块。</li>
</ul>
<h3 id="2-volatile"><a href="#2-volatile" class="headerlink" title="2. volatile"></a>2. <code>volatile</code></h3><h4 id="实现方式：-1"><a href="#实现方式：-1" class="headerlink" title="实现方式："></a>实现方式：</h4><p><code>volatile</code> 是一种轻量级的同步机制，它保证了变量的可见性和禁止指令重排序。</p>
<h4 id="区别与注意事项：-1"><a href="#区别与注意事项：-1" class="headerlink" title="区别与注意事项："></a>区别与注意事项：</h4><ul>
<li><code>volatile</code> 用于保证多个线程能够正确处理共享变量。</li>
<li>它不具备原子性，不适合替代 <code>synchronized</code> 来进行复合操作。</li>
</ul>
<h3 id="3-Lock（ReentrantLock）"><a href="#3-Lock（ReentrantLock）" class="headerlink" title="3. Lock（ReentrantLock）"></a>3. <code>Lock</code>（ReentrantLock）</h3><h4 id="实现方式：-2"><a href="#实现方式：-2" class="headerlink" title="实现方式："></a>实现方式：</h4><p><code>Lock</code> 是 Java 中的显式锁，它提供了更灵活的线程同步方式，支持可重入锁。</p>
<h4 id="区别与注意事项：-2"><a href="#区别与注意事项：-2" class="headerlink" title="区别与注意事项："></a>区别与注意事项：</h4><ul>
<li><code>Lock</code> 提供了更灵活的同步控制，支持公平锁和非公平锁。</li>
<li>在使用 <code>Lock</code> 时，需要手动释放锁，通常使用 <code>try-finally</code> 块确保锁的释放。</li>
</ul>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ul>
<li>使用 <code>synchronized</code> 适用于简单的同步需求，例如方法或代码块的同步。</li>
<li>使用 <code>volatile</code> 适用于变量的简单读写操作，且变量的值不依赖于当前值。</li>
<li>使用 <code>Lock</code> 适用于需要更灵活控制的场景，例如支持公平性、锁的中断等。</li>
</ul>
<p>在实际应用中，选择合适的同步机制取决于具体的需求和性能考虑。一般情况下，推荐使用 <code>synchronized</code> 和 <code>volatile</code>，而在更复杂的情况下，可以考虑使用 <code>Lock</code>。</p>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><h3 id="1-继承-Thread-类："><a href="#1-继承-Thread-类：" class="headerlink" title="1. 继承 Thread 类："></a>1. 继承 <code>Thread</code> 类：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Thread is running"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-实现-Runnable-接口："><a href="#2-实现-Runnable-接口：" class="headerlink" title="2. 实现 Runnable 接口："></a>2. 实现 <code>Runnable</code> 接口：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Runnable is running"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        myThread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-使用匿名内部类："><a href="#3-使用匿名内部类：" class="headerlink" title="3. 使用匿名内部类："></a>3. 使用匿名内部类：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Anonymous Runnable is running"</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousRunnableExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">        myThread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-使用-Callable-和-Future："><a href="#4-使用-Callable-和-Future：" class="headerlink" title="4. 使用 Callable 和 Future："></a>4. 使用 <code>Callable</code> 和 <code>Future</code>：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Callable is running"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-使用线程池："><a href="#5-使用线程池：" class="headerlink" title="5. 使用线程池："></a>5. 使用线程池：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Task is running"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="Get与Post"><a href="#Get与Post" class="headerlink" title="Get与Post"></a>Get与Post</h1><h2 id="1-数据传递方式："><a href="#1-数据传递方式：" class="headerlink" title="1. 数据传递方式："></a>1. 数据传递方式：</h2><ul>
<li><p><strong>GET：</strong></p>
<ul>
<li>数据附在 URL 后面，以查询字符串的形式传递。</li>
<li>有长度限制，由浏览器和服务器的限制决定，一般在 2KB 到 8KB 之间。</li>
<li>数据在 URL 中可见，安全性较低。</li>
<li>适用于无副作用的幂等请求，比如搜索。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://example.com/path?param1=value1&amp;param2=value2</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>POST：</strong></p>
<ul>
<li>数据附在请求体中，对应于 HTTP 报文的消息体。</li>
<li>没有明确长度限制，由服务器和客户端的配置决定，通常支持较大的数据传输。</li>
<li>数据不在 URL 中可见，安全性相对较高。</li>
<li>适用于有副作用的请求，比如表单提交。</li>
</ul>
</li>
</ul>
<h2 id="2-安全性："><a href="#2-安全性：" class="headerlink" title="2. 安全性："></a>2. 安全性：</h2><ul>
<li><p><strong>GET：</strong></p>
<ul>
<li>因为数据附在 URL 中，对于敏感信息不够安全，例如密码。</li>
<li>浏览器会缓存发送过的 URL，因此可能会被浏览器历史记录、代理服务器等记录。</li>
</ul>
</li>
<li><p><strong>POST：</strong></p>
<ul>
<li>数据在请求体中，相对安全，适用于传输敏感信息。</li>
<li>不会被浏览器缓存。</li>
</ul>
</li>
</ul>
<h2 id="3-幂等性："><a href="#3-幂等性：" class="headerlink" title="3. 幂等性："></a>3. 幂等性：</h2><ul>
<li><p><strong>GET：</strong></p>
<ul>
<li>幂等，多次执行不会产生不同的结果，不会改变服务器状态。</li>
</ul>
</li>
<li><p><strong>POST：</strong></p>
<ul>
<li>不一定幂等，因为可能引起服务器状态的改变，比如向数据库插入数据。</li>
</ul>
</li>
</ul>
<h2 id="4-可见性："><a href="#4-可见性：" class="headerlink" title="4. 可见性："></a>4. 可见性：</h2><ul>
<li><p><strong>GET：</strong></p>
<ul>
<li>数据在 URL 中可见，适合用于传递非敏感信息。</li>
</ul>
</li>
<li><p><strong>POST：</strong></p>
<ul>
<li>数据在请求体中，相对安全，适用于传递敏感信息。</li>
</ul>
</li>
</ul>
<h2 id="5-缓存："><a href="#5-缓存：" class="headerlink" title="5. 缓存："></a>5. 缓存：</h2><ul>
<li><p><strong>GET：</strong></p>
<ul>
<li>可以被浏览器缓存，可以被书签保存。</li>
</ul>
</li>
<li><p><strong>POST：</strong></p>
<ul>
<li>一般不被浏览器缓存，不适合保存为书签。</li>
</ul>
</li>
</ul>
<h2 id="6-使用场景："><a href="#6-使用场景：" class="headerlink" title="6. 使用场景："></a>6. 使用场景：</h2><ul>
<li><p><strong>GET：</strong></p>
<ul>
<li>用于请求数据，对服务器没有副作用。</li>
<li>用于 idempotent 操作。</li>
</ul>
</li>
<li><p><strong>POST：</strong></p>
<ul>
<li>用于提交表单数据，上传文件等可能引起服务器状态改变的操作。</li>
<li>不一定要求 idempotent 操作。</li>
</ul>
</li>
</ul>
<h3 id="Git-merge-vs-Git-rebase"><a href="#Git-merge-vs-Git-rebase" class="headerlink" title="Git merge vs. Git rebase"></a>Git merge vs. Git rebase</h3><p>What are the differences?</p>
<p>
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cwrisingblog.oss-cn-beijing.aliyuncs.com/blog/git-merge-git-rebase.jpeg" style="width: 680px">
</p>


<h1 id="手写LRU"><a href="#手写LRU" class="headerlink" title="手写LRU"></a>手写LRU</h1><p>题目描述<br>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。</p>
<p><code>最近用过的放在前边，放不下了删后边。（get put操作都算用过）</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 解法二： 需要自己实现双向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> {</span><br><span class="line">    <span class="comment">// 定义双向链表节点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> {</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode pre;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> {}</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key,<span class="type">int</span> _val)</span> {</span><br><span class="line">            key = _key;</span><br><span class="line">            value = _val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 定义hashMap</span></span><br><span class="line">    Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,DLinkedNode&gt;();</span><br><span class="line">    <span class="comment">// 定义双向链表头结点 尾结点</span></span><br><span class="line">    DLinkedNode head,tail;</span><br><span class="line">    <span class="comment">// 定义缓冲区容量</span></span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">// 定义当前缓冲区大小</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span>{</span><br><span class="line">    	<span class="comment">// 记录当前大小</span></span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录总的容量</span></span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 定义伪头部和尾部</span></span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        <span class="comment">// 连接成双链表的形式</span></span><br><span class="line">        tail.pre = head;</span><br><span class="line">        head.next = tail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span>{</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 没有就返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 使用了就移到最前边</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="comment">// 返回get到的值</span></span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> {</span><br><span class="line">    	<span class="comment">// 先看原来有没有</span></span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 当前插入节点不存在</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 新建节点</span></span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key,value);</span><br><span class="line">            <span class="comment">// 加入缓冲区</span></span><br><span class="line">            cache.put(key,node);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="comment">// 添加到双链表的头部</span></span><br><span class="line">            addToHead(node);</span><br><span class="line">            <span class="comment">// 超出容量删除尾结点(两处 一处双向链表的一处hasmap)</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) {</span><br><span class="line">            	<span class="comment">// 删hashmap</span></span><br><span class="line">                cache.remove(tail.pre.key);</span><br><span class="line">                <span class="comment">// 删双链表的</span></span><br><span class="line">                removeNode(tail.pre);</span><br><span class="line">                <span class="comment">// 删完改变size</span></span><br><span class="line">                size--;<span class="comment">//很容易忘！！</span></span><br><span class="line">            }</span><br><span class="line">        <span class="comment">// 当前节点存在</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 更改节点的值</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="comment">// 将节点移动到双链表头部</span></span><br><span class="line">            moveToHead(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> {</span><br><span class="line">        <span class="comment">// 先连后，再连前</span></span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        node.next = head.next; </span><br><span class="line">        head.next = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> {</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> {</span><br><span class="line">        <span class="comment">// 先remove掉原来的，再加新的</span></span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>





<h1 id="Java面试题复习总结（自用）"><a href="#Java面试题复习总结（自用）" class="headerlink" title="Java面试题复习总结（自用）"></a>Java面试题复习总结（自用）</h1><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h1><h2 id="线程池："><a href="#线程池：" class="headerlink" title="线程池："></a>线程池：</h2><ol>
<li>为什么使用线程池？</li>
<li>说一下创建线程池时的核心参数和线程池执行原理？</li>
<li>线程池的拒绝策略有哪些？</li>
<li>常用的阻塞队列有哪些？</li>
<li>ArrayBlockingQueue和LinkedBlockingQueue的区别？</li>
<li>阻塞队列的作用？</li>
<li>为什么不先创建救急线程而是先把任务添加到阻塞队列中？</li>
<li>具体说说常见的线程池种类？</li>
<li>如何确定核心线程数和最大线程数？</li>
</ol>
<h2 id="线程基础："><a href="#线程基础：" class="headerlink" title="线程基础："></a>线程基础：</h2><ol>
<li>线程与进程的区别是什么？</li>
<li>谈一谈守护线程？</li>
<li>创建线程的方式有哪些？</li>
<li>实现Callable接口和Runnable接口都可以创建线程，二者的区别是什么？</li>
<li>线程的start()和run()方法的区别？</li>
<li>线程有哪些状态，这些状态之间是如何切换的？</li>
<li>wait()、sleep()、yield()和join()方法之间的区别？</li>
<li>notify()和notifyAll()方法的对比？</li>
<li>如何保证多个线程之间的执行顺序？</li>
<li>如何终止一个正在运行中的线程？</li>
<li>ThreadLocal的实现原理？</li>
<li>ThreadLocal是如何导致内存泄漏的？</li>
<li>如何防止ThreadLocal内存泄漏？</li>
</ol>
<h2 id="并发安全："><a href="#并发安全：" class="headerlink" title="并发安全："></a>并发安全：</h2><ol>
<li>讲一下Java内存模型？</li>
<li>谈谈你对线程安全问题的理解？</li>
<li>Java是如何保证多线程的执行安全？</li>
<li>Synchronized关键字的底层原理？</li>
<li>锁机制是如何升级的？</li>
<li>Synchronized和Lock的区别？</li>
<li>谈一谈你对volatile关键字的理解？</li>
<li>Synchronized和volatile关键字的区别？</li>
<li>谈一谈AQS？</li>
<li>了解CAS吗？</li>
<li>讲一下乐观锁和悲观锁？</li>
<li>ReentranLock的实现原理是什么？</li>
<li>ReentranLock和Synchronized的区别？</li>
<li>聊一下ConcurrentHashMap？</li>
</ol>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><strong>Spring</strong></h1><ol>
<li>什么是Spring框架？</li>
<li>Spring框架的优势是什么？</li>
<li>Spring框架中用到了哪些设计模式？</li>
<li>解释一下Bean的生命周期？</li>
<li>BeanFactory和ApplicationContext的区别？</li>
<li>解释一下Spring支持的几种Bean的作用域？</li>
<li>Spring框架中的单例Bean是线程安全的吗？</li>
<li>什么是Bean的自动装配？有哪些方式？</li>
<li>解释Spring中的循环引用？</li>
<li>构造函数中的循环依赖怎么解决？</li>
<li>谈谈你对IOC的理解？</li>
<li>如何实现一个IOC容器？</li>
<li>什么是AOP？</li>
<li>Spring中事务是如何实现的？</li>
<li>声明式事务的原理是什么？</li>
<li>Spring中事务的隔离级别？</li>
<li>Spring中事务的传播机制？</li>
<li>Spring中事务失效的场景有哪些？解决方法？</li>
<li>@Autowired和@Resource的区别？</li>
</ol>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a><strong>SpringMVC</strong></h1><ol>
<li>SpringMVC的执行流程了解吗？</li>
</ol>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a><strong>SpringBoot</strong></h1><ol>
<li>Spring、SpringMVC、SpringBoot有什么区别？</li>
<li>如何理解SpringBoot中的starter？</li>
<li>讲一讲SpringBoot中的自动配置？</li>
</ol>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><ol>
<li>MyBatis是什么？</li>
<li>MyBatis框架的优缺点？</li>
<li>ORM是什么？</li>
<li>#{}和${}的区别是什么？</li>
<li>MyBatis执行流程/工作原理是什么？</li>
<li>MyBatis是否支持延迟加载？</li>
<li>延迟加载的底层原理是什么？</li>
<li>MyBatis的一级、二级缓存使用过吗？</li>
<li>二级缓存什么时候会清理缓存中的数据？</li>
</ol>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h2><ol>
<li>介绍一下事务的四大特性？</li>
<li>并发事务会带来哪些问题？</li>
<li>如何解决并发事务带来的问题/事务的隔离级别有哪些？</li>
<li>可重复读和幻读的区别？</li>
<li>事务的ACID靠什么保证？</li>
<li>事务的三大日志是什么？作用？</li>
<li>bin log 和 redo log的区别？</li>
<li>undo log 和 redo log的区别？</li>
<li>什么是MVCC？实现原理是什么？</li>
</ol>
<h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h2><h2 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h2><ol>
<li>MySQL主从同步是如何实现的？</li>
</ol>
<p><strong>1.什么是缓存，它在高并发系统中起什么作用？</strong></p>
<p>缓存是一种硬件或软件的组件，它存储数据，以便在将来的请求中，如果同样的数据被请求，可以更快地提供数据。在高并发系统中，缓存可以显著提高数据读取的速度，减少对原始数据源（例如数据库）的访问，从而降低系统的响应时间，并提高系统的吞吐量。对于高访问频率和相对静态的数据，将其存储在缓存中可以减少对后端服务器的负载，提高系统的性能和可伸缩性。同时，缓存也可以作为一种缓冲机制，帮助系统应对突然的流量峰值，防止后端服务器被过载。</p>
<p><strong>2.如何选择适合高并发场景的缓存策略？</strong></p>
<p>选择适合高并发场景的缓存策略通常需要考虑以下几个因素：</p>
<ul>
<li>数据的访问模式： 如果数据的访问模式是读多写少，且数据更新不频繁，那么使用缓存可以大幅度提高系统的性能。如果数据更新非常频繁，那么缓存的效果可能就不明显。</li>
<li>数据的一致性需求： 如果系统对数据的一致性要求非常高，需要考虑如何在更新原始数据的同时更新缓存，以保证数据的一致性。</li>
<li>缓存的大小和数据的大小： 缓存的大小必须足够大，以便存储高访问频率的数据。同时，需要考虑数据的大小，如果单个数据项非常大，那么可能需要使用特殊的缓存策略，如对象缓存。</li>
<li>缓存的失效策略： 常见的缓存失效策略有LRU（最近最少使用）、FIFO（先进先出）等。选择何种失效策略取决于具体的数据访问模式。</li>
<li>分布式缓存： 对于大规模的高并发系统，可能需要使用分布式缓存，如Redis或Memcached，以提高系统的可扩展性。</li>
</ul>
<p><strong>3.如何解决缓存系统中的热点数据问题？</strong></p>
<p>“热点数据”是指在一段时间内被频繁访问的数据。在高并发环境下，大量请求同时访问热点数据可能会导致缓存服务器的压力增大，甚至可能导致缓存服务的瘫痪。以下是一些解决策略：</p>
<ul>
<li>缓存预热： 在系统启动时，主动将可能成为热点的数据加载到缓存中，这样可以避免大量请求同时对数据库发起查询。</li>
<li>数据复制： 对于热点数据，可以在缓存层面进行数据复制，即将热点数据复制到多个缓存节点中，分散访问压力。</li>
<li>一致性哈希： 通过一致性哈希算法，可以将请求均匀地分散到多个缓存节点上，减轻单个节点的压力。</li>
<li>限流： 对于访问特别频繁的热点数据，可以通过限流控制请求的频率，保证系统的稳定性。</li>
<li>熔断降级： 设定系统的阈值，当访问量或者错误率超过一定的阈值时，启动熔断机制，暂时停止服务，或者提供降级服务，防止系统因为访问热点数据的请求过多而崩溃。</li>
</ul>
<p><strong>4.缓存穿透、缓存击穿和缓存雪崩的区别是什么，如何预防它们？</strong></p>
<ul>
<li>缓存穿透是指用户不断请求缓存和数据库中都不存在的数据，导致所有的请求都直接打到数据库上，从而可能导致数据库压力过大。预防方法包括：对用户输入的查询条件进行校验；对查询结果为空的情况也进行缓存，但设置较短的过期时间。</li>
<li>缓存击穿是指一个热点数据的缓存突然失效（比如过期），导致大量的请求直接打到数据库上。预防方法包括：对热点数据设置永不过期；使用互斥锁或者队列，保证对数据库的访问只有一个线程在进行。</li>
<li>缓存雪崩是指在缓存系统中，大量的数据突然在同一时间点失效，导致大量的请求都直接打到数据库上。预防方法包括：对缓存的过期时间进行随机化，避免大量数据同时过期；使用多级缓存，或者容错备份方法；服务降级，即在缓存失效时，让用户访问备份数据或者返回简化的内容。</li>
</ul>
<p><strong>5.如何保证缓存数据的一致性？</strong></p>
<p>在使用缓存的系统中，保持缓存数据和数据库数据的一致性是一个重要，也是相当复杂的问题。以下是一些常用的策略：</p>
<ul>
<li><strong>读写穿透</strong>： 所有的写操作都直接对数据库进行，并且在写入数据库后，立即从数据库读取数据更新缓存。这种方式可以保证缓存数据的一致性，但可能会增加数据库的压力。</li>
<li><strong>延时双删</strong>： 在更新数据库后，延时一段时间（比如几百毫秒），然后删除缓存。这种方式可以在大部分情况下保证数据的一致性，但在高并发情况下可能会有问题。</li>
<li><strong>消息队列</strong>： 使用消息队列，将更新操作作为消息发送到队列，然后由单独的线程或进程进行处理。这种方式可以序列化更新操作，避免并发更新导致的一致性问题。</li>
<li>版本号（或时间戳）机制： 为每个数据项添加版本号或时间戳，只有当缓存中的版本号和数据库中的版本号一致时，才更新缓存。这种方式可以有效防止旧数据覆盖新数据，从而保证数据的一致性。</li>
</ul>
<p><strong>6.分布式缓存系统有哪些常见的实现，如Redis，Memcached等，它们的优缺点是什么？</strong></p>
<p>以下是两种常见的分布式缓存系统，以及它们各自的优缺点：</p>
<ul>
<li><strong>Redis</strong>：优点：Redis 是一个开源的，基于内存的键值存储系统。它支持多种数据结构，如字符串，哈希，列表，集合，有序集合等。此外，Redis 还支持数据持久化，可以将内存中的数据保存在磁盘中，重启后可以再次加载到内存中。Redis 还支持分布式，可以实现主从同步，分片等功能。缺点：虽然 Redis 支持数据持久化，但是如果数据非常重要，且不能接受数据丢失，那么可能需要考虑其他持久化的存储系统。同时，虽然 Redis 支持分布式，但是其分片和一致性方面的功能不如一些专门的分布式系统强大。</li>
<li><strong>Memcached</strong>：优点：Memcached 是一个开源的，高性能的，分布式内存对象缓存系统。它简单易用，使用广泛，有丰富的客户端库支持。Memcached 非常适合用于缓存数据库查询结果，页面渲染结果等。缺点：Memcached 的数据模型比较简单，只支持简单的键值对，并且不支持数据持久化。如果需要复杂的数据结构或者数据持久化，那么可能需要考虑其他缓存系统。</li>
</ul>
<p><strong>7.为什么在高并发环境下，数据库需要配合缓存来使用？</strong></p>
<p>在高并发环境下，如果所有的请求都直接访问数据库，可能会使数据库的负载过大，影响数据库的性能，甚至导致数据库崩溃。在这种情况下，使用缓存是一种有效的方式来提高系统性能，减轻数据库负载：</p>
<ul>
<li>减少数据库压力： 缓存可以把一部分读请求从数据库转移到内存，从而减轻数据库的压力。对于读多写少的系统，通过合理的缓存策略，大部分的读请求可以直接在缓存中得到满足，极大地减少了数据库的访问压力。</li>
<li>提高系统响应速度： 访问内存的速度要远高于访问磁盘（数据库通常存储在磁盘上）的速度。因此，缓存可以显著提高系统的响应速度，提高用户体验。</li>
<li>缓冲数据库峰值访问： 在高并发场景下，流量可能会有突发的峰值。缓存可以作为一个缓冲层，吸收峰值流量，保护数据库不会被突然的流量冲垮。</li>
<li>减少网络带宽： 缓存一般部署在与应用服务器相同或者网络距离较近的地方，通过缓存，可以减少对数据库的远程访问，从而节省网络带宽。</li>
</ul>
<p><strong>8.在高并发系统中，如何有效地更新缓存？</strong></p>
<p>在高并发系统中，有效地更新缓存是一个挑战，因为你需要在保持数据一致性和提高性能之间找到平衡。以下是一些常用的策略：</p>
<ul>
<li>懒惰更新或者延迟更新： 当数据发生改变时，不立即更新缓存，而是在下次获取数据时，从数据库获取最新的数据，并更新缓存。这种方法简单易实现，但可能导致数据不一致。</li>
<li>立即更新或者同步更新： 当数据发生改变时，立即更新缓存。这种方法可以保持数据的一致性，但可能会影响性能，因为每次数据更新都需要同时更新数据库和缓存。</li>
<li>设置适当的缓存过期时间： 为缓存设置一个过期时间，当缓存过期时，再从数据库获取最新的数据。这种方法可以在一定程度上平衡数据一致性和性能。</li>
<li>使用消息队列： 当数据发生改变时，将更新操作发送到消息队列，然后由一个专门的线程或者进程从队列中取出操作并更新缓存。这种方法可以将更新操作异步化，提高性能。</li>
<li>使用读写分离和数据库主从同步： 将写操作直接发送到数据库，读操作从缓存中获取。当数据库中的数据发生改变时，通过数据库主从同步更新缓存。这种方法需要数据库支持主从同步，实现较为复杂。</li>
</ul>
<p><strong>9.为什么在高并发系统中，我们通常推荐使用分布式缓存而不是本地缓存？</strong></p>
<p>在高并发系统中，我们通常推荐使用分布式缓存而不是本地缓存，主要基于以下几个原因：</p>
<ul>
<li>可伸缩性： 分布式缓存由多个节点组成，可以通过增加节点来提高整体的存储容量和处理能力。这与单机的本地缓存形成对比，本地缓存的容量和性能受到单台机器的硬件限制。</li>
<li>数据一致性： 在分布式环境中，多个应用实例可能需要访问和修改同一份数据。如果使用本地缓存，每个应用实例只能看到自己的缓存，无法看到其他实例的缓存，这可能导致数据不一致。分布式缓存可以提供一致的数据视图，所有的应用实例共享同一份缓存数据。</li>
<li>高可用性： 分布式缓存通常可以提供数据复制和故障转移的机制，当某个缓存节点出现故障时，可以自动切换到其他健康的节点，提供持续的服务。而本地缓存通常无法提供这样的机制。</li>
<li>网络延迟： 本地缓存由于在本地，访问延迟低。但在微服务架构下，服务实例可能分布在不同的网络节点，如果频繁访问远程的数据库，网络延迟可能会成为瓶颈。使用分布式缓存，可以将数据近距离存储在服务实例附近，减少网络延迟。</li>
</ul>
<p>总的来说，在高并发和大规模的系统中，分布式缓存通常比本地缓存更具优势。但是，这并不意味着本地缓存没有用武之地，对于某些特定的场景，如数据局部性强，或者对延迟要求极高的场景，本地缓存可能是更好的选择。</p>
<p><strong>10.在使用缓存改善高并发系统的性能时，有哪些常见的最佳实践？</strong></p>
<p>选择合适的缓存策略：不同的缓存策略适用于不同的场景。例如，LRU（最近最少使用）策略适用于那些最近访问过的数据可能再次被访问的场景，而LFU（最少使用）策略适用于一些访问频率较高的数据。</p>
<p>缓存数据的过期和清理：设置合理的过期时间可以防止缓存中的数据过时。此外，定期清理缓存中的无用数据也是一个好习惯。</p>
<p>分布式缓存：在高并发系统中，单点缓存可能会成为瓶颈。使用分布式缓存（比如Redis、Memcached）可以提高缓存系统的吞吐量和可用性。</p>
<p>一致性哈希：一致性哈希是一种特殊的哈希技术，常常与分布式缓存一起使用，以减少节点增加或减少时对系统的影响。</p>
<p>缓存穿透、击穿和雪崩的防护：这些都是缓存系统中常见的问题，需要通过各种策略进行防护。比如，对于缓存穿透，可以使用布隆过滤器；对于缓存击穿，可以使用互斥锁；对于缓存雪崩，可以使用多级缓存、设置不同的过期时间等。</p>
<p>读写策略：缓存的读写策略（如：Read/Write through, Read/Write around, Read/Write back）也需要根据具体的业务需求来选择。</p>
<p>监控和日志：对缓存的命中率、响应时间等关键指标进行监控，可以帮助系统管理员及时发现并处理问题。同时，保持良好的日志记录也可以帮助分析和解决问题。</p>
<p>测试：在推出任何缓存策略之前，都应该进行充分的测试，包括但不限于性能测试和压力测试，确保缓存策略能够在实际环境中有效工作。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://risingrode.github.io">fcw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://risingrode.github.io/post/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95-%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93.html">https://risingrode.github.io/post/面试/面试-自己总结.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://risingrode.github.io" target="_blank">代码有点萌</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9/">面试高频考点</a></div><div class="post_share"><div class="social-share" data-image="https://i0.hippopx.com/photos/997/702/475/road-train-landscape-storm-thumb.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/%E6%AF%94%E8%B5%9B/2023%E5%9B%BD%E8%B5%9B.html" title="2023国赛"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2023国赛</div></div></a></div><div class="next-post pull-right"><a href="/post/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/gulimall-es.html" title="谷粒商城-es篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/583/885/292/tianjin-twilight-city-scenery-preview.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">谷粒商城-es篇</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/girl.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">fcw</div><div class="author-info__description">一个收藏回忆与分享技术的地方！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Risingrode"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到cwRising的博客</div></div><div class="card-widget"><div class="item-headline"><i></i><span></span></div><div class="item-content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9JVM%E7%9A%84%E7%90%86%E8%A7%A3-8-24"><span class="toc-number">2.</span> <span class="toc-text">对JVM的理解(8-24)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E5%8C%85%E6%8B%AC%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">JDK包括什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%8C%85%E6%8B%AC%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.</span> <span class="toc-text">JVM包括什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">2.2.1.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">2.2.2.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%A0%86"><span class="toc-number">2.2.4.</span> <span class="toc-text">Java 堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">2.2.5.</span> <span class="toc-text">虚拟机栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%96%E8%AF%91%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">为什么编译成字节码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">面向对象、面向过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB-8-28"><span class="toc-number">3.</span> <span class="toc-text">内存溢出和内存泄漏的区别(8-28)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-7%E5%92%8CJDK1-8%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="toc-number">4.</span> <span class="toc-text">JDK1.7和JDK1.8的内存模型比较</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E4%B8%80%E6%97%A5%E6%B8%B8"><span class="toc-number">5.</span> <span class="toc-text">java一日游</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hello-World-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84"><span class="toc-number">6.</span> <span class="toc-text">Hello World 是如何运行的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%8E%A8%E8%8D%90"><span class="toc-number">7.</span> <span class="toc-text">链接推荐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS"><span class="toc-number">8.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">9.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">11.</span> <span class="toc-text">Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95"><span class="toc-number">12.</span> <span class="toc-text">MySQL索引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">13.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">14.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map"><span class="toc-number">15.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HashMap"><span class="toc-number">15.0.1.</span> <span class="toc-text">1. HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TreeMap"><span class="toc-number">15.0.2.</span> <span class="toc-text">2. TreeMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LinkedHashMap"><span class="toc-number">15.0.3.</span> <span class="toc-text">3. LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">15.0.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">16.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">16.1.</span> <span class="toc-text">java内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3"><span class="toc-number">16.2.</span> <span class="toc-text">详解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized%E3%80%81volatile-%E3%80%81-Lock"><span class="toc-number">17.</span> <span class="toc-text">synchronized、volatile 、 Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-synchronized%EF%BC%88%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E3%80%81%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%89"><span class="toc-number">17.0.1.</span> <span class="toc-text">1. synchronized（同步方法、同步块）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">17.0.1.1.</span> <span class="toc-text">实现方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">17.0.1.2.</span> <span class="toc-text">区别与注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-volatile"><span class="toc-number">17.0.2.</span> <span class="toc-text">2. volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A-1"><span class="toc-number">17.0.2.1.</span> <span class="toc-text">实现方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-1"><span class="toc-number">17.0.2.2.</span> <span class="toc-text">区别与注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Lock%EF%BC%88ReentrantLock%EF%BC%89"><span class="toc-number">17.0.3.</span> <span class="toc-text">3. Lock（ReentrantLock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A-2"><span class="toc-number">17.0.3.1.</span> <span class="toc-text">实现方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-2"><span class="toc-number">17.0.3.2.</span> <span class="toc-text">区别与注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">17.0.4.</span> <span class="toc-text">应用场景：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">18.</span> <span class="toc-text">创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB%EF%BC%9A"><span class="toc-number">18.0.1.</span> <span class="toc-text">1. 继承 Thread 类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">18.0.2.</span> <span class="toc-text">2. 实现 Runnable 接口：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9A"><span class="toc-number">18.0.3.</span> <span class="toc-text">3. 使用匿名内部类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-Callable-%E5%92%8C-Future%EF%BC%9A"><span class="toc-number">18.0.4.</span> <span class="toc-text">4. 使用 Callable 和 Future：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A"><span class="toc-number">18.0.5.</span> <span class="toc-text">5. 使用线程池：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Get%E4%B8%8EPost"><span class="toc-number">19.</span> <span class="toc-text">Get与Post</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">19.1.</span> <span class="toc-text">1. 数据传递方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9A"><span class="toc-number">19.2.</span> <span class="toc-text">2. 安全性：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%9A"><span class="toc-number">19.3.</span> <span class="toc-text">3. 幂等性：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9A"><span class="toc-number">19.4.</span> <span class="toc-text">4. 可见性：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="toc-number">19.5.</span> <span class="toc-text">5. 缓存：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">19.6.</span> <span class="toc-text">6. 使用场景：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Git-merge-vs-Git-rebase"><span class="toc-number">19.6.1.</span> <span class="toc-text">Git merge vs. Git rebase</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99LRU"><span class="toc-number">20.</span> <span class="toc-text">手写LRU</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89"><span class="toc-number">21.</span> <span class="toc-text">Java面试题复习总结（自用）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">22.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A"><span class="toc-number">22.1.</span> <span class="toc-text">线程池：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%9A"><span class="toc-number">22.2.</span> <span class="toc-text">线程基础：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9A"><span class="toc-number">22.3.</span> <span class="toc-text">并发安全：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-number">23.</span> <span class="toc-text">Spring</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC"><span class="toc-number">24.</span> <span class="toc-text">SpringMVC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot"><span class="toc-number">25.</span> <span class="toc-text">SpringBoot</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyBatis"><span class="toc-number">26.</span> <span class="toc-text">MyBatis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">27.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%EF%BC%9A"><span class="toc-number">27.1.</span> <span class="toc-text">事务：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-number">27.2.</span> <span class="toc-text">优化：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%EF%BC%9A"><span class="toc-number">27.3.</span> <span class="toc-text">其它：</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%B4%BE/MVC%E6%9E%B6%E6%9E%84.html" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"></a><div class="content"><a class="title" href="/post/%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%B4%BE/MVC%E6%9E%B6%E6%9E%84.html" title="无题">无题</a><time datetime="2024-02-07T14:32:07.894Z" title="发表于 2024-02-07 22:32:07">2024-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%B4%BE/Knife4j.html" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"></a><div class="content"><a class="title" href="/post/%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%B4%BE/Knife4j.html" title="无题">无题</a><time datetime="2024-02-07T14:07:05.959Z" title="发表于 2024-02-07 22:07:05">2024-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%B4%BE/%E9%89%B4%E6%9D%83.html" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"></a><div class="content"><a class="title" href="/post/%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%B4%BE/%E9%89%B4%E6%9D%83.html" title="无题">无题</a><time datetime="2024-02-07T14:07:05.959Z" title="发表于 2024-02-07 22:07:05">2024-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/nvm.html" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"></a><div class="content"><a class="title" href="/post/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/nvm.html" title="无题">无题</a><time datetime="2024-01-31T07:18:43.801Z" title="发表于 2024-01-31 15:18:43">2024-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E7%BD%91%E7%AB%99/%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B8%8A%E6%90%AD%E5%BB%BAhexo.html" title="在云服务上搭建hexo"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/11/22/Y65fK7QPnFLEzjs.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在云服务上搭建hexo"></a><div class="content"><a class="title" href="/post/%E7%BD%91%E7%AB%99/%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B8%8A%E6%90%AD%E5%BB%BAhexo.html" title="在云服务上搭建hexo">在云服务上搭建hexo</a><time datetime="2024-01-25T10:01:08.000Z" title="发表于 2024-01-25 18:01:08">2024-01-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2023 - 2024 By fcw</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><br>
<imgsrc="https: haiyong.site="" img="" icp.png"="">
<a href="https://beian.miit.gov.cn/#/Integrated/index" style="color:white" target="_blank">豫ICP备2023032527号</a></imgsrc="https:></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://risingrode.github.io/post/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95-%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93.html'
    this.page.identifier = '/post/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95-%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93.html'
    this.page.title = '面试高频考点'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/js/aplayer/music.js"></script><script src="/js/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>