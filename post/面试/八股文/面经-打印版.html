<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>面经 | 代码有点萌</title><meta name="author" content="fcw,3185087246@protonmail.com"><meta name="copyright" content="fcw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面经请求一个网页链接的过程以下是请求一个网页链接的详细过程：  DNS解析：  客户端（通常是Web浏览器）获取目标网页的URL（统一资源定位符）。 客户端提取URL中的域名部分，例如www.example.com。 客户端向本地DNS服务器发起域名解析请求，询问目标网页的IP地址。   TCP连接建立：  客户端通过本地DNS服务器获取目标网页的IP地址。 客户端使用目标网页的IP地址与服务器建">
<meta property="og:type" content="article">
<meta property="og:title" content="面经">
<meta property="og:url" content="https://risingrode.github.io/post/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/%E9%9D%A2%E7%BB%8F-%E6%89%93%E5%8D%B0%E7%89%88.html">
<meta property="og:site_name" content="代码有点萌">
<meta property="og:description" content="面经请求一个网页链接的过程以下是请求一个网页链接的详细过程：  DNS解析：  客户端（通常是Web浏览器）获取目标网页的URL（统一资源定位符）。 客户端提取URL中的域名部分，例如www.example.com。 客户端向本地DNS服务器发起域名解析请求，询问目标网页的IP地址。   TCP连接建立：  客户端通过本地DNS服务器获取目标网页的IP地址。 客户端使用目标网页的IP地址与服务器建">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg">
<meta property="article:published_time" content="2023-06-29T08:06:29.000Z">
<meta property="article:modified_time" content="2023-11-27T00:15:03.472Z">
<meta property="article:author" content="fcw">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://risingrode.github.io/post/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/%E9%9D%A2%E7%BB%8F-%E6%89%93%E5%8D%B0%E7%89%88.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面经',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-27 08:15:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="/live2d-widget-master/autoload.js"></script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/girl.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">47</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 优质网站链接</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="代码有点萌"><span class="site-name">代码有点萌</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 优质网站链接</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw far fa-comment"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面经</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-29T08:06:29.000Z" title="发表于 2023-06-29 16:06:29">2023-06-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-27T00:15:03.472Z" title="更新于 2023-11-27 08:15:03">2023-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">35.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>109分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面经"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg');"></div><article class="post-content" id="article-container"><h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><h2 id="请求一个网页链接的过程"><a href="#请求一个网页链接的过程" class="headerlink" title="请求一个网页链接的过程"></a>请求一个网页链接的过程</h2><p>以下是请求一个网页链接的详细过程：</p>
<ol>
<li><p>DNS解析：</p>
<ul>
<li>客户端（通常是Web浏览器）获取目标网页的URL（统一资源定位符）。</li>
<li>客户端提取URL中的域名部分，例如<a target="_blank" rel="noopener" href="http://www.example.com./">www.example.com。</a></li>
<li>客户端向本地DNS服务器发起域名解析请求，询问目标网页的IP地址。</li>
</ul>
</li>
<li><p>TCP连接建立：</p>
<ul>
<li>客户端通过本地DNS服务器获取目标网页的IP地址。</li>
<li>客户端使用目标网页的IP地址与服务器建立TCP连接。</li>
<li>客户端向服务器发送一个TCP连接请求（称为三次握手），建立可靠的通信连接。</li>
</ul>
</li>
<li><p>发送HTTP请求：</p>
<ul>
<li>客户端向服务器发送一个HTTP请求报文，包括以下内容：<ul>
<li>请求行：包含请求方法（GET、POST等）和请求的资源路径。</li>
<li>请求头：包含附加的请求信息，如浏览器类型、语言偏好等。</li>
<li>请求体（对于POST请求）：包含提交的数据。</li>
</ul>
</li>
<li>客户端将HTTP请求报文发送到服务器端。</li>
</ul>
</li>
<li><p>服务器处理请求：</p>
<ul>
<li>服务器接收到客户端发送的HTTP请求。</li>
<li>服务器解析请求报文，获取请求的资源路径和其他相关信息。</li>
<li>服务器根据请求的资源路径和服务器配置，处理请求并生成相应的响应。</li>
</ul>
</li>
<li><p>服务器发送HTTP响应：</p>
<ul>
<li>服务器生成一个HTTP响应报文，包括以下内容：<ul>
<li>状态行：指示响应状态码（如200表示成功）和响应的文本描述。</li>
<li>响应头：包含附加的响应信息，如内容类型、日期等。</li>
<li>响应体：包含请求的资源或响应的数据。</li>
</ul>
</li>
<li>服务器将HTTP响应报文发送回客户端。</li>
</ul>
</li>
<li><p>客户端接收HTTP响应：</p>
<ul>
<li>客户端接收到服务器发送的HTTP响应。</li>
<li>客户端解析响应报文，提取响应状态码、响应头和响应体等信息。</li>
</ul>
</li>
<li><p>渲染和显示网页：</p>
<ul>
<li>如果响应状态码为200（成功），客户端将根据响应的内容类型（如HTML、CSS、JavaScript等）对响应体进行解析。</li>
<li>客户端渲染并显示网页内容，将HTML解析为可视化的网页，执行JavaScript代码，加载和显示网页中的资源（如图像、样式表等）。</li>
</ul>
</li>
<li><p>关闭TCP连接：</p>
<ul>
<li>客户端和服务器之间的数据传输完成后，客户端和服务器通过TCP连接进行握手，关闭连接。</li>
</ul>
</li>
</ol>
<h2 id="Redis-将数据存储在内存中，mysql把数据存在哪里？"><a href="#Redis-将数据存储在内存中，mysql把数据存在哪里？" class="headerlink" title="Redis 将数据存储在内存中，mysql把数据存在哪里？"></a>Redis 将数据存储在内存中，mysql把数据存在哪里？</h2><p>MySQL将数据存储在磁盘上。它使用文件系统来管理数据文件，将数据持久地存储在硬盘上的文件中。MySQL的数据文件通常被称为表空间（tablespace），包括系统表空间和用户表空间。</p>
<p>系统表空间包含了MySQL的系统表和共享表数据。这些表存储了关于数据库和表结构的元数据信息。</p>
<p>用户表空间用于存储用户创建的表和数据。每个数据库都有一个对应的用户表空间，其中包含该数据库中所有表的数据。</p>
<p>在用户表空间中，每个表都有对应的表文件，用于存储表的数据和索引。这些表文件通常以<code>.frm</code>扩展名的文件存储表的定义，以及<code>.ibd</code>扩展名的文件存储表的数据和索引。</p>
<p>MySQL还使用日志文件来记录数据库的修改操作，包括事务日志和重做日志。这些日志文件位于磁盘上，用于保证数据的一致性和持久性。</p>
<p>需要注意的是，MySQL也可以配置为使用内存表（Memory Table），这种表将数据存储在内存中，但是它们的数据不是持久的，会在MySQL重启或关闭时丢失。而Redis则是一种基于内存的键值存储系统，它将数据完全存储在内存中，并通过持久化机制将数据定期写入磁盘以保证数据的持久性。</p>
<h2 id="内存与磁盘的区别"><a href="#内存与磁盘的区别" class="headerlink" title="内存与磁盘的区别"></a>内存与磁盘的区别</h2><p>内存（RAM）和磁盘（硬盘或固态硬盘）是计算机中用于存储数据的两个主要组件，它们在以下几个方面有着明显的区别：</p>
<ol>
<li><p>工作原理：内存是计算机中的临时存储介质，用于存储正在运行的程序和数据。它通过电子电荷在集成电路中的状态变化来存储和访问数据，数据在断电后会被清空。磁盘是永久存储介质，用于长期存储数据。它利用磁性材料上的磁场来存储和读取数据，数据在断电后仍然保留。</p>
</li>
<li><p>速度：内存的读写速度非常快，可以以纳秒级别的速度访问数据。这使得内存非常适合于需要快速访问的数据和程序。磁盘的读写速度相对较慢，以毫秒级别甚至更长的时间访问数据。</p>
</li>
<li><p>容量：内存的容量通常比较有限，以几千兆字节（GB）为单位。磁盘的容量相对较大，可以达到几十到几千或更多的千兆字节（TB）。</p>
</li>
<li><p>成本：内存的成本相对较高，以每千兆字节（GB）为单位计算。磁盘的成本相对较低，以每千兆字节（GB）或每千兆位（GB）为单位计算。</p>
</li>
<li><p>数据持久性：内存是易失性存储，断电后数据会丢失。磁盘是非易失性存储，断电后数据仍然保留。</p>
</li>
</ol>
<p>基于这些区别，内存通常用于临时存储正在运行的程序和数据，以提供快速访问速度。磁盘用于长期存储大量数据和文件，但相对访问速度较慢。计算机系统通常会使用内存作为缓存，将经常访问的数据存储在内存中，以提高整体性能。</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树（B-tree）是一种自平衡的搜索树数据结构，广泛应用于文件系统、数据库和文件索引等领域。它具有高效的插入、删除和查找操作，同时适应大规模数据集的存储和访问。</p>
<p>B树的特点包括：</p>
<ol>
<li><p>多路搜索树：B树是一种多路搜索树，每个节点可以存储多个键值对。相比于二叉搜索树，B树的节点可以拥有更多的子节点，从而减少树的高度，提高搜索效率。</p>
</li>
<li><p>自平衡：B树通过保持树的平衡性来保证高效的操作。在插入和删除操作后，B树会进行自动的平衡调整，确保树的高度在可接受的范围内，避免数据倾斜和性能下降。</p>
</li>
<li><p>有序存储：B树的节点中的键值对按照特定的顺序进行存储。这使得B树在范围查询和顺序遍历方面表现出良好的性能。</p>
</li>
<li><p>多级索引：B树支持多级索引结构，通过根节点、内部节点和叶节点的层次结构，可以快速定位和访问存储在树中的数据。</p>
</li>
<li><p>磁盘友好：B树的节点大小通常与磁盘页的大小相匹配。这意味着在磁盘上读取或写入一个节点时，可以一次性处理更多的键值对，减少磁盘I/O操作次数，提高性能。</p>
</li>
</ol>
<p>总体而言，B树通过自平衡和多路搜索的特性，在处理大规模数据和频繁的插入、删除、查找操作时表现出较好的性能。它是许多常见数据存储系统的核心组件之一，用于高效地管理和访问数据。</p>
<h2 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h2><p>HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是用于在网络上传输数据的两种协议。它们之间的主要区别在于安全性和数据传输方式：</p>
<ol>
<li><p>安全性：HTTP是明文传输协议，数据在传输过程中不经过加密处理，容易被恶意攻击者截获和窃听。HTTPS使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对通信进行加密，确保数据在传输过程中的机密性和完整性，使得数据更加安全。</p>
</li>
<li><p>加密方式：HTTP不使用加密，数据以纯文本形式传输。HTTPS使用SSL或TLS协议对数据进行加密，使数据在传输过程中变得不可读。</p>
</li>
<li><p>端口号：HTTP默认使用80端口进行通信，而HTTPS默认使用443端口。这样使得网络服务器能够根据端口号来区分处理HTTP请求和HTTPS请求。</p>
</li>
<li><p>证书要求：HTTPS需要通过数字证书来验证服务器的身份。数字证书由可信任的第三方机构（如CA机构）签发，用于证明服务器的身份和确保通信的安全性。而HTTP不需要证书验证。</p>
</li>
<li><p>性能：HTTPS的加密和解密过程需要消耗更多的计算资源，因此比起HTTP会稍微慢一些。然而，随着计算机处理能力的提升，HTTPS的性能差距逐渐缩小。</p>
</li>
</ol>
<p>综上所述，HTTPS相较于HTTP在数据传输过程中提供了更高的安全性和保护用户隐私的能力。因此，对于处理敏感信息和需要保密性的场景，使用HTTPS是更为推荐的选择。</p>
<h2 id="Socket是什么"><a href="#Socket是什么" class="headerlink" title="Socket是什么"></a>Socket是什么</h2><p>Socket（套接字）是计算机网络中用于实现网络通信的编程接口或抽象层。它允许应用程序通过网络发送和接收数据，实现不同设备之间的通信。</p>
<p>Socket提供了一种标准化的方式，使得应用程序能够通过网络进行数据传输。它基于网络协议栈（例如TCP/IP协议栈）来实现数据的分割、传输和重组。</p>
<p>通过使用Socket，应用程序可以创建一个网络套接字（socket），并通过该套接字与其他设备建立连接、发送和接收数据。套接字可以在不同设备之间的不同计算机上进行通信，允许客户端和服务器之间的双向数据传输。</p>
<p>在网络编程中，Socket通常使用一组API函数来进行操作，这些函数包括创建套接字、绑定套接字到特定的IP地址和端口、监听连接请求、接受连接、发送和接收数据等。</p>
<p>不同类型的套接字可以支持不同的网络协议和通信模式，例如TCP套接字用于可靠的面向连接的通信，UDP套接字用于无连接的不可靠通信。</p>
<p>总结来说，Socket是一种网络编程接口，允许应用程序通过网络进行数据传输和通信。它提供了一种标准化的方式来实现网络通信，使得应用程序能够在不同设备之间进行数据交换。</p>
<hr>
<h2 id="GET和POST区别："><a href="#GET和POST区别：" class="headerlink" title="GET和POST区别："></a>GET和POST区别：</h2><ul>
<li>GET用于获取资源，POST用于提交资源。</li>
<li>GET请求的参数会附加在URL的后面，以查询字符串的形式传递，而POST请求的参数在请求体中传递，不会在URL中显示。</li>
<li>GET请求对数据长度有限制，一般在URL长度上限范围内，而POST请求对数据长度没有限制。</li>
<li>GET请求的数据会被保存在浏览器的历史记录中，而POST请求的数据不会保存。</li>
<li>GET请求会被浏览器主动缓存，POST请求不会被缓存，需要再次确认是否提交。</li>
</ul>
<h2 id="HTTP和HTTPS区别："><a href="#HTTP和HTTPS区别：" class="headerlink" title="HTTP和HTTPS区别："></a>HTTP和HTTPS区别：</h2><ul>
<li>HTTP是明文传输协议，数据在传输过程中不经过加密处理，容易被截获和窃听。HTTPS使用SSL/TLS协议对通信进行加密，保证数据的机密性和完整性。</li>
<li>HTTP默认使用80端口进行通信，而HTTPS默认使用443端口。</li>
<li>HTTP不需要证书验证，而HTTPS需要通过数字证书验证服务器的身份。</li>
<li>HTTPS的安全性更高，但相对而言会消耗更多的计算资源，性能稍低于HTTP。</li>
</ul>
<h2 id="十进制和二进制的转换："><a href="#十进制和二进制的转换：" class="headerlink" title="十进制和二进制的转换："></a>十进制和二进制的转换：</h2><ul>
<li>十进制转二进制：将十进制数不断除以2，直到商为0，然后将每次的余数从下往上依次排列，即为二进制表示。</li>
<li>二进制转十进制：将二进制数从右往左依次乘以2的幂，对应位置上为1的位对应的幂相加，得到的和即为十进制表示。</li>
</ul>
<blockquote>
<p>判断一个数是否为2的幂：一个数如果是2的幂，则其二进制表示中只有一个1，其他位都是0。可以使用位运算进行判断，如果数n满足 n &amp; (n-1) == 0，则它是2的幂。</p>
</blockquote>
<h2 id="MySQL调优："><a href="#MySQL调优：" class="headerlink" title="MySQL调优："></a>MySQL调优：</h2><ul>
<li>使用索引来加速查询。</li>
<li>优化SQL语句，避免全表扫描和不必要的连接。</li>
<li>适当调整数据库的参数设置，如缓冲区大小、连接数等。</li>
<li>避免使用过多的触发器和存储过程，以减少数据库的负载。</li>
<li>合理设计数据库表结构，避免冗余和重复数据。</li>
<li>定期进行数据库备份和优化，清理无用数据和日志。</li>
</ul>
<h2 id="IO多路复用："><a href="#IO多路复用：" class="headerlink" title="IO多路复用："></a>IO多路复用：</h2><p>IO多路复用是一种通过单个线程来监听多个IO事件的机制，它可以同时监视多个文件描述符的可读、可写等事件状态。常见的IO多路复用模型包括select、poll和epoll。它可以提高程序的并发性能，避免使用多线程或多进程处理大量的并发连接。</p>
<h2 id="HAVING和WHERE区别："><a href="#HAVING和WHERE区别：" class="headerlink" title="HAVING和WHERE区别："></a>HAVING和WHERE区别：</h2><ul>
<li>WHERE用于在查询中指定条件筛选行，它在对表进行分组之前过滤数据。</li>
<li>HAVING用于在查询的结果集上指定条件，它在对分组后的结果进行过滤。</li>
</ul>
<h2 id="Redis数据类型和数据结构："><a href="#Redis数据类型和数据结构：" class="headerlink" title="Redis数据类型和数据结构："></a>Redis数据类型和数据结构：</h2><p>Redis支持多种数据类型，包括字符串（String）、哈希（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set）和位图（Bitmap）等。</p>
<ul>
<li>有序集合（Sorted Set）使用跳表（Skip List）和字典（Hash Table）两种数据结构，跳表用于提供有序性，字典用于提供快速的成员查找和删除操作。</li>
<li>跳表是一种特殊的链表结构，通过在每个节点上增加多个指针来实现快速的查找和插入操作。</li>
</ul>
<h2 id="第K大算法："><a href="#第K大算法：" class="headerlink" title="第K大算法："></a>第K大算法：</h2><p>可以使用快速选择（QuickSelect）算法来找到数组中第K大的元素，其基本思想是选取一个基准元素，将数组划分为两部分，使得左边的元素都大于基准元素，右边的元素都小于基准元素。如果基准元素的位置等于K，则找到了第K大的元素；如果基准元素的位置大于K，则在左边继续查找；如果基准元素的位置小于K，则在右边继续查找。通过递归地进行划分和查找，最终可以找到第K大的元素。</p>
<hr>
<h2 id="MySQL默认引擎，解决了什么问题："><a href="#MySQL默认引擎，解决了什么问题：" class="headerlink" title="MySQL默认引擎，解决了什么问题："></a>MySQL默认引擎，解决了什么问题：</h2><ul>
<li>MySQL的默认存储引擎是InnoDB。</li>
<li>InnoDB引擎解决了多版本并发控制（MVCC）的问题，实现了更好的并发性能。</li>
<li>它支持事务处理和ACID属性（原子性、一致性、隔离性和持久性），提供了更高的数据完整性和可靠性。</li>
<li>InnoDB还提供了行级锁定和外键约束等功能。</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h2 id="MySQL写一个死锁场景："><a href="#MySQL写一个死锁场景：" class="headerlink" title="MySQL写一个死锁场景："></a>MySQL写一个死锁场景：</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 会话1</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话2</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会话1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>上述场景中，会话1获取了table1的行锁并等待table2的行锁，同时会话2获取了table2的行锁并等待table1的行锁，从而造成死锁。</p>
<h2 id="一组有序可重复数组找到某个最后出现的数的索引（二分）："><a href="#一组有序可重复数组找到某个最后出现的数的索引（二分）：" class="headerlink" title="一组有序可重复数组找到某个最后出现的数的索引（二分）："></a>一组有序可重复数组找到某个最后出现的数的索引（二分）：</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_last_index</span>(<span class="params">arr, target</span>):</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    index = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:</span><br><span class="line">            index = mid</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index</span><br></pre></td></tr></tbody></table></figure>


<blockquote>
<p> 有1、3、9、27克的砝码各一个，能称出多重的物品，后追问如果添加81克、273克等（3的幂）各一个，能称出500克：</p>
<blockquote>
<p>可以使用贪心算法解决该问题。首先，将重量为1的砝码放在一边，然后将剩下的砝码按从小到大的顺序放在另一边，将需要称重的物品放在一边，并根据需要逐步使用较大的砝码进行称重。如果添加了81克、273克等砝码，仍然可以按照相同的方法进行称重，因为这些额外的砝码是3的幂，可以覆盖到其他重量范围。这样，可以称出500克的物品。</p>
</blockquote>
</blockquote>
<hr>
<h2 id="线程安全机制："><a href="#线程安全机制：" class="headerlink" title="线程安全机制："></a>线程安全机制：</h2><p>线程安全是指在多线程环境下，多个线程同时访问共享资源时，保证对共享资源的操作能够正确执行而不会出现数据不一致或不确定的结果。</p>
<p>常见的线程安全机制包括：</p>
<ul>
<li>互斥锁（Mutex）：通过锁机制保证在同一时刻只有一个线程可以访问共享资源。</li>
<li>信号量（Semaphore）：用于控制同时访问共享资源的线程数量。</li>
<li>条件变量（Condition Variable）：用于线程之间的通信和同步，允许线程等待某个条件的发生。</li>
<li>原子操作（Atomic Operation）：保证特定操作在执行过程中不会被中断，确保数据的原子性。</li>
</ul>
<h2 id="JVM类加载："><a href="#JVM类加载：" class="headerlink" title="JVM类加载："></a>JVM类加载：</h2><p>JVM（Java Virtual Machine）类加载是指将Java字节码文件加载到内存中，并解析成可执行的Java类的过程。<br>JVM采用了三级类加载器体系：启动类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）和应用程序类加载器（Application Class Loader）。</p>
<p>类加载的过程包括：</p>
<ul>
<li>加载（Loading）：将字节码文件加载到内存中，通常从磁盘或网络中获取字节码文件。</li>
<li>验证（Verification）：验证字节码文件的格式、结构和语义的正确性。</li>
<li>准备（Preparation）：为类的静态变量分配内存空间，并设置默认初始值。</li>
<li>解析（Resolution）：将符号引用替换为直接引用，解析类之间的关系。</li>
<li>初始化（Initialization）：执行类的初始化代码，包括静态变量的赋值和静态块的执行。</li>
</ul>
<h2 id="TCP-x2F-IP如何实现可靠的数据传输："><a href="#TCP-x2F-IP如何实现可靠的数据传输：" class="headerlink" title="TCP/IP如何实现可靠的数据传输："></a>TCP/IP如何实现可靠的数据传输：</h2><p>TCP/IP协议通过以下方式实现可靠的数据传输：</p>
<ul>
<li>应用数据被分割成小的数据块（Segment），每个数据块都有序号。</li>
<li>TCP使用滑动窗口机制来管理发送和接收数据的缓冲区大小。</li>
<li>接收方会对收到的数据进行确认，并发送确认消息给发送方，以确认数据的接收。</li>
<li>发送方在一定时间内未收到确认消息，则认为数据丢失，并重新发送未收到确认的数据。</li>
<li>TCP使用序号和确认号来保证数据的有序性和完整性。</li>
<li>TCP使用流量控制和拥塞控制机制来控制数据的发送速率，避免网络拥塞和数据丢失。</li>
</ul>
<ol start="7">
<li>CAS（Compare and Swap）：<br>CAS是一种并发编程中的原子操作，用于实现无锁并发算法。它通过比较内存中的值与预期值是否相等，如果相等则将新值写入内存，否则不进行任何操作。</li>
</ol>
<p>CAS操作包括三个参数：内存地址（或称为变量的引用）、预期值和新值。它的执行过程如下：</p>
<ul>
<li>读取内存地址中的值，与预期值进行比较。</li>
<li>如果相等，则将新值写入内存地址，操作成功。</li>
<li>如果不相等，则表示其他线程已经修改了内存中的值，CAS操作失败。</li>
</ul>
<p>CAS操作在并发环境下可以保证数据的一致性和线程安全性，避免了锁的使用，减少了线程切换和调度的开销。然而，CAS操作也存在ABA问题，即在操作过程中可能发生其他线程修改了值并恢复成原来的值，导致CAS操作无法感知这种变化。为了解决ABA问题，通常会使用版本号或标记来增加额外的判断。</p>
<hr>
<h2 id="static关键字："><a href="#static关键字：" class="headerlink" title="static关键字："></a>static关键字：</h2><ul>
<li>static关键字可以用于修饰类的成员（属性和方法），也可以用于修饰局部变量。</li>
<li>当static关键字用于类的成员时，表示该成员属于类级别，而不是实例级别。类的所有实例共享同一个static成员。</li>
<li>静态成员可以通过类名直接访问，不需要创建类的实例。</li>
<li>静态属性在内存中只有一份拷贝，对于所有的实例都是共享的。</li>
<li>静态方法不能访问非静态成员，只能访问静态成员。</li>
</ul>
<h2 id="类加载机制："><a href="#类加载机制：" class="headerlink" title="类加载机制："></a>类加载机制：</h2><ul>
<li>类加载是指将类的字节码文件加载到内存中，并在JVM中生成对应的Class对象的过程。</li>
<li>类加载机制分为加载、验证、准备、解析和初始化五个阶段。</li>
<li>加载阶段：通过类加载器将字节码文件加载到内存中。</li>
<li>验证阶段：验证字节码文件的正确性和安全性。</li>
<li>准备阶段：为类的静态变量分配内存空间，并设置默认初始值。</li>
<li>解析阶段：将符号引用替换为直接引用，建立类之间的关系。</li>
<li>初始化阶段：执行类的初始化代码，包括静态变量的赋值和静态块的执行。</li>
</ul>
<h2 id="反射："><a href="#反射：" class="headerlink" title="反射："></a>反射：</h2><ul>
<li>反射是指在运行时动态地获取类的信息，并能够操作类或对象的属性、方法和构造函数。</li>
<li>通过反射，可以在运行时创建对象、调用方法、获取和设置属性等，即使在编译时无法确定具体的类。</li>
<li>反射提供了灵活性和扩展性，但由于涉及到动态解析和调用，性能上相对较低。</li>
</ul>
<h2 id="HashMap："><a href="#HashMap：" class="headerlink" title="HashMap："></a>HashMap：</h2><ul>
<li><p>HashMap是Java中的一种数据结构，用于存储键值对。</p>
</li>
<li><p>它基于哈希表实现，可以快速地进行插入、删除和查找操作。</p>
</li>
<li><p>HashMap允许null键和null值，但键不能重复（相同的键只能存在一个）。</p>
</li>
<li><p>HashMap的底层数据结构是数组和链表（或红黑树），通过哈希算法将键映射到数组的索引位置，解决哈希冲突的键值对通过链表（或红黑树）形成一个链表（或红黑树）节点。</p>
</li>
<li><p>HashMap的查找和插入操作的平均时间复杂度是O(1)，但在最坏情况下可能会达到O(n)。</p>
</li>
</ul>
<h2 id="TCP和UDP的区别及介绍："><a href="#TCP和UDP的区别及介绍：" class="headerlink" title="TCP和UDP的区别及介绍："></a>TCP和UDP的区别及介绍：</h2><ul>
<li>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是网络通信中常用的两种传输协议。</li>
<li>TCP是面向连接的协议，提供可靠的数据传输，保证数据的有序性和完整性，但传输效率相对较低。</li>
<li>UDP是无连接的协议，不提供可靠性保证，传输速度较快，但对数据的有序性和完整性没有保证。</li>
<li>TCP使用三次握手和四次挥手来建立和关闭连接，保证数据的可靠传输。</li>
<li>UDP适用于实时性要求高、数据量较小、丢失一些数据不影响的场景，例如音视频传输、实时游戏等。</li>
</ul>
<h2 id="TCP如何保证可靠的数据传输："><a href="#TCP如何保证可靠的数据传输：" class="headerlink" title="TCP如何保证可靠的数据传输："></a>TCP如何保证可靠的数据传输：</h2><ul>
<li>TCP使用以下机制保证数据的可靠传输：<ul>
<li>序号和确认号：TCP使用序号对数据进行编号，接收方通过确认号告知发送方已接收到的数据，确保数据的有序性和完整性。</li>
<li>窗口机制：TCP使用滑动窗口机制控制发送和接收数据的窗口大小，根据网络的拥塞情况动态调整数据传输速率。</li>
<li>确认机制：接收方在接收到数据后发送确认消息给发送方，以确认数据的接收。如果发送方在一定时间内未收到确认消息，则认为数据丢失，重新发送未收到<br>确认的数据。</li>
<li>超时重传：如果发送方在一定时间内未收到确认消息，则认为数据丢失，会重新发送未收到确认的数据，确保数据的可靠传输。</li>
<li>拥塞控制：TCP使用拥塞控制机制来避免网络拥塞，通过动态调整窗口大小和发送速率来控制数据的传输。</li>
</ul>
</li>
</ul>
<blockquote>
<p>给定一个数组，然后一个正数k，判断数组中是否存在子数组，使得子数组之和可以被正数K整除。</p>
<blockquote>
<p>思路：使用前缀和的思想，使用一个Set容器存储前缀和与k的余数，当计算完每个位置的前缀和并取余后，如果发现Set中存在该余数，则证明一定存在一个子数组之和可以被k整除。这是因为如果两个位置的前缀和的余数相同，那么这两个位置之间的子数组之和必然是k的倍数。</p>
</blockquote>
</blockquote>
<h2 id="说一下数组和列表是什么，以及区别？"><a href="#说一下数组和列表是什么，以及区别？" class="headerlink" title="说一下数组和列表是什么，以及区别？"></a>说一下数组和列表是什么，以及区别？</h2><p>数组和列表都是数据结构用于存储和组织一组数据的容器，但它们在实现方式和特性上有一些区别。</p>
<p>数组（Array）：</p>
<ul>
<li>数组是一种固定大小的数据结构，它由相同类型的元素组成，这些元素在内存中是连续存储的。</li>
<li>数组的访问是通过索引来实现的，可以通过索引快速访问和修改数组中的元素。</li>
<li>数组的大小在创建时确定，并且通常不可更改。如果需要调整大小，需要创建一个新的数组，并将原数组的元素复制到新数组中。</li>
<li>数组适合用于对元素的随机访问和修改，但在插入和删除元素时效率较低。</li>
</ul>
<p>列表（List）：</p>
<ul>
<li>列表是一种动态大小的数据结构，它可以容纳不同类型的元素，并且元素在内存中不一定是连续存储的。</li>
<li>列表的访问可以通过索引或迭代器来实现，可以按需访问和修改列表中的元素。</li>
<li>列表的大小可以根据需要动态调整，可以方便地插入和删除元素。</li>
<li>列表适合用于需要频繁插入和删除元素的场景，但在随机访问元素时效率较低。</li>
</ul>
<p>区别：</p>
<ol>
<li>存储方式：数组中的元素在内存中是连续存储的，而列表中的元素在内存中不一定是连续存储的。</li>
<li>大小调整：数组的大小在创建时确定，并且通常不可更改，而列表的大小可以根据需要动态调整。</li>
<li>元素类型：数组要求存储的元素类型必须相同，而列表可以容纳不同类型的元素。</li>
<li>插入和删除操作：数组在插入和删除元素时效率较低，需要移动其他元素，而列表在插入和删除元素时效率较高，不需要移动其他元素。</li>
<li>随机访问效率：数组可以通过索引进行快速随机访问，而列表在随机访问元素时效率较低。</li>
</ol>
<h2 id="Spring-Bean-生命周期："><a href="#Spring-Bean-生命周期：" class="headerlink" title="Spring Bean 生命周期："></a>Spring Bean 生命周期：</h2><ul>
<li>实例化：当容器加载Bean定义时，会实例化Bean对象。</li>
<li>属性赋值：容器将属性值和对其他Bean的引用注入到Bean实例中。</li>
<li>初始化：在Bean实例化和属性赋值完成后，可以执行自定义的初始化逻辑，例如调用自定义的初始化方法或实现InitializingBean接口。</li>
<li>使用：Bean可以被容器或其他Bean使用。</li>
<li>销毁：当容器关闭时，会销毁Bean对象，可以执行自定义的销毁逻辑，例如调用自定义的销毁方法或实现DisposableBean接口。</li>
</ul>
<h2 id="Spring-Boot-Starter-factorys文件："><a href="#Spring-Boot-Starter-factorys文件：" class="headerlink" title="Spring Boot Starter .factorys文件："></a>Spring Boot Starter .factorys文件：</h2><ul>
<li>在Spring Boot中，自动配置的实现是通过Spring Boot Starter模块来实现的。</li>
<li>在Starter模块的META-INF目录下，有一个名为spring.factories的文件，其中列出了自动配置类的全限定名。</li>
<li>Spring Boot在启动时，会根据spring.factories文件加载配置的自动配置类，并将其纳入到应用上下文中。</li>
</ul>
<h2 id="MySQL三个范式和索引建立与查询："><a href="#MySQL三个范式和索引建立与查询：" class="headerlink" title="MySQL三个范式和索引建立与查询："></a>MySQL三个范式和索引建立与查询：</h2><ul>
<li>第一范式（1NF）要求数据表中的每一列都是不可分割的最小数据单位，确保每个数据都是原子性的。</li>
<li>第二范式（2NF）要求数据表中的非主键列完全依赖于主键，即每个非主键列都必须完全依赖于主键而不是部分依赖。</li>
<li>第三范式（3NF）要求数据表中的非主键列之间没有传递依赖关系，即非主键列不依赖于其他非主键列。</li>
</ul>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ul>
<li>原子性（Atomicity）：事务是一个原子操作，要么全部执行成功，要么全部回滚到事务开始前的状态。</li>
<li>一致性（Consistency）：事务在执行前后，数据的完整性必须保持一致，即满足预定义的规则和约束。</li>
<li>隔离性（Isolation）：多个并发事务之间应该相互隔离，每个事务都应该感觉不到其他事务的存在。</li>
<li>持久性（Durability）：一旦事务提交，对数据库的修改应该永久保存，即使系统故障也不应该丢失提交的事务。</li>
</ul>
<p>具体实现事务的方式包括使用事务管理器、在代码中使用@Transactional注解等。</p>
<h2 id="Redis缓存穿透、缓存击穿和缓存雪崩的解决方法："><a href="#Redis缓存穿透、缓存击穿和缓存雪崩的解决方法：" class="headerlink" title="Redis缓存穿透、缓存击穿和缓存雪崩的解决方法："></a>Redis缓存穿透、缓存击穿和缓存雪崩的解决方法：</h2><ul>
<li>缓存穿透：指查询一个不存在于缓存和数据库中的数据，导致每次查询都穿透到数据库。解决方法包括在查询时进行空值缓存、布隆过滤器等。</li>
<li>缓存击穿：指一个热点数据失效或被删除，导致大量请求直接打到数据库上。解决方法包括设置热点数据永不过期、互斥锁等。</li>
<li>缓存雪崩：指缓存中的大量数据在同一时间失效，导致大量请求直接打到数据库上。解决方法包括设置缓存数据的随机过期时间、使用分布式缓存等。</li>
</ul>
<h2 id="Redis实现分布式锁和解决set-nx命令的问题："><a href="#Redis实现分布式锁和解决set-nx命令的问题：" class="headerlink" title="Redis实现分布式锁和解决set nx命令的问题："></a>Redis实现分布式锁和解决set nx命令的问题：</h2><ul>
<li>使用Redis实现分布式锁可以利用Redis的原子性操作，通过设置一个特定的键来实现锁的获取和释放。</li>
<li>在使用<code>SET</code>命令设置分布式锁时，可以设置<code>NX</code>（只在键不存在时才设置）和<code>EX</code>（设置键的过期时间）选项。</li>
<li>问题：在分布式环境下，如果获取锁和设置过期时间两个操作不是原子性的，可能导致锁无法正常释放。</li>
<li>解决方法：可以使用<code>SET</code>命令的<code>NX</code>、<code>EX</code>和<code>PX</code>选项组合，或者使用Redis的Lua脚本来保证获取锁和设置过期时间的原子性。</li>
</ul>
<h2 id="CMS（Concurrent-Mark-Sweep）："><a href="#CMS（Concurrent-Mark-Sweep）：" class="headerlink" title="CMS（Concurrent Mark Sweep）："></a>CMS（Concurrent Mark Sweep）：</h2><ul>
<li>CMS是一种基于标记-清除算法的垃圾回收器，用于减少垃圾回收的停顿时间。</li>
<li>CMS采用并发标记和并发清除的方式进行垃圾回收，允许垃圾回收与应用程序并发执行，以减少停顿时间。</li>
<li>CMS的主要目标是减少垃圾回收的停顿时间，但可能会牺牲一些吞吐量。</li>
<li>CMS在进行垃圾回收时，会产生一些碎片，可能会导致内存空间的浪费。</li>
</ul>
<h2 id="Full-GC的发生时机："><a href="#Full-GC的发生时机：" class="headerlink" title="Full GC的发生时机："></a>Full GC的发生时机：</h2><ul>
<li>Full GC（Full Garbage Collection）指的是对整个堆内存进行垃圾回收的过程。</li>
<li>Full GC的发生时机包括：<ul>
<li>当老年代空间不足以容纳新生成的对象时，会触发Full GC。</li>
<li>当调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>显式触发垃圾回收时，可能会触发Full GC。</li>
<li>当永久代或元空间（在不同的Java版本中）空间不足时，会触发Full GC。</li>
</ul>
</li>
</ul>
<h2 id="在代码中捕获OOM异常："><a href="#在代码中捕获OOM异常：" class="headerlink" title="在代码中捕获OOM异常："></a>在代码中捕获OOM异常：</h2><ul>
<li>OOM（OutOfMemoryError）是Java中的错误（Error），而不是异常（Exception），表示内存溢出错误。</li>
<li>OOM通常发生在JVM无法分配足够的内存给对象使用时。</li>
<li>由于OOM是错误而不是异常，它表示JVM处于不可恢复的状态，无法被捕获和处理。</li>
</ul>
<h2 id="算法题：二维数组逐行自增快速查找target："><a href="#算法题：二维数组逐行自增快速查找target：" class="headerlink" title="算法题：二维数组逐行自增快速查找target："></a>算法题：二维数组逐行自增快速查找target：</h2><ul>
<li>可以使用二分查找的思想进行解答。</li>
<li>对于逐行自增的二维数组，可以将其看作是一个按顺序排列的一维数组。</li>
<li>首先确定目标值在哪一行，然后在该行进行二分查找。</li>
<li>如果找到目标值，返回true；否则，返回false。</li>
</ul>
<h2 id="ArrayList的并发修改异常（ConcurrentModificationException）"><a href="#ArrayList的并发修改异常（ConcurrentModificationException）" class="headerlink" title="ArrayList的并发修改异常（ConcurrentModificationException）"></a>ArrayList的并发修改异常（ConcurrentModificationException）</h2><ul>
<li>当使用迭代器遍历ArrayList时，如果在遍历过程中通过集合的add、remove等方法修改了集合的结构（增加或删除元素），就会抛出ConcurrentModificationException异常。</li>
<li>单线程情况下不会发生并发修改异常，因为在单线程环境下，遍历和修改操作是串行执行的。</li>
</ul>
<h2 id="Java的happens-before："><a href="#Java的happens-before：" class="headerlink" title="Java的happens-before："></a>Java的happens-before：</h2><ul>
<li>Happens-before是Java内存模型中的概念，用于定义操作之间的可见性和顺序关系。</li>
<li>Happens-before规则规定了在多线程环境下，对共享变量的写操作对于后续的读操作是可见的。</li>
<li>Happens-before关系保证了程序的顺序性和一致性，避免了由于指令重排等因素导致的数据不一致问题。</li>
</ul>
<h2 id="Redis的持久化机制："><a href="#Redis的持久化机制：" class="headerlink" title="Redis的持久化机制："></a>Redis的持久化机制：</h2><ul>
<li>AOF（Append-Only File）持久化：将每个写操作追加到AOF文件中，恢复时重新执行AOF文件中的命令。AOF持久化可以通过配置进行自动化的定期写入或者根据数据变化的时候执行。</li>
<li>RDB（Redis Database）持久化：将当前时刻的内存数据快照保存到磁盘上的二进制文件。RDB持久化可以通过手动执行SAVE或者BGSAVE命令，或者根据配置定期自动执行。</li>
</ul>
<h2 id="Redis集群方案："><a href="#Redis集群方案：" class="headerlink" title="Redis集群方案："></a>Redis集群方案：</h2><ul>
<li>Redis集群通过数据分片和复制来提供高可用性和可扩展性。</li>
<li>Redis Cluster使用分片来水平拆分数据到多个节点，每个节点负责管理其中的一部分数据。</li>
<li>Redis Cluster使用Gossip协议来进行节点之间的通信和信息交换，实现节点的自动发现和故障转移。</li>
<li>集群模式下，Redis客户端会根据哈希算法将数据分散存储到不同的节点上，从而实现负载均衡和数据的高可用性。</li>
</ul>
<h2 id="Spring的IOC容器的作用："><a href="#Spring的IOC容器的作用：" class="headerlink" title="Spring的IOC容器的作用："></a>Spring的IOC容器的作用：</h2><ul>
<li>IOC（Inversion of Control）是一种设计模式，它将对象的创建和依赖关系的管理交给容器来处理。</li>
<li>Spring的IOC容器负责创建、装配和管理应用程序中的对象（Bean），通过配置文件或注解的方式来描述对象之间的依赖关系。</li>
<li>IOC容器的作用是实现对象之间的解耦，使得应用程序的组件更加灵活、可维护和可测试。</li>
</ul>
<h2 id="对Spring的理解："><a href="#对Spring的理解：" class="headerlink" title="对Spring的理解："></a>对Spring的理解：</h2><ul>
<li><p>Spring是一个开源的、轻量级的企业级应用开发框架。</p>
</li>
<li><p>Spring提供了一个IOC容器和AOP等核心特性，以简化Java开发过程。</p>
</li>
<li><p>Spring可以用于构建各种类型的应用程序，包括Web应用、RESTful服务、批处理应用等。</p>
</li>
<li><p>Spring提供了丰富的功能和扩展，如事务管理、安全性、缓存、消息传递等。</p>
</li>
</ul>
<h2 id="适配器、装饰器和代理模式的区别："><a href="#适配器、装饰器和代理模式的区别：" class="headerlink" title="适配器、装饰器和代理模式的区别："></a>适配器、装饰器和代理模式的区别：</h2><ul>
<li>适配器模式：用于将一个类的接口转换成另一个客户端所期望的接口，使得原本不兼容的类能够协同工作。</li>
<li>装饰器模式：动态地给对象添加额外的功能，通过包装（装饰）原始对象，而不是通过继承来扩展功能。</li>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。代理类和被代理类实现相同的接口，通过代理类来控制和管理被代理类的访问。</li>
</ul>
<h2 id="TCP-x2F-IP四层模型："><a href="#TCP-x2F-IP四层模型：" class="headerlink" title="TCP/IP四层模型："></a>TCP/IP四层模型：</h2><ul>
<li>应用层：提供应用程序之间的通信和数据交换，包括HTTP、FTP、SMTP等协议。</li>
<li>传输层：负责端到端的数据传输，包括TCP和UDP协议。</li>
<li>网络层：处理网络中的数据包路由和转发，包括IP协议。</li>
<li>数据链路层：负责物理链路的传输，包括以太网、WiFi等。</li>
</ul>
<h2 id="三次握手和四次挥手："><a href="#三次握手和四次挥手：" class="headerlink" title="三次握手和四次挥手："></a>三次握手和四次挥手：</h2><ul>
<li>三次握手是建立TCP连接的过程，用于确认双方的通信能力和同步连接序列号。</li>
<li>四次挥手是关闭TCP连接的过程，用于双方协商断开连接并确认最后的数据传输。</li>
</ul>
<h2 id="HTTP请求的构成："><a href="#HTTP请求的构成：" class="headerlink" title="HTTP请求的构成："></a>HTTP请求的构成：</h2><ul>
<li>HTTP请求由请求行、请求头和请求体组成。请求行包括请求方法、URL和协议版本。</li>
<li>请求头包括一些附加的信息，如请求头字段和值，用于传递请求的相关信息。</li>
<li>请求体（可选）包含要发送给服务器的数据，例如表单数据或请求体内容。</li>
</ul>
<h2 id="消息队列的作用和RabbitMQ的设计："><a href="#消息队列的作用和RabbitMQ的设计：" class="headerlink" title="消息队列的作用和RabbitMQ的设计："></a>消息队列的作用和RabbitMQ的设计：</h2><ul>
<li>消息队列用于解耦和异步处理系统中的组件，提供了可靠的消息传递机制。</li>
<li>RabbitMQ是一种开源的消息队列系统，它实现了AMQP（高级消息队列协议），提供了可靠的消息传递、消息路由和消息排队等功能。</li>
<li>RabbitMQ的设计包括交换机（Exchange）、队列（Queue）和绑定（Binding），通过交换机和绑定规则将消息发送到特定的队列中。</li>
</ul>
<h2 id="最长无重复子串算法："><a href="#最长无重复子串算法：" class="headerlink" title="最长无重复子串算法："></a>最长无重复子串算法：</h2><ul>
<li><p>最长无重复子串算法可以通过滑动窗口的方式来实现。</p>
</li>
<li><p>使用两个指针表示滑动窗口的左右边界，遍历整个字符串。</p>
</li>
<li><p>当右指针遇到重复字符时，移动左指针到重复字符的下一个位置，更新窗口的大小。</p>
</li>
<li><p>在遍历过程中记录最大的窗口大小，即为最长无重复子串的长度。</p>
</li>
</ul>
<h2 id="什么是遍历和修改操作是串行执行"><a href="#什么是遍历和修改操作是串行执行" class="headerlink" title="什么是遍历和修改操作是串行执行"></a>什么是遍历和修改操作是串行执行</h2><p>当说到遍历和修改操作是串行执行时，意味着在单线程环境中，这两个操作是按顺序依次执行的，不会发生并发或并行的情况。</p>
<p>具体来说，在单线程中执行遍历操作时，会按照集合的顺序依次访问每个元素，直到遍历完所有元素或满足某个条件。期间不会有其他线程干扰或修改集合的结构。</p>
<p>同样，在单线程中执行修改操作时，会依次对集合的元素进行修改，例如添加、删除或更新元素。在修改操作执行期间，也不会有其他线程同时对集合进行修改。</p>
<p>因此，在单线程环境下，遍历和修改操作是串行执行的，保证了操作的顺序性和一致性。但是需要注意的是，在多线程环境下，遍历和修改操作可能会引发并发修改异常（ConcurrentModificationException），需要使用相应的并发控制手段来保证线程安全性。</p>
<h2 id="什么是快照"><a href="#什么是快照" class="headerlink" title="什么是快照"></a>什么是快照</h2><p>在计算机科学和数据库领域，快照（Snapshot）是指某一时刻系统或数据的静态副本或状态的表示。</p>
<p>在操作系统中，快照可以是对文件系统或虚拟机的状态的拍摄，记录了某一时刻文件系统或虚拟机中所有文件、目录和内存的状态。这样的快照可以用于备份和还原，以及系统恢复和故障排除。</p>
<p>在数据库中，快照是数据库在某一时刻的一致性视图。它是数据库在特定时间点的数据副本，反映了数据库中所有表、记录和索引的状态。数据库快照可以用于数据恢复、数据分析和并发控制。</p>
<p>快照的关键特点是它是在某个确定的时间点捕获的，因此它反映了该时间点系统或数据的准确状态。快照可以被用于恢复系统到该时间点的状态，或者作为参考点进行数据分析和比较。</p>
<p>需要注意的是，快照通常是只读的，即不能对快照进行修改。任何对原始系统或数据的修改都不会影响已经捕获的快照。因此，快照常常用于数据保护和故障恢复的目的。</p>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>IOC（Inversion of Control）是一种软件设计原则，也是Spring框架的核心概念之一。它实现了控制反转，即将对象的创建、依赖关系的管理和对象的生命周期的控制权从应用程序代码中转移到了容器（框架）中。</p>
<p>在传统的编程模型中，应用程序代码通常负责创建对象、解决对象之间的依赖关系以及管理对象的生命周期。这导致了代码的紧耦合和复杂性，使得代码难以维护、测试和扩展。</p>
<p>而IOC容器则通过将对象的创建和依赖关系的管理委托给容器来解决这些问题。应用程序只需要描述对象之间的依赖关系，而不需要直接处理对象的创建和管理。容器根据配置文件或注解来实现对象的创建、依赖注入和生命周期管理，从而实现了对象之间的解耦和灵活性。</p>
<p>IOC容器的工作原理是通过反射、配置文件或注解来实现对象的实例化和依赖注入。它可以根据配置文件或注解中的信息，自动创建对象，并将依赖的对象注入到目标对象中。这样，对象之间的依赖关系由容器来管理，应用程序代码只需要使用这些对象即可。</p>
<p>通过使用IOC容器，我们可以实现以下优势：</p>
<ul>
<li>松耦合：对象之间的依赖关系由容器来管理，减少了对象之间的直接耦合，提高了代码的可维护性和可测试性。</li>
<li>可扩展性：通过配置文件或注解，可以很容易地添加、修改或替换对象的实现，而不需要修改应用程序的代码。</li>
<li>简化开发：IOC容器自动处理对象的创建和依赖注入，减少了开发人员的工作量，提高了开发效率。</li>
</ul>
<p>Spring框架是一个基于IOC容器的应用框架，它提供了强大的IOC功能以及其他丰富的特性，如AOP（面向切面编程）、事务管理、安全性等，使得开发者可以更轻松地开发复杂的企业应用。</p>
<h2 id="为什么要有异步这个东西，解决了什么问题，举个代码例子"><a href="#为什么要有异步这个东西，解决了什么问题，举个代码例子" class="headerlink" title="为什么要有异步这个东西，解决了什么问题，举个代码例子"></a>为什么要有异步这个东西，解决了什么问题，举个代码例子</h2><p>异步编程是一种编程范式，用于解决在某些情况下同步执行会导致性能问题或阻塞的情况。它可以提高系统的响应性能、资源利用率和并发处理能力。</p>
<p>异步编程的主要目的是通过将耗时的操作（如网络请求、文件读写、数据库查询等）放在后台进行，不阻塞主线程或其他任务的执行。这样可以使程序在等待这些操作完成的同时继续执行其他任务，提高了程序的吞吐量和响应速度。</p>
<p>异步编程可以解决以下问题：</p>
<ol>
<li>阻塞问题：当程序需要等待耗时操作完成时，同步执行会导致阻塞，影响程序的执行效率和响应性能。异步编程通过非阻塞的方式处理耗时操作，允许程序继续执行其他任务，提高了程序的并发处理能力。</li>
<li>响应性能问题：在需要响应用户请求的应用中，同步执行可能导致用户长时间等待，给用户带来不良的体验。异步编程可以在后台处理耗时操作，使得系统能够更快地响应用户请求。</li>
<li>资源利用率问题：同步执行时，如果一个线程在等待耗时操作完成期间空闲，资源得不到充分利用。异步编程可以在等待时释放线程，使其能够执行其他任务，提高了资源的利用率。</li>
</ol>
<p>以下是一个简单的Java代码例子，展示了如何使用异步编程（基于Java 8 CompletableFuture）进行网络请求的并发处理：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncExample</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">            <span class="comment">// 执行第一个网络请求</span></span><br><span class="line">            <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Result from Request 1"</span>;</span><br><span class="line">        }, executor);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">            <span class="comment">// 执行第二个网络请求</span></span><br><span class="line">            <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Result from Request 2"</span>;</span><br><span class="line">        }, executor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步等待两个请求都完成</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; combinedFuture = CompletableFuture.allOf(future1, future2);</span><br><span class="line"></span><br><span class="line">        combinedFuture.thenRun(() -&gt; {</span><br><span class="line">            <span class="comment">// 当两个请求都完成时执行的操作</span></span><br><span class="line">            System.out.println(<span class="string">"Both requests completed."</span>);</span><br><span class="line">            System.out.println(<span class="string">"Result 1: "</span> + future1.join());</span><br><span class="line">            System.out.println(<span class="string">"Result 2: "</span> + future2.join());</span><br><span class="line">            <span class="comment">// 可以继续执行其他任务</span></span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>在上述代码中，我们使用<code>CompletableFuture</code>创建两个异步任务，分别模拟两个网络请求的耗时操作。然后，使用<code>CompletableFuture.allOf</code>等待两个任务都完成，然后执行后续操作。这样可以并发地处理多个网络请求，提高了程序的并发性能。</p>
<h2 id="什么是编程范式"><a href="#什么是编程范式" class="headerlink" title="什么是编程范式"></a>什么是编程范式</h2><p>编程范式是一种编程的方法论或编程的风格，它规定了程序员在解决问题时应遵循的原则和思维方式。不同的编程范式强调不同的概念、原则和思想，以实现特定的目标和效果。</p>
<ol>
<li>命令式编程范式：以算法为中心，通过编写一系列的命令来指导计算机执行任务。常见的命令式编程语言有C、Java等。</li>
<li>声明式编程范式：以描述问题的逻辑为中心，通过声明式语句来描述问题的解决方式，而不是直接指定计算机的执行步骤。常见的声明式编程范式包括函数式编程和逻辑编程。</li>
<li>函数式编程范式：将计算视为数学函数的求值过程，强调函数的纯粹性和不可变性。函数式编程语言如Haskell、Scala和Lisp属于这种范式。</li>
<li>面向对象编程范式：以对象为中心，将数据和操作封装在对象中，并通过对象之间的交互来解决问题。面向对象编程语言如Java、C++和Python属于这种范式。</li>
<li>面向过程编程范式：将程序看作是一系列的过程或函数，通过顺序执行这些过程来实现任务。C语言常用这种范式。</li>
<li>并发编程范式：用于处理并发和多线程编程的范式，例如使用锁、线程、消息传递等机制来实现并发任务。并发编程语言和框架如Java的并发包、Go和Erlang等属于这种范式。</li>
<li>泛型编程范式：通过参数化类型和抽象数据类型的概念，实现可重用和通用的代码。C++的模板和Java的泛型就是泛型编程的范式。</li>
</ol>
<h2 id="Spring-Bean-是什么"><a href="#Spring-Bean-是什么" class="headerlink" title="Spring Bean 是什么"></a>Spring Bean 是什么</h2><p>在Spring框架中，Bean是一个由Spring容器管理的对象。Bean代表了应用程序中的一个组件，它可以是一个实例化的类对象、一个配置的数据源、一个服务等。</p>
<p>Spring Bean的特点和作用包括：</p>
<ol>
<li>实例化和管理：Spring容器负责创建和管理Bean的生命周期，包括实例化、依赖注入、初始化、销毁等过程。</li>
<li>依赖注入：Spring容器通过依赖注入将Bean所需的依赖关系自动注入到Bean中，实现了松耦合和可测试性。</li>
<li>配置灵活性：Spring Bean的配置信息可以通过XML配置文件、注解或Java代码等方式进行定义和修改，提供了灵活的配置选项。</li>
<li>AOP支持：Spring框架提供了面向切面编程（AOP）的支持，可以在Bean中定义切面和通知，实现横切关注点的解耦和复用。</li>
<li>事务管理：Spring框架提供了事务管理的功能，可以通过配置将事务应用到Bean的方法中，实现数据的一致性和事务的管理。</li>
<li>生命周期管理：Spring容器管理Bean的生命周期，包括初始化方法和销毁方法的回调，可以通过配置自定义Bean的初始化和销毁逻辑。</li>
</ol>
<p>通过Spring Bean的管理和依赖注入，开发人员可以更加专注于业务逻辑的实现，而无需关注对象的创建和管理细节。同时，Spring Bean的配置灵活性也使得应用程序的组件可以方便地进行扩展和修改，提供了更好的可维护性和可测试性。</p>
<h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>RESTful是一种设计风格或架构风格，用于构建网络应用程序，特别是基于HTTP协议的Web服务。REST是Representational State Transfer的缩写，它强调将应用程序的功能以资源的形式进行建模，通过HTTP协议中的各种方法对资源进行操作和交互。</p>
<p>以下是RESTful的一些关键概念和原则：</p>
<ol>
<li>资源（Resource）：在RESTful架构中，所有的功能被视为资源，每个资源都可以通过一个唯一的URI进行标识，例如/users、/products等。</li>
<li>表述（Representation）：资源的表述是指资源的具体数据表示形式，可以是JSON、XML、HTML等。客户端可以通过HTTP方法（GET、POST、PUT、DELETE等）对资源的表述进行操作。</li>
<li>统一接口（Uniform Interface）：RESTful架构通过使用统一的接口规范，包括使用HTTP方法进行资源操作（GET、POST、PUT、DELETE）以及对资源的URI进行标识和访问。</li>
<li>状态无关（Stateless）：RESTful架构是无状态的，每个请求都包含了足够的信息，服务器不需要存储客户端的状态信息。</li>
<li>超媒体驱动（HATEOAS）：通过在响应中提供资源间的链接，客户端可以动态地发现和操作可用的资源，实现应用程序的自描述性和可扩展性。</li>
</ol>
<p>使用RESTful架构设计的Web服务具有良好的可扩展性、可维护性和松耦合性。它能够提供清晰的接口设计、灵活的资源交互方式和统一的状态管理，使得不同系统之间的通信更加简洁和高效。同时，RESTful架构也符合Web标准，能够充分利用HTTP协议的各种功能和特性。</p>
<h2 id="GET、POST、PUT、DELETE"><a href="#GET、POST、PUT、DELETE" class="headerlink" title="GET、POST、PUT、DELETE"></a>GET、POST、PUT、DELETE</h2><p>GET、POST、PUT和DELETE是HTTP协议中定义的常用请求方法，用于对服务器资源进行不同类型的操作。</p>
<ol>
<li><p>GET：用于从服务器获取资源，常用于获取数据。GET请求是幂等的，即多次执行相同的GET请求应该返回相同的结果，不应该对服务器产生副作用。GET请求的参数可以通过URL的查询字符串传递，也可以通过请求体传递（例如在RESTful API中使用JSON格式的请求体）。</p>
</li>
<li><p>POST：用于向服务器提交数据，常用于创建新的资源。POST请求不是幂等的，即多次执行相同的POST请求可能会创建多个资源。POST请求的参数通常包含在请求体中，用于传递需要提交的数据。</p>
</li>
<li><p>PUT：用于更新服务器上的资源，常用于更新已存在的资源。PUT请求是幂等的，即多次执行相同的PUT请求应该产生相同的结果。PUT请求通常需要提供完整的资源表示，即需要将所有的属性值都传递给服务器。</p>
</li>
<li><p>DELETE：用于删除服务器上的资源，常用于删除不再需要的资源。DELETE请求是幂等的，即多次执行相同的DELETE请求应该产生相同的结果。DELETE请求的URI通常包含要删除的资源的唯一标识，例如”/users/1”表示删除ID为1的用户。</p>
</li>
</ol>
<p>这些请求方法在RESTful API设计中起着重要的作用，它们定义了对资源的不同操作类型，使得客户端能够以统一和标准的方式与服务器进行交互。根据具体的应用场景和需求，选择合适的请求方法来进行资源操作。</p>
<h2 id="什么是BEAN"><a href="#什么是BEAN" class="headerlink" title="什么是BEAN"></a>什么是BEAN</h2><p>在计算机编程领域，”Bean”一词通常用于表示可重用的软件组件，特别是在Java编程语言中。在Java中，Bean是指符合一定规范的Java对象，它具有以下特征：</p>
<ol>
<li>具有私有的成员变量（属性）：Bean通常定义了一组私有的成员变量，用于存储对象的状态。</li>
<li>提供公共的访问方法：Bean通过公共的getter和setter方法，提供对成员变量的访问和修改。</li>
<li>符合JavaBean规范：JavaBean是一种特殊类型的Bean，它需要满足一些规范，如具有无参构造函数、实现可序列化接口等。</li>
</ol>
<p>Bean的概念旨在提供一种可重用和可组合的编程模型，通过封装对象的状态和行为，使得开发人员能够更加方便地进行代码复用和模块化开发。在Java中，Bean通常用于描述业务逻辑、数据模型、服务组件等，它们可以被其他代码引用和调用。</p>
<p>在Java的开发框架中，比如Spring框架，Bean是指由Spring容器管理的对象，它们通过配置文件或注解的方式进行声明和创建。Spring Bean具有生命周期管理、依赖注入等特性，可以被动态地创建、初始化、销毁，并通过容器进行管理和协调。Spring框架通过Bean的管理和依赖注入，实现了松耦合、可测试性和可扩展性，提供了强大的面向对象编程支持。</p>
<h2 id="什么是松耦合"><a href="#什么是松耦合" class="headerlink" title="什么是松耦合"></a>什么是松耦合</h2><p>松耦合（Loose coupling）是软件设计中的一个原则，用于描述模块或组件之间的关系。它指的是模块或组件之间的依赖关系应该尽量减少或降低，使得它们能够独立地进行修改、扩展和测试，而不会对其他模块或组件造成过大的影响。</p>
<p>松耦合的设计具有以下特点：</p>
<ol>
<li><p>低依赖性：模块之间的依赖应该尽量减少，避免直接依赖于具体的实现细节。模块之间的通信应该基于抽象接口或协议，而不是依赖具体的类或对象。</p>
</li>
<li><p>接口隔离：模块之间的接口应该是精简的，只包含必要的方法和属性，避免暴露不必要的细节。每个模块都应该有清晰的职责和接口定义，避免对其他模块的实现细节产生依赖。</p>
</li>
<li><p>解耦合：模块之间应该尽量解耦，即减少相互之间的直接关联性。通过中间层、消息传递、事件驱动等方式，实现模块之间的解耦，使得模块能够独立地进行修改和演化。</p>
</li>
<li><p>可扩展性：松耦合的设计能够更好地支持系统的扩展和修改。当需要添加新的功能或模块时，可以通过新增模块、替换组件等方式进行扩展，而不会对其他模块产生较大的影响。</p>
</li>
</ol>
<p>通过实现松耦合的设计，可以提高系统的可维护性、可测试性和可扩展性。松耦合的模块更易于理解、修改和重用，同时也降低了代码之间的耦合度，使得系统更加灵活和可靠。</p>
<p>举个例子</p>
<p>假设我们有一个简单的订单管理系统，包含订单模块和库存模块。下面是一个例子来说明松耦合的概念：</p>
<p>在紧耦合的设计中，订单模块和库存模块可能直接依赖于彼此的实现细节，相互之间存在强耦合关系。例如，订单模块可能直接调用库存模块的方法来查询库存情况，并根据库存数量进行一些处理。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderModule</span> {</span><br><span class="line">    <span class="keyword">private</span> InventoryModule inventory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderModule</span><span class="params">()</span> {</span><br><span class="line">        inventory = <span class="keyword">new</span> <span class="title class_">InventoryModule</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Order order)</span> {</span><br><span class="line">        <span class="comment">// 获取库存数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> inventory.getQuantity(order.getProduct());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据库存情况进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (quantity &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 下单逻辑...</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 库存不足逻辑...</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，订单模块直接依赖于库存模块的实现，并且直接调用了库存模块的方法。这种紧耦合的设计存在以下问题：</p>
<ul>
<li>当库存模块的实现发生变化时，订单模块也需要相应地进行修改。</li>
<li>难以对订单模块和库存模块进行单独的测试，因为它们之间的关联性很高。</li>
</ul>
<p>相反，在松耦合的设计中，订单模块和库存模块之间通过接口进行通信，彼此之间不存在直接的依赖关系。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InventoryService</span> {</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getQuantity</span><span class="params">(String product)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderModule</span> {</span><br><span class="line">    <span class="keyword">private</span> InventoryService inventory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderModule</span><span class="params">(InventoryService inventory)</span> {</span><br><span class="line">        <span class="built_in">this</span>.inventory = inventory;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Order order)</span> {</span><br><span class="line">        <span class="comment">// 获取库存数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> inventory.getQuantity(order.getProduct());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据库存情况进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (quantity &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 下单逻辑...</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 库存不足逻辑...</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，订单模块通过依赖注入的方式获取库存模块的实现，而不是直接实例化库存模块。这种松耦合的设计带来了以下好处：</p>
<ul>
<li>订单模块和库存模块之间解耦，它们可以独立地进行修改和扩展。</li>
<li>可以通过实现不同的<code>InventoryService</code>接口来切换不同的库存服务，而不会对订单模块的实现造成影响。</li>
<li>可以更方便地对订单模块和库存模块进行单独的测试，因为它们之间的关联性降低。</li>
</ul>
<p>这个例子展示了松耦合设计的思想，通过接口抽象和依赖注入等方式，实现了模块之间的解耦，提高了系统的可维护性和扩展性。</p>
<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务（Transaction）是指一组数据库操作组成的逻辑单位，它要么全部执行成功，要么全部失败回滚。事务具有以下特性，通常被称为 ACID 特性：</p>
<ol>
<li><p>原子性（Atomicity）：事务中的操作要么全部执行成功，要么全部失败回滚，不存在部分执行的情况。如果事务中的任意操作失败，系统将撤销已经执行的操作，回滚到事务开始前的状态。</p>
</li>
<li><p>一致性（Consistency）：事务执行前和执行后，数据库的完整性约束没有被破坏。即使事务中的操作可能改变数据库中的数据状态，但是这些变化必须满足预定义的规则，确保数据库的一致性。</p>
</li>
<li><p>隔离性（Isolation）：并发执行的事务之间相互隔离，一个事务的执行不应该影响其他事务的结果。每个事务都应该感觉到自己是在独占地使用数据库，不会被其他事务干扰。</p>
</li>
<li><p>持久性（Durability）：一旦事务提交成功，其结果应该持久保存在数据库中，并且对于系统故障或崩溃的情况下也能够恢复。持久性保证了事务的结果不会因为系统故障而丢失。</p>
</li>
</ol>
<p>事务通常通过以下四个关键操作来管理：</p>
<ol>
<li><p>开始事务（BEGIN）：标记事务的开始，事务中的操作将被记录并可以进行回滚。</p>
</li>
<li><p>提交事务（COMMIT）：将事务中的操作应用到数据库，并使其成为永久性的更改。</p>
</li>
<li><p>回滚事务（ROLLBACK）：撤销事务中的操作，将数据库恢复到事务开始前的状态。</p>
</li>
<li><p>设置保存点（SAVEPOINT）：在事务中设置一个保存点，可以在回滚时将事务回滚到该保存点之前的状态。</p>
</li>
</ol>
<p>事务的使用可以确保数据库操作的一致性和完整性，特别是在并发环境下，可以避免数据的混乱和冲突。常见的数据库管理系统如 MySQL、Oracle、PostgreSQL 等都支持事务的概念和相关操作。在应用开发中，事务的正确使用可以保证数据的可靠性和一致性。</p>
<h2 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h2><p>分布式（Distributed）是指在多台计算机或多个节点上协同工作的系统或应用程序。在分布式系统中，多个计算节点通过网络相互连接，共同完成任务或提供服务，形成一个整体。</p>
<p>分布式系统的设计目标通常包括以下几个方面：</p>
<ol>
<li><p>可扩展性：能够方便地增加或减少计算节点，以应对负载的变化，实现水平扩展。</p>
</li>
<li><p>高可用性：通过冗余和故障转移机制，保证系统在部分节点或组件故障的情况下仍然可用。</p>
</li>
<li><p>容错性：分布式系统能够容忍节点或组件的故障，并且能够自动进行故障恢复。</p>
</li>
<li><p>性能：利用分布式计算资源，提高系统的计算、存储和网络性能。</p>
</li>
<li><p>数据一致性：在分布式环境下，保证数据在不同节点之间的一致性，避免数据的冲突和不一致。</p>
</li>
</ol>
<p>分布式系统面临的挑战和问题包括：</p>
<ol>
<li><p>通信和网络延迟：分布式系统依赖于网络进行节点之间的通信，网络延迟和不可靠性可能会影响系统的性能和可靠性。</p>
</li>
<li><p>数据一致性：在分布式环境下，多个节点可能并发地读写数据，需要采取合适的机制来保证数据的一致性。</p>
</li>
<li><p>并发控制：多个节点并发地进行计算和操作，需要解决并发访问共享资源的冲突问题。</p>
</li>
<li><p>故障处理：分布式系统中的节点可能会发生故障，需要采取故障检测和故障转移机制来保证系统的可用性。</p>
</li>
</ol>
<p>常见的分布式系统包括分布式数据库系统、分布式文件系统、分布式缓存系统等。分布式系统的设计和实现涉及到分布式算法、一致性协议、负载均衡、故障恢复等技术。分布式系统的优势在于提供高性能、可伸缩性和可靠性，但也增加了系统设计和管理的复杂性。</p>
<h2 id="分布式数据库系统、分布式文件系统、分布式缓存系统"><a href="#分布式数据库系统、分布式文件系统、分布式缓存系统" class="headerlink" title="分布式数据库系统、分布式文件系统、分布式缓存系统"></a>分布式数据库系统、分布式文件系统、分布式缓存系统</h2><p>分布式数据库系统（Distributed Database System）是一种将数据存储和处理分布在多个计算节点上的数据库系统。它允许数据在多个节点之间进行分片存储，并提供分布式查询和事务处理能力。</p>
<p>分布式数据库系统的设计目标是提高数据的可扩展性、可用性和性能。它通常具有以下特点：</p>
<ol>
<li><p>数据分片：将数据划分为多个分片，每个分片存储在不同的节点上，实现数据的分布存储。分片可以按照不同的策略进行，如范围分片、哈希分片等。</p>
</li>
<li><p>数据复制：为了提高数据的可用性和容错性，分布式数据库系统通常会对数据进行复制，并将副本存储在多个节点上。数据的复制可以采用同步复制或异步复制的方式。</p>
</li>
<li><p>数据一致性：在分布式环境下，确保数据的一致性是一个重要的挑战。分布式数据库系统通常使用一致性协议和机制来解决数据一致性的问题，如基于副本的一致性协议、分布式事务协议等。</p>
</li>
<li><p>查询优化和路由：分布式数据库系统需要考虑将查询请求路由到合适的节点上进行处理，并进行查询优化，以提高查询性能。</p>
</li>
</ol>
<p>分布式文件系统（Distributed File System）是一种将文件数据存储在多个计算节点上的文件系统。它将文件划分为多个块（Block），并将块分布存储在不同的节点上，实现文件的分布式存储和访问。</p>
<p>分布式文件系统的设计目标是提供高可用性、可扩展性和容错性。它通常具有以下特点：</p>
<ol>
<li><p>数据分布和复制：文件数据被划分为多个块，并将块分布存储在多个节点上。为了提高可用性和容错性，文件块通常会进行多次复制，并存储在不同的节点上。</p>
</li>
<li><p>文件访问和路由：分布式文件系统提供文件访问接口，可以通过文件名或文件路径进行文件的读取和写入操作。文件系统需要考虑将文件访问请求路由到存储了相应块的节点上。</p>
</li>
<li><p>一致性和一致性协议：分布式文件系统需要考虑多个节点之间的数据一致性问题。通常使用一致性协议和副本管理策略来保证数据的一致性。</p>
</li>
</ol>
<p>分布式缓存系统（Distributed Cache System）是一种将数据缓存分布在多个计算节点上的缓存系统。它通过在节点上存储一部分热点数据，以提高数据访问的性能和响应速度。</p>
<p>分布式缓存系统的设计目标是提供高速的数据访问和低延迟。它通常具有以下特点：</p>
<ol>
<li><p>数据分片和路由：缓存数据被分片存储在多个节点上，根据数据的键（Key）进行路由和访问。这样可以将缓存数据均匀分布在多个节点上，避免单个节点的负载过高。</p>
</li>
<li><p>缓存更新和失效：分布式缓存系统需要考虑缓存数据的更新和失效问题。当数据发生变化时，需要及时更新缓存数据；当数据过期或失效时，需要从后端数据源重新加载数据。</p>
</li>
<li><p>缓存一致性：在分布式缓存系统中，多个节点上的缓存数据需要保持一致。通常使用缓存一致性协议和缓存失效策略来解决数据一致性的问题。</p>
</li>
</ol>
<p>这些分布式系统在大规模、高并发的应用场景中发挥着重要作用，提供了可扩展性、高可用性和性能等方面的优势。它们的设计和实现涉及到分布式算法、一致性协议、数据分片和复制、负载均衡等技术。</p>
<h2 id="希尔排序，c"><a href="#希尔排序，c" class="headerlink" title="希尔排序，c++"></a>希尔排序，c++</h2><p>下面是一个使用C++实现的希尔排序算法示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希尔排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// 定义步长序列</span></span><br><span class="line">    <span class="type">int</span> gap = n / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每个步长进行插入排序</span></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) {</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在当前步长下进行插入排序</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp) {</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新步长</span></span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> arr[] = {<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>};</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"排序前的数组: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">shellSort</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"排序后的数组: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="CPU三级缓存的作用如下："><a href="#CPU三级缓存的作用如下：" class="headerlink" title="CPU三级缓存的作用如下："></a>CPU三级缓存的作用如下：</h2><ul>
<li>第一级缓存（L1 Cache）：位于CPU内部，与CPU核心紧密相连，速度最快。用于存储最常用的数据和指令。</li>
<li>第二级缓存（L2 Cache）：位于CPU内部，较大容量，速度较快。用于存储CPU频繁访问但不在L1 Cache中的数据和指令。</li>
<li>第三级缓存（L3 Cache）：位于CPU外部，容量更大，速度较慢。用于存储CPU访问次数较少但仍然需要快速访问的数据和指令。</li>
</ul>
<p>CPU缓存的目的是提高CPU的数据访问速度，通过将常用的数据和指令存储在高速缓存中，减少了对主内存的访问次数，从而加快程序的执行速度。</p>
<h2 id="进程和线程的区别："><a href="#进程和线程的区别：" class="headerlink" title="进程和线程的区别："></a>进程和线程的区别：</h2><ul>
<li>进程是程序的执行实例，是操作系统进行资源分配和调度的基本单位。每个进程都拥有独立的内存空间，包括代码、数据和堆栈等。</li>
<li>线程是进程的执行单元，一个进程可以包含多个线程。线程共享进程的内存空间，包括代码、数据和堆栈等，因此线程之间的数据共享较为方便。</li>
</ul>
<p>进程间通信的方式包括管道、信号量、共享内存、消息队列等。</p>
<blockquote>
<p>HTTP长连接的实现是通过在一个TCP连接上进行多次HTTP请求和响应，而不是每次请求都建立和关闭一次TCP连接。在HTTP请求头中使用<code>Connection: keep-alive</code>来表示使用长连接。</p>
</blockquote>
<blockquote>
<p>GET和POST是HTTP协议中的两种常见请求方法：</p>
</blockquote>
<ul>
<li>GET请求用于获取资源，参数通过URL的查询字符串传递，有长度限制，一般用于查询数据。</li>
<li>POST请求用于提交数据，参数通过请求体传递，没有长度限制，一般用于提交表单数据或上传文件。</li>
</ul>
<p>如果GET请求的参数过长，可以将参数放在请求体中进行POST请求，或者使用分段请求等方式将参数拆分为多个请求。</p>
<h2 id="用户态和内核态是CPU执行指令时的两种工作模式："><a href="#用户态和内核态是CPU执行指令时的两种工作模式：" class="headerlink" title="用户态和内核态是CPU执行指令时的两种工作模式："></a>用户态和内核态是CPU执行指令时的两种工作模式：</h2><ul>
<li>用户态：程序运行在用户空间，只能访问受限资源，无法直接访问硬件和操作系统内核。</li>
<li>内核态：操作系统运行在内核空间，可以访问系统的所有资源和硬件。</li>
</ul>
<p>Java线程属于用户态，因为Java虚拟机（JVM）是运行在用户空间的，Java线程的调度和管理是由JVM负责的。</p>
<p>读写并发可以通过使用锁机制（如读写锁）或使用线程安全的数据结构来实现。读操作可以并发执行，写操作需要互斥进行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/11/24/afuwWrsYMg7xDiR.jpg"></p>
<ol start="6">
<li><p>Java常见的集合类包括ArrayList、LinkedList、HashMap、HashSet等。线程安全的Map有ConcurrentHashMap。</p>
</li>
<li><p>锁的实现方式包括悲观锁和乐观锁。公平锁和非公平锁是悲观锁的两种实现方式：</p>
<ul>
<li>公平锁：按照申请锁的顺序来获取锁，遵循先来先得的原则。</li>
<li>非公平锁：不保证按照申请锁的顺序来获取锁，允许插队。</li>
</ul>
<p>公平锁的优点是保证了资源的公平性，缺点是可能导致线程频繁切换。非公平锁的优点是效率较高，缺点是可能会导致某些线程长时间无法获取锁。</p>
</li>
<li><p>CAS（Compare and Swap）是一种无锁算法，用于实现多线程环境下的原子操作。CAS操作包括读取一个内存位置的值、比较该值与预期值、根据比较结果来更新内存位置的值。</p>
<p>CAS的优点是无锁、高效，可以避免线程的切换和阻塞等开销。缺点是当多个线程同时执行CAS操作时，只有一个线程能成功，其他线程需要重新尝试，可能导致性能下降。</p>
<p>CAS的缺点可以通过使用自旋锁或者将CAS操作转化为有锁的操作来解决。</p>
</li>
<li><p>线程池的核心参数包括线程池大小、核心线程数、最大线程数、线程空闲时间等。线程池的大小决定了可以同时执行的任务数量，核心线程数是线程池中保持活动状态的线程数，最大线程数是线程池中允许存在的最大线程数，线程空闲时间是线程在无任务可执行时保持活动状态的时间。</p>
</li>
<li><p>JVM的类加载过程包括加载、验证、准备、解析和初始化五个阶段。加载阶段将类的字节码加载到内存中，验证阶段验证字节码的正确性，准备阶段为类的静态变量分配内存并初始化默认值，解析阶段将符号引用转换为直接引用，初始化阶段执行类的初始化代码，包括静态变量的赋值和静态代码块的执行。</p>
</li>
<li><p>聚簇索引是将数据行存储在磁盘上物理上相邻的位置，非聚簇索引是将索引项存储在磁盘上物理上相邻的位置。为了避免</p>
</li>
</ol>
<p>回表查找，可以将需要的列都包含在索引中，这样就可以通过索引直接获取所需数据，而不需要再次访问表。</p>
<ol start="12">
<li><p>最左匹配指的是在查询条件中使用多列索引时，索引列的顺序对查询的效率有影响，查询条件中使用的索引列的顺序要与索引定义的列的顺序一致，才能发挥最佳的索引效果。行锁是数据库中的锁机制，用于保证并发操作的一致性和数据的完整性。</p>
</li>
<li><p>常见的事务隔离级别有读未提交、读已提交、可重复读和串行化。在生产环境中一般使用读已提交（Read Committed）隔离级别。事务隔离级别的选择会影响并发性能和数据的一致性。</p>
</li>
<li><p>Redis常用的数据结构有字符串（String）、哈希表（Hash）、列表（List）、集合（Set）和有序集合（Sorted Set）。排行榜可以使用有序集合来实现，将每个成员作为排名对象，分数作为排名标准。</p>
</li>
<li><p>缓存穿透是指缓存和数据库中都没有需要的数据，导致每次请求都穿透缓存访问数据库，解决方式可以使用布隆过滤器过滤不存在的数据。缓存击穿是指某个热点数据失效，导致大量请求同时访问数据库，解决方式可以使用互斥锁或者设置短暂的缓存过期时间。缓存雪崩是指大量缓存同时失效，导致所有请求都直接访问数据库，解决方式可以设置随机的缓存过期时间或使用分布式缓存方案。</p>
</li>
<li><p>在项目中最有收获的地方可以是技术的成长、解决复杂问题的经验、与团队合作的能力提升等。</p>
</li>
<li><p>订单多次创建可能导致幂等性问题，即多次创建的结果不一致。可以通过在创建订单时使用唯一标识符（如订单号）来确保幂等性，当重复创建时，检查该标识符是否已存在，如果已存在则不执行重复创建操作。</p>
</li>
</ol>
<h2 id="什么是mysql的索引"><a href="#什么是mysql的索引" class="headerlink" title="什么是mysql的索引"></a>什么是mysql的索引</h2><p>MySQL的索引是一种数据结构，用于提高数据库查询操作的效率。索引是在表中某一列或多列上创建的，它们包含了对数据行的引用，以便可以快速定位到满足特定条件的数据行。</p>
<p>MySQL的索引可以分为以下几种类型：</p>
<ol>
<li><p>主键索引（Primary Key Index）：用于唯一标识表中的每一行数据。主键索引在创建表时可以指定，如果没有显式指定，则会自动创建一个隐藏的主键索引。</p>
</li>
<li><p>唯一索引（Unique Index）：用于保证索引列的值在表中是唯一的。唯一索引可以包含空值，但每个非空值只能出现一次。</p>
</li>
<li><p>普通索引（Normal Index）：也称为非唯一索引，用于加快查询速度。多个行可以具有相同的索引值。</p>
</li>
<li><p>全文索引（Full-text Index）：用于在文本数据上执行全文搜索。全文索引适用于大量文本内容的查询，支持关键词搜索和自然语言搜索。</p>
</li>
<li><p>组合索引（Composite Index）：由多个列组合而成的索引，用于加快多列条件查询的速度。组合索引的顺序很重要，根据查询的列顺序来决定是否能够有效使用索引。</p>
</li>
</ol>
<p>索引可以提高查询的速度，因为它们可以减少需要扫描的数据量。然而，索引也会增加数据插入、更新和删除的成本，因为每次修改数据时都需要更新索引。因此，在设计数据库时，需要根据查询的频率和更新的频率来合理地选择索引，以平衡查询性能和数据维护的开销。</p>
<h2 id="有序集合（Sorted-Set）"><a href="#有序集合（Sorted-Set）" class="headerlink" title="有序集合（Sorted Set）"></a>有序集合（Sorted Set）</h2><p>有序集合（Sorted Set）是Redis中的一种数据结构，它类似于集合（Set），但每个元素都关联着一个”分数”（score），通过分数的排序可以将元素按照一定顺序进行存储和访问。</p>
<p>有序集合的特点包括：</p>
<ol>
<li><p>元素的唯一性：每个元素在有序集合中是唯一的，不会存在重复元素。</p>
</li>
<li><p>元素的排序：每个元素都有一个关联的分数，通过分数进行排序。分数可以是浮点数或整数，根据分数的值来决定元素的顺序。</p>
</li>
<li><p>快速的插入、删除和查找：有序集合使用了内部的数据结构（跳表和哈希表）来实现高效的插入、删除和查找操作。</p>
</li>
</ol>
<p>有序集合在实际应用中有广泛的用途，例如：</p>
<ul>
<li><p>排行榜：可以使用有序集合来存储用户的得分，并根据得分进行排名和排序。</p>
</li>
<li><p>计数器：可以使用有序集合来存储计数器的值，每次增减操作都可以更新对应元素的分数。</p>
</li>
<li><p>范围查找：可以根据分数的范围进行查找操作，快速找到满足条件的元素。</p>
</li>
<li><p>任务调度：可以使用有序集合来存储任务的执行时间，按照时间顺序获取需要执行的任务。</p>
</li>
</ul>
<p>有序集合提供了一种灵活且高效的数据结构，能够满足多种场景下的排序和查找需求。在Redis中，可以使用一系列的命令对有序集合进行操作，如添加元素、删除元素、按照分数范围查找等。</p>
<h2 id="底层是什么"><a href="#底层是什么" class="headerlink" title="底层是什么"></a>底层是什么</h2><p>在Redis中，有序集合（Sorted Set）的底层数据结构是一个叫做”跳跃表”（Skip List）的数据结构。跳跃表是一种有序的数据结构，通过在普通链表的基础上添加多级索引，提供了快速的查找和插入操作。</p>
<p>跳跃表的特点包括：</p>
<ol>
<li><p>有序性：跳跃表中的元素按照一定的顺序进行排列，可以根据元素的分数进行快速的有序查找。</p>
</li>
<li><p>多级索引：跳跃表通过添加多级索引来加速查找操作，索引层数越高，查找速度越快。每一层索引都是一个有序链表，其中每个节点保存了下一层索引的指针。</p>
</li>
<li><p>空间效率：跳跃表在维持有序性的同时，也要尽量减少额外的空间消耗。相比于平衡树等其他数据结构，跳跃表具有较好的空间效率。</p>
</li>
</ol>
<p>跳跃表是一种高效的数据结构，适用于需要有序性和快速查找的场景。在Redis中，有序集合使用跳跃表作为底层数据结构，使得有序集合具备了快速插入、删除和按分数范围查找的能力。</p>
<h2 id="怎么解决死锁"><a href="#怎么解决死锁" class="headerlink" title="怎么解决死锁"></a>怎么解决死锁</h2><p>死锁是多线程或多进程程序中常见的一个问题，它发生在两个或多个线程或进程相互等待对方释放资源的情况下，导致程序无法继续执行。解决死锁问题需要采取一些策略和技术，以下是一些常见的方法：</p>
<ol>
<li><p><strong>避免死锁</strong>：通过合理地设计系统和资源分配策略，避免进程或线程陷入死锁的状态。这可以通过合理的资源分配顺序、资源申请的限制和超时机制等来实现。</p>
</li>
<li><p><strong>使用资源分配图</strong>：通过绘制资源分配图，可以分析出哪些资源被哪些进程或线程占用，从而更好地了解可能导致死锁的情况。根据图中的信息，可以调整资源分配策略以避免死锁。</p>
</li>
<li><p><strong>引入超时机制</strong>：在等待资源时，引入超时机制，如果等待时间过长，可以放弃当前请求，释放已占用的资源，避免进程或线程一直等待而导致死锁。</p>
</li>
<li><p><strong>按序申请资源</strong>：确保进程或线程按照特定的顺序申请资源，避免出现循环等待的情况。</p>
</li>
<li><p><strong>使用资源分级</strong>：将资源划分为不同的等级，确保进程或线程只能按照一定顺序申请资源，避免相互等待。</p>
</li>
<li><p><strong>采用死锁检测和恢复机制</strong>：实现死锁检测算法，及时检测出死锁的发生，然后采取恢复措施，比如回退资源分配、终止部分进程等。</p>
</li>
<li><p><strong>精心规划资源释放策略</strong>：在申请资源后，规划好资源的释放策略，避免长时间持有资源而阻塞其他进程。</p>
</li>
<li><p><strong>使用同步原语</strong>：合理使用锁、信号量等同步原语，确保资源的访问是有序的，从而避免死锁。</p>
</li>
<li><p><strong>引入资源预约</strong>：资源预约机制可以使进程在申请资源之前提前预约所需资源，从而降低死锁的可能性。</p>
</li>
<li><p><strong>监控和报警系统</strong>：实现监控系统，及时发现死锁问题并触发警报，便于及时处理。</p>
</li>
</ol>
<p>解决死锁是一个复杂的问题，需要根据具体情况采取不同的策略和方法。在编写多线程或多进程程序时，需要充分考虑资源分配和释放的顺序，以及合理地设计同步机制，从而避免死锁问题的发生。</p>
<h2 id="MySQL的binlog和redolog如何保证一致性？"><a href="#MySQL的binlog和redolog如何保证一致性？" class="headerlink" title="MySQL的binlog和redolog如何保证一致性？"></a><strong>MySQL的binlog和redolog如何保证一致性？</strong></h2><ul>
<li>MySQL的binlog和redolog都是用于事务的持久化和恢复，但它们服务于不同的目的。Redo log是在事务提交前记录，以保证事务的持久性。Binlog记录的是逻辑日志，可以用于复制和恢复。</li>
<li>一致性是通过在事务提交前将操作记录到redo log，并在事务提交后再记录到binlog，来保证的。如果在提交前出现问题，MySQL可以通过redo log进行恢复。如果在提交后出现问题，binlog可以用于恢复。</li>
</ul>
<h2 id="类加载时class文件加载到JVM的什么区域？"><a href="#类加载时class文件加载到JVM的什么区域？" class="headerlink" title="类加载时class文件加载到JVM的什么区域？"></a><strong>类加载时class文件加载到JVM的什么区域？</strong></h2><ul>
<li>类加载时的class文件会加载到JVM的方法区（Metaspace）中。方法区存储类的结构信息、静态变量、常量池等。</li>
</ul>
<h2 id="父类加载器能访问子类加载器吗？反过来呢？"><a href="#父类加载器能访问子类加载器吗？反过来呢？" class="headerlink" title="父类加载器能访问子类加载器吗？反过来呢？"></a><strong>父类加载器能访问子类加载器吗？反过来呢？</strong></h2><ul>
<li>父类加载器可以访问子类加载器加载的类，但反过来是不行的。这是由类加载器的双亲委派模型所决定的。</li>
</ul>
<h2 id="父类怎么访问子类？"><a href="#父类怎么访问子类？" class="headerlink" title="父类怎么访问子类？"></a><strong>父类怎么访问子类？</strong></h2><ul>
<li>父类无法直接访问子类，因为子类可能在不同的类加载器命名空间中。如果需要进行类的转型操作，应该在具体使用的位置进行。</li>
</ul>
<blockquote>
<p> 抽奖系统设计题：怎么保证中奖者一定能收到奖品？考虑发奖失败的情况？高概率的热门奖品怎么处理？库存hotkey遇到超高并发怎么办？</p>
</blockquote>
<ul>
<li>这是一个比较复杂的设计问题，需要考虑分布式事务、消息队列等方案，以确保中奖者能够收到奖品，同时保证系统的可用性和一致性。</li>
</ul>
<h2 id="synchronized实现底层？"><a href="#synchronized实现底层？" class="headerlink" title="synchronized实现底层？"></a><strong>synchronized实现底层？</strong></h2><ul>
<li><code>synchronized</code> 的实现底层是通过对象头中的标志位来实现的，当线程进入同步块时会尝试获取锁，如果锁已被其他线程占用，线程会被阻塞，直到锁被释放。</li>
</ul>
<h2 id="什么叫死锁？写出SQL模拟一个死锁。"><a href="#什么叫死锁？写出SQL模拟一个死锁。" class="headerlink" title="什么叫死锁？写出SQL模拟一个死锁。"></a><strong>什么叫死锁？写出SQL模拟一个死锁。</strong></h2><ul>
<li>死锁是指两个或多个进程（线程）在互相等待对方持有的资源，从而造成的一种僵局。例如：<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- Session 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> table1 <span class="keyword">SET</span> column1 <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Session 2</span></span><br><span class="line"><span class="keyword">UPDATE</span> table2 <span class="keyword">SET</span> column2 <span class="operator">=</span> <span class="number">2</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Session 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> table2 <span class="keyword">SET</span> column2 <span class="operator">=</span> <span class="number">2</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>; <span class="comment">-- 等待 table2 的锁</span></span><br><span class="line"><span class="comment">-- Session 2</span></span><br><span class="line"><span class="keyword">UPDATE</span> table1 <span class="keyword">SET</span> column1 <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 等待 table1 的锁</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="保证分布式一致性的所有方法？"><a href="#保证分布式一致性的所有方法？" class="headerlink" title="保证分布式一致性的所有方法？"></a><strong>保证分布式一致性的所有方法？</strong></h2><ul>
<li>一致性算法如 Paxos、Raft，分布式锁，分布式事务，消息队列，分布式数据存储等。</li>
</ul>
<h2 id="一条Java代码执行会发生什么，说得越底层越好。"><a href="#一条Java代码执行会发生什么，说得越底层越好。" class="headerlink" title="一条Java代码执行会发生什么，说得越底层越好。"></a><strong>一条Java代码执行会发生什么，说得越底层越好。</strong></h2><ul>
<li>一条Java代码的执行包括：编译为字节码、类加载、字节码解释、即时编译（JIT）等阶段。字节码解释和JIT编译会生成本地机器码，进而被CPU执行。</li>
</ul>
<h2 id="觉得设计模式的意义是什么，真的必要吗？"><a href="#觉得设计模式的意义是什么，真的必要吗？" class="headerlink" title="觉得设计模式的意义是什么，真的必要吗？"></a><strong>觉得设计模式的意义是什么，真的必要吗？</strong></h2><ul>
<li>设计模式是为了解决软件设计中的常见问题而提出的一些通用解决方案。在合适的情况下，设计模式可以使代码更具可读性、可维护性和扩展性，但并不是所有情况都需要使用设计模式。</li>
</ul>
<h2 id="容器部分面试题"><a href="#容器部分面试题" class="headerlink" title="容器部分面试题"></a>容器部分面试题</h2><h2 id="Java-容器都有哪些"><a href="#Java-容器都有哪些" class="headerlink" title="Java 容器都有哪些"></a>Java 容器都有哪些</h2><ol>
<li><p>Collection 的子类 List、Set</p>
</li>
<li><p>List 的子类 ArrayList、LinkedList等</p>
</li>
<li><p>Set 的子类 HashSet、TreeSet等</p>
</li>
<li><p>Map 的子类 HashMap、TreeMao等</p>
</li>
</ol>
<h2 id="Collecion-和-Collections-有什么区别"><a href="#Collecion-和-Collections-有什么区别" class="headerlink" title="Collecion 和 Collections 有什么区别"></a>Collecion 和 Collections 有什么区别</h2><blockquote>
<p> java.util.Collection 是一个集合的顶级接口，它提供了对集合对象进行基本操作的通用接口方法，Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口的有 List 和 Set</p>
</blockquote>
<blockquote>
<p>java.util.Collections 是一个包装类（工具类），它包含了各种有关集合操作的静态多态方法。此类不能被实例化，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于 Java 的 Collection 框架</p>
</blockquote>
<h2 id="List、Set、Map-之间的区别"><a href="#List、Set、Map-之间的区别" class="headerlink" title="List、Set、Map 之间的区别"></a>List、Set、Map 之间的区别</h2><ol>
<li>List、Set 都继承 Collection 接口，而 Map 则不是</li>
<li>List 是一个有序集合，元素可重复，可有多个NULL值。可以使用各种循环遍历集合，因为它是有序的</li>
<li>Set 是一个无序集合，元素不可重复，重复元素会被覆盖掉（注意：元素虽然无放入顺序，但元素在 Set 中的位置是由该元素的 HashCode 决定的，其位置是固定的，加入 Set 的 Object 必须定义 equals()方法），Set 只能用迭代，因为它是无序的</li>
<li>Map 是由一系列键值对组成的集合，提供了 key 和 value 的映射。在 Map 中保证 key 与 value 一 一对应的关系。一个 key 对应一个 value ，不能存在相同的 key，但 value 可以相同</li>
</ol>
<h2 id="Set-与-List-相比较"><a href="#Set-与-List-相比较" class="headerlink" title="Set 与 List 相比较"></a>Set 与 List 相比较</h2><ol>
<li>Set 检索元素效率较低，删除和插入效率高，因为删除和插入不会引起元素的位置变化</li>
<li>List 可动态增长，查找元素效率高，但是删除和插入效率低，因为删除或插入一条元素，会引起其他元素位置变化</li>
<li>Map 适合存储键值对的数据</li>
</ol>
<h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><ul>
<li><p><strong>继承关系：</strong></p>
<ul>
<li>HashTable 继承自 Dictionary 类。</li>
<li>HashMap 继承自 AbstractMap 类。</li>
</ul>
</li>
<li><p><strong>线程安全性：</strong></p>
<ul>
<li>HashMap 在缺省的情况下是非Synchronize的。</li>
<li>HashTable 的方法是Synchronize的。</li>
<li>在多线程下直接使用 HashTable 不需要自己为它的方法实现同步。但使用 HashMap 时需要手动增加同步处理，例如 <code>Map m = Collections.synchronizeMap(hashMap);</code>。</li>
</ul>
</li>
<li><p><strong>contains 方法：</strong></p>
<ul>
<li>HashMap 把 HashTable 的 contains() 方法去掉了，改成了 containsValue() 和 containsKey()。</li>
<li>HashTable 则保留了 contains()、containsValue()、containsKey() 三个方法，其中 contains() 与 containsValue() 功能相同。</li>
</ul>
</li>
<li><p><strong>null 值：</strong></p>
<ul>
<li>HashTable 中，key 和 value 都不能为 null 值。</li>
<li>HashMap 中，null 可以作为键，但这样的键只有一个。可以有多个 value 为 null 值的键。当 <code>get()</code> 方法返回 null 有可能是 HashMap 中没有该键，也有可能返回的 value 为 null。因此，HashMap 使用 <code>containsKey()</code> 方法判断是否存在键。</li>
</ul>
</li>
<li><p><strong>遍历方式：</strong></p>
<ul>
<li>HashTable 与 HashMap 都是使用 Iterator 迭代器遍历。</li>
<li>HashTable 还支持 Enumeration 的方式。</li>
</ul>
</li>
<li><p><strong>哈希值计算：</strong></p>
<ul>
<li>HashTable 直接使用对象的 HashCode。</li>
<li>HashMap 重新计算哈希值，先用 <code>hash &amp; 0x7FFFFFFF</code>，再对 length 取模。其中 <code>&amp;0x7FFFFFFF</code> 目的是为了将负的 hash 值转化为正值，因为 hash 值有可能为负数。</li>
</ul>
</li>
<li><p><strong>数组初始化和扩容方式：</strong></p>
<ul>
<li>HashTable 在不指定容量的情况下默认是 11。</li>
<li>HashMap 为默认容量 16。</li>
<li>HashTable 不要求底层数组的容量一定要是2的整数次幂，而 HashMap 底层数组则一定为 2 的整数次幂。</li>
<li>HashTable 扩容时，将容量变成原来的 2倍+1 （old * 2 + 1）。</li>
<li>HashMap 扩容时直接将容量改为原来的 2倍 （old * 2）。</li>
</ul>
</li>
</ul>
<p><strong>如何决定使用 HashMap 还是 TreeMap</strong></p>
<p>如果需要得到一个有序的 Map 集合，就应该使用 TreeMap，因为 HashMap 的排序顺序不是固定的。除此之外，在不需要使用排序的情况下，由于 HashMap 有比 TreeMap 更好的性能，使用 HashMap 会更好。</p>
<p><strong>HashMap 的实现原理</strong></p>
<p>HashMap 的实现原理基于以下过程：</p>
<ol>
<li>利用 key 的 hashCode 重新 hash 计算出当前对象的元素在数组中的下标。</li>
<li>存储时，如果出现 hash 值相同的 key，有两种情况：<ul>
<li>如果 key 相同，则覆盖原始值。</li>
<li>如果 key 不同（出现冲突），则将当前的 key-value 放入链表中。</li>
</ul>
</li>
<li>获取时，直接找到 hash 值对应的下标，进一步判断 key 是否相同，从而找到对应值。</li>
</ol>
<p>HashMap 解决 hash 冲突的核心在于使用了数组的存储方式，将冲突的 key 的对象放入链表中。一旦发现冲突，就在链表中进行进一步的对比。</p>
<p><strong>HashSet 的实现原理</strong></p>
<p>HashSet 实际上是一个 HashMap 实例，都是一个存放链表的数组。它不保证存储元素的迭代顺序，允许使用 null 元素。HashSet 中不允许有重复元素。</p>
<p>HashSet 中的 add() 方法调用的是底层 HashMap 中的 put() 方法。HashSet 判断元素是否存在的依据是 HashSet 中的元素都存放在 HashMap 的 key 上面，而 value 中的值都是统一的一个固定对象。在 HashSet 中，由于 value 值没有用，不存在修改 value 值的说法。因此，往 HashSet 中添加元素时，首先判断元素（也就是 key）是否存在，如果不存在则插入，如果存在则不插入。</p>
<p>判断 key 是否存在要重写元素的类的 equals() 和 hashCode() 方法。向 Set 中添加对象时，首先调用此对象所在类的 hashCode() 方法，计算此对象的哈希值，决定了此对象在 Set 中存放的位置。如果此位置没有被存储对象，则直接存储；如果已有对象，则通过对象所在类的 equals() 比较两个对象是否相同，相同则不能被添加。</p>
<p><strong>ArrayList 与 LinkedList 的区别</strong></p>
<ul>
<li><code>ArrayList</code>是由动态数组构成，而<code>LinkedList</code>是由链表构成。</li>
<li><code>ArrayList</code>适用于经常查询的集合，因为<code>LinkedList</code>是线性存储方式，需要移动指针从前往后查找。</li>
<li><code>LinkedList</code>适用于新增和删除的集合，因为<code>ArrayList</code>是数组构成，删除某个值会对下标产生影响，需要进行数据的移动。</li>
<li><code>ArrayList</code>的自由度较低，需要手动设置固定的大小。操作方便，直接创建、添加对象、根据下标使用。</li>
<li><code>LinkedList</code>的自由度较高，能够动态随数组的数据量而变化。</li>
<li><code>ArrayList</code>的主要开销在List需要预留一定空间。</li>
<li><code>LinkedList</code>的主要开销在需要存储节点信息以及节点指针信息。</li>
</ul>
<p><strong>如何实现数组与 List 之间的转换</strong></p>
<ul>
<li>List to Array: 使用List的<code>toArray()</code>方法，传入一个数组的类型，例如<code>String[] strs = strList.toArray(new String[strList.size()])</code>。</li>
<li>Array to List: 使用<code>java.util.Arrays</code>的<code>asList()</code>方法，例如<code>List&lt;String&gt; strList = Arrays.asList(strs)</code>。</li>
</ul>
<p><strong>ArrayList 与 Vector 的区别</strong></p>
<ul>
<li><code>ArrayList</code>是非线程安全的，而<code>Vector</code>使用了Synchronized来实现线程同步。</li>
<li><code>ArrayList</code>在性能方面优于<code>Vector</code>。</li>
<li><code>ArrayList</code>和<code>Vector</code>都会根据实际情况动态扩容，不同的是<code>ArrayList</code>扩容到原大小的1.5倍，而<code>Vector</code>扩容到原大小的2倍。</li>
</ul>
<p><strong>Array 与 ArrayList 的区别</strong></p>
<ul>
<li><code>Array</code>是数组，定义时必须指定数据类型和数组长度。</li>
<li><code>ArrayList</code>是动态数组，长度可以动态改变，会自动扩容。在不使用泛型的情况下，可以添加不同类型的元素。</li>
</ul>
<p><strong>在 Queue 中 poll() 与 remove() 有什么区别</strong></p>
<ul>
<li><code>poll()</code>和<code>remove()</code>都是从队列头删除一个元素。</li>
<li>如果队列为空，<code>remove()</code>方法会抛出<code>NoSuchElementException</code>异常，而<code>poll()</code>方法只会返回<code>null</code>。</li>
</ul>
<p><strong>哪些集合类是线程安全的</strong></p>
<ul>
<li><code>Vector</code>: 比<code>ArrayList</code>多了同步化机制，线程安全。</li>
<li><code>HashTable</code>: 比<code>HashMap</code>多了线程安全。</li>
<li><code>ConcurrentHashMap</code>: 高效且线程安全的集合。</li>
<li><code>Stack</code>: 栈，继承于<code>Vector</code>，也是线程安全。</li>
</ul>
<p><strong>迭代器 Iterator 是什么</strong></p>
<ul>
<li><code>Iterator</code>是集合专用的遍历方式。</li>
<li><code>Iterator&lt;E&gt; iterator()</code>: 返回此集合中元素的迭代器，通过集合的<code>iterator()</code>方法得到，所以<code>Iterator</code>是依赖于集合而存在的。</li>
</ul>
<p><strong>Iterator 怎么使用？有什么特点</strong></p>
<p><em>Iterator 的使用方法</em></p>
<ul>
<li><code>java.lang.Iterable</code> 接口被 <code>java.util.Collection</code> 接口继承，<code>java.util.Collection</code> 接口的 <code>iterator()</code> 方法返回一个 <code>Iterator</code> 对象。</li>
<li><code>next()</code> 方法获取集合中下一个元素。</li>
<li><code>hasNext()</code> 方法检查集合中是否还有元素。</li>
<li><code>remove()</code> 方法将迭代器新返回的元素删除。</li>
</ul>
<p><em>Iterator 的特点</em></p>
<ul>
<li><code>Iterator</code> 遍历集合过程中不允许线程对集合元素进行修改。</li>
<li><code>Iterator</code> 遍历集合过程中可以用<code>remove()</code>方法来移除元素，移除的元素是上一次<code>Iterator.next()</code>返回的元素。</li>
<li><code>Iterator</code> 的 <code>next()</code> 方法是通过游标指向的形式返回<code>Iterator</code>下一个元素。</li>
</ul>
<p><strong>Iterator 与 ListIterator 有什么区别</strong></p>
<ul>
<li>使用范围不同:<ul>
<li><code>Iterator</code> 适用于所有集合，<code>Set</code>、<code>List</code>、<code>Map</code> 以及这些集合的子类型，而 <code>ListIterator</code> 只适用于 <code>List</code> 及其子类型。</li>
</ul>
</li>
<li><code>ListIterator</code> 有 <code>add()</code> 方法，可以向 <code>List</code> 中添加元素，而 <code>Iterator</code> 不能。</li>
<li><code>ListIterator</code> 和 <code>Iterator</code> 都有 <code>hasNext()</code> 和 <code>next()</code> 方法，来实现顺序向后遍历。而 <code>ListIterator</code> 有 <code>hasPrevious()</code> 和 <code>previous()</code> 方法，可以实现逆向遍历，但是 <code>Iterator</code> 不能。</li>
<li><code>ListIterator</code> 可以使用 <code>nextIndex()</code> 和 <code>previousIndex()</code> 方法定位到当前索引位置，而 <code>Iterator</code> 不能。</li>
<li>它们都可以实现 <code>remove()</code> 删除操作，但是 <code>ListIterator</code> 可以使用 <code>set()</code> 方法实现对象修改，而 <code>Iterator</code> 不能。</li>
</ul>
<p><strong>怎么确保一个集合不能被修改</strong></p>
<ul>
<li>可以采用 <code>java.util.Collections</code> 工具类:<ul>
<li><code>Collections.unmodifiableMap(map)</code></li>
<li><code>Collections.unmodifiableList(list)</code></li>
<li><code>Collections.unmodifiableSet(set)</code></li>
</ul>
</li>
<li>如若修改则会报错<code>java.lang.UnsupportedOperationException</code>.</li>
</ul>
<h2 id="多线程部分面试题"><a href="#多线程部分面试题" class="headerlink" title="多线程部分面试题"></a>多线程部分面试题</h2><p><strong>并发和并行有什么区别</strong></p>
<ul>
<li><strong>并发：</strong> 不同的代码块交替执行。</li>
<li><strong>并行：</strong> 不同的代码块同时执行。</li>
</ul>
<p><em>个人理解</em></p>
<ul>
<li><strong>并发：</strong> 放下手头的任务A去执行另外一个任务B，执行完任务B后，再回来执行任务A。例如，吃饭时来电话了，去接电话，打完电话后又回来吃饭。</li>
<li><strong>并行：</strong> 执行A的同时，接受到任务B，然后一起执行。例如，吃饭时来电话了，一边吃饭一边打电话。</li>
</ul>
<p><strong>线程和进程的区别</strong></p>
<ul>
<li><strong>根本区别：</strong> 进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。</li>
<li>在操作系统中能同时运行多个进程，进程中会执行多个线程。</li>
<li>线程是操作系统能够进行运算调度的最小单位。</li>
</ul>
<p><strong>守护线程是什么</strong></p>
<ul>
<li><code>守护线程</code>是 JVM 内部的实现，如果运行的程序只剩下守护线程的话，程序将终止运行，直接结束。因此，守护线程是作为辅助线程存在的。</li>
</ul>
<p><strong>创建线程有哪几种方式</strong></p>
<ol>
<li><p><strong>继承 <code>Thread</code> 类创建线程类:</strong></p>
<ul>
<li>定义 <code>Thread</code> 类的子类，并重写该类的 <code>run()</code> 方法。</li>
<li>创建 <code>Thread</code> 子类的实例，即创建了线程对象。</li>
<li>调用线程对象的 <code>start()</code> 方法来启动该线程。</li>
</ul>
</li>
<li><p><strong>实现 <code>Runnable</code> 接口创建线程类:</strong></p>
<ul>
<li>创建 <code>Runnable</code> 接口的实现类，并重写该接口的 <code>run()</code> 方法。</li>
<li>创建 <code>Runnable</code> 实现类的实例，并依此实例作为 <code>Thread</code> 的 <code>target</code> 来创建 <code>Thread</code> 对象。</li>
<li>调用线程对象的 <code>start()</code> 方法来启动该线程。</li>
</ul>
</li>
<li><p><strong>通过 <code>Callable</code> 和 <code>Future</code> 创建线程:</strong></p>
<ul>
<li>创建 <code>Callable</code> 接口的实现类，并重写 <code>call()</code> 方法，该 <code>call()</code> 方法将作为线程执行体，并且有返回值。</li>
<li>创建 <code>Callable</code> 实现类的实例，使用 <code>FutureTask</code> 类来包装 <code>Callable</code> 对象，该 <code>FutureTask</code> 对象封装了该 <code>Callable</code> 对象的 <code>call()</code> 方法的返回值。</li>
<li>使用 <code>FutureTask</code> 对象作为 <code>Thread</code> 对象的 <code>target</code> 创建并启动新线程。</li>
<li>调用 <code>FutureTask</code> 对象的 <code>get()</code> 方法来获得子线程执行结束后的返回值。</li>
</ul>
</li>
</ol>
<p><strong>runnable 和 callable 有什么区别</strong></p>
<p><em>相同点:</em></p>
<ul>
<li>都是接口。</li>
<li>都可以编写多线程程序。</li>
<li>都是采用 <code>Thread.start()</code> 启动线程。</li>
</ul>
<p><em>不同点:</em></p>
<ul>
<li><code>Runnable</code> 没有返回值，<code>Callable</code> 可以返回执行结果，是个泛型，和 <code>Future</code>、<code>FutureTask</code> 配合可以用来获取异步执行的结果。</li>
<li><code>Callable</code> 接口的 <code>call()</code> 方法允许抛出异常，<code>Runnable</code> 的 <code>run()</code> 方法异常只能在内部消化，不能往上继续抛。</li>
<li>注意，<code>Callable</code> 接口支持返回执行结果，需要调用 <code>FutureTask.get()</code> 得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li>
</ul>
<p><strong>线程有哪些状态</strong></p>
<p>线程的生命周期包括以下状态：</p>
<ol>
<li><strong>新建（New）：</strong> 线程被创建但还未启动。</li>
<li><strong>就绪（Runnable）：</strong> 线程已经被创建，等待被系统调度执行。</li>
<li><strong>运行（Running）：</strong> 线程正在执行任务。</li>
<li><strong>阻塞（Blocked）：</strong> 线程被挂起，暂时停止执行。</li>
<li><strong>死亡（Dead）：</strong> 线程执行完任务或因异常退出。</li>
</ol>
<p><strong>sleep() 和 wait() 的区别</strong></p>
<ol>
<li><p><strong>sleep() 和 wait() 区别：</strong></p>
<ul>
<li>最大区别是 <code>sleep()</code> 休眠时不释放同步对象锁，其他线程无法访问；而 <code>wait()</code> 休眠时，释放同步对象锁，其他线程可以访问。</li>
<li><code>sleep()</code> 执行完后会自动恢复运行，不需要其他线程唤起；而 <code>wait()</code> 执行后会放弃对象的使用权，其他线程可以访问，需要其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 来唤醒或通知等待队列。</li>
</ul>
</li>
<li><p><strong>线程调度：</strong></p>
<ul>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态方法，属于线程类；而 <code>wait()</code> 是 <code>Object</code> 类的方法，属于对象。</li>
<li><code>sleep()</code> 可以在任何地方使用，而 <code>wait()</code> 必须在同步块或同步方法中使用。</li>
</ul>
</li>
</ol>
<p><strong>线程的 run() 和 start() 的区别</strong></p>
<ul>
<li><code>start()</code> 是用来启动线程的，调用后会执行线程的 <code>run()</code> 方法。</li>
<li><code>run()</code> 方法只是线程类中的一个普通方法，在主线程中执行。如果直接调用 <code>run()</code>，并不会启动新线程，而是在当前线程中执行。</li>
</ul>
<p><strong>notify() 和 notifyAll() 有什么区别</strong></p>
<ul>
<li><code>notify()</code> 方法随机唤醒对象的等待池中的一个线程，让其进入锁池。</li>
<li><code>notifyAll()</code> 唤醒对象的等待池中的所有线程，让它们进入锁池。</li>
</ul>
<p><strong>创建线程池有哪几种方式</strong></p>
<ol>
<li>利用 <code>Executors</code> 创建线程池：<ul>
<li><code>newCachedThreadPool()</code>：用于处理大量短时间工作任务的线程池。</li>
<li><code>newFixedThreadPool(int nThreads)</code>：重用指定数目 <code>nThreads</code> 的线程。</li>
<li><code>newSingleThreadExecutor()</code>：特点是工作线程数目限制为1。</li>
<li><code>newSingleThreadScheduledExecutor()</code> 和 <code>newScheduledThreadPool(int corePoolSize)</code>：创建 <code>ScheduledExecutorService</code>，可进行定时或周期性的工作调度。</li>
<li><code>newWorkStealingPool(int parallelism)</code>：使用 <code>Work-Stealing</code> 算法，并行地处理任务，不保证处理顺序。</li>
</ul>
</li>
</ol>
<p><strong>线程池的状态</strong></p>
<p>线程池的状态包括：</p>
<ul>
<li><strong>运行（RUNNING）：</strong> 线程池一旦被创建，就处于 RUNNING 状态，可以接收新任务，对已排队的任务进行处理。</li>
<li><strong>关闭（SHUTDOWN）：</strong> 不接收新任务，但能处理已排队的任务。通过调用线程池的 <code>shutdown()</code> 方法，线程池由 RUNNING 转变为 SHUTDOWN 状态。</li>
<li><strong>停止（STOP）：</strong> 不接收新任务，不处理已排队的任务，并中断正在处理的任务。通过调用线程池的 <code>shutdownNow()</code> 方法，线程池由（RUNNING 或 SHUTDOWN） 转变为 STOP 状态。</li>
<li><strong>整理（TIDYING）：</strong> 在 SHUTDOWN 状态下，任务数为 0，其他所有任务已终止，线程池会变为 TIDYING 状态，执行 <code>terminated()</code> 方法。</li>
<li><strong>终止（TERMINATED）：</strong> 线程池彻底终止，TIDYING 状态执行完 <code>terminated()</code> 方法后，会由 TIDYING 转变为 TERMINATED 状态。</li>
</ul>
<p><strong>线程池中的 submit() 和 execute() 有什么区别</strong></p>
<ul>
<li>这两个方法都可以向线程池提交任务。</li>
<li><code>execute()</code> 方法的返回类型是</li>
</ul>
<p> <code>void</code>，定义在 <code>Executor</code> 接口中。</p>
<ul>
<li><code>submit()</code> 方法可以返回持有计算结果的 <code>Future</code> 对象，定义在 <code>ExecutorService</code> 接口中。</li>
</ul>
<p><strong>在 Java 程序中怎么确保多线程运行安全</strong></p>
<p>确保多线程运行安全可以采用以下方式：</p>
<ol>
<li>使用 <code>synchronized</code> 关键字。</li>
<li>使用 <code>volatile</code> 关键字，防止指令重排，保证变量的可见性。</li>
<li>使用 <code>lock</code> 锁机制，<code>lock()</code> 和 <code>unlock()</code>。</li>
<li>使用线程安全的类，如 <code>StringBuffer</code>、<code>HashTable</code>、<code>Vector</code> 等。</li>
<li>线程安全问题主要涉及原子性、可见性、有序性。</li>
</ol>
<p><strong><code>synchronized</code> 和 <code>volatile</code> 的作用是什么？有什么区别</strong></p>
<ul>
<li><p><strong>作用：</strong></p>
<ul>
<li><code>synchronized</code> 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</li>
<li><code>volatile</code> 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性，禁止指令重排序。</li>
</ul>
</li>
<li><p><strong>区别：</strong></p>
<ul>
<li><code>synchronized</code> 可以作用于变量、方法、对象。<code>volatile</code> 只能作用于变量。</li>
<li><code>synchronized</code> 可以保证线程间的有序性、原子性和可见性。<code>volatile</code> 只保证了可见性和有序性，无法保证原子性。</li>
<li><code>synchronized</code> 线程阻塞，<code>volatile</code> 线程不阻塞。</li>
</ul>
</li>
</ul>
<p><strong><code>synchronized</code> 和 <code>Lock</code> 有什么区别</strong></p>
<ul>
<li><code>synchronized</code> 是一个 Java 关键字，在 JVM 层面上，而 <code>Lock</code> 是一个类。</li>
<li><code>synchronized</code> 以获取锁的线程执行完同步代码，释放锁；如果线程中发生异常，JVM 会让线程释放锁。而 <code>Lock</code> 必须在 <code>finally</code> 中释放锁，否则容易造成线程死锁。</li>
<li><code>Lock</code> 可以查看锁的状态，而 <code>synchronized</code> 不能。</li>
<li>在性能上，如果竞争资源不激烈，两者性能差不多；而当竞争资源非常激烈时，<code>Lock</code> 的性能要优于 <code>synchronized</code>。同时，<code>Lock</code> 是可公平锁，而 <code>synchronized</code> 是非公平锁。</li>
</ul>
<h2 id="Spring-自动装配-bean-有哪些方式"><a href="#Spring-自动装配-bean-有哪些方式" class="headerlink" title="Spring 自动装配 bean 有哪些方式"></a>Spring 自动装配 bean 有哪些方式</h2><ul>
<li>default：默认方式和‘no’效果一样</li>
<li>no：不自动配置，需要使用 节点或参数</li>
<li>byName：根据名称进行装配</li>
<li>byType：根据类型进行装配</li>
<li>constructor：根据构造函数进行装配</li>
</ul>
<h2 id="Spring-事务实现方式有哪些"><a href="#Spring-事务实现方式有哪些" class="headerlink" title="Spring 事务实现方式有哪些"></a>Spring 事务实现方式有哪些</h2><ol>
<li>编程式事务管理：对基于 POJO 的应用来说是唯一选择，需要在代码中调用 <code>beginTransaction()</code>、<code>commit()</code>、<code>rollback()</code>等事务管理相关的方法。</li>
<li>基于 <code>TransactionProxyFactoryBean</code> 的声明式事务管理。</li>
<li>基于 <code>@Transactional</code> 的声明式事务管理。</li>
<li>基于 Aspectj AOP 配置事务。</li>
</ol>
<h2 id="Spring-的事务隔离是什么"><a href="#Spring-的事务隔离是什么" class="headerlink" title="Spring 的事务隔离是什么"></a>Spring 的事务隔离是什么</h2><p>Spring 的事务隔离是指多个事务并发执行时，事务之间的隔离程度。隔离级别包括：</p>
<ul>
<li>READ_UNCOMMITTED：最低的隔离级别，允许一个事务读取另一个事务未提交的数据。</li>
<li>READ_COMMITTED：保证一个事务提交后才能被另一个事务读取。</li>
<li>REPEATABLE_READ：确保一个事务在多次读取同一数据时，能够得到一致的结果，即不会出现脏读、不可重复读，但可能会出现幻读。</li>
<li>SERIALIZABLE：最高的隔离级别，完全禁止其他事务对当前事务的操作，保证事务的完整性。</li>
</ul>
<h2 id="Spring-Mvc-的运行流程"><a href="#Spring-Mvc-的运行流程" class="headerlink" title="Spring Mvc 的运行流程"></a>Spring Mvc 的运行流程</h2><ol>
<li>用户发送请求至前端控制器 DispatcherServlet。</li>
<li>DispatcherServlet 收到请求调用处理器映射器 HandlerMapping。</li>
<li>HandlerMapping 根据请求 URL 找到具体的处理器，生成处理器执行链 HandlerExecutionChain（包括处理器对象和处理器拦截器）一并返回给 DispatcherServlet。</li>
<li>DispatcherServlet 根据处理器 Handler 获取处理器适配器 HandlerAdapter 执行 HandlerAdapter 处理一系列的操作。</li>
<li>执行处理器 Handler（Controller，也叫页面控制器）。</li>
<li>Handler 执行完成返回 ModelAndView 到 HandlerAdapter。</li>
<li>HandlerAdapter 将 Handler 执行结果 ModelAndView 返回到 DispatcherServlet。</li>
<li>DispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器。</li>
<li>ViewResolver 解析后返回具体 View。</li>
<li>DispatcherServlet 对 View 进行渲染视图，即将模型数据 model 填充至视图中。</li>
<li>DispatcherServlet 响应用户。</li>
</ol>
<h2 id="Spring-Mvc-有哪些组件"><a href="#Spring-Mvc-有哪些组件" class="headerlink" title="Spring Mvc 有哪些组件"></a>Spring Mvc 有哪些组件</h2><ol>
<li>DispatcherServlet：前端控制器</li>
<li>HandlerMapping：处理器映射器</li>
<li>HandlerAdapter：处理器适配器</li>
<li>HandlerInterceptor：拦截器</li>
<li>ViewResolver：视图解析器</li>
<li>MultipartResolver：文件上传处理器</li>
<li>HandlerExceptionResolver：异常处理器</li>
<li>DataBinder：数据转换</li>
<li>HttpMessageConverter：消息转换器</li>
<li>FlashMapManager：页面跳转参数管理器</li>
<li>HandlerExecutionChain：处理程序执行链</li>
<li>RequestToViewNameTranslator：请求转视图翻译器</li>
<li>ThemeResolver</li>
<li>LocaleResolver：语言环境处理器</li>
</ol>
<h2 id="RequestMapping-的作用是什么"><a href="#RequestMapping-的作用是什么" class="headerlink" title="@RequestMapping 的作用是什么"></a>@RequestMapping 的作用是什么</h2><p><code>@RequestMapping</code> 是一个注解，用来标识 HTTP 请求地址与 Controller 类的方法之间的映射。它可以指定 HTTP 请求的类型，包括 GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS、TRACE。</p>
<h2 id="Autowired-与-Resource-的区别"><a href="#Autowired-与-Resource-的区别" class="headerlink" title="@Autowired 与 @Resource 的区别"></a>@Autowired 与 @Resource 的区别</h2><ul>
<li><code>@Autowired</code> 为 Spring 提供的注解，需要导入包 <code>org.springframework.beans.factory.annotation.Autowired</code>，采取的策略为按照类型注入。</li>
<li><code>@Resource</code> 注解由 J2EE 提供，需要导入包 <code>javax.annotation.Resource</code>，默认按照名称自动注入。</li>
</ul>
<h2 id="Mybatis-中-和-的区别"><a href="#Mybatis-中-和-的区别" class="headerlink" title="Mybatis 中 #{} 和 ${} 的区别"></a>Mybatis 中 #{} 和 ${} 的区别</h2><ul>
<li><code>#{}</code> 表示一个占位符，可以有效防止 SQL 注入。</li>
<li><code>${}</code> 表示拼接 SQL 串，可以用于动态判断字段。</li>
</ul>
<h2 id="Mybatis-有几种分页方式"><a href="#Mybatis-有几种分页方式" class="headerlink" title="Mybatis 有几种分页方式"></a>Mybatis 有几种分页方式</h2><ol>
<li>原始分页：取出数据后，进行手动分割。</li>
<li><code>LIMIT</code> 关键字：修改执行 SQL 语句。</li>
<li><code>RowBounds</code> 实现分页：将 <code>PageInfo</code> 信息封装成 <code>RowBounds</code>，调用 DAO 层方法。</li>
<li>Mybatis 的 Interceptor 实现：在 SQL 语句前加上 <code>limit</code> 关键字，不用手动添加。</li>
</ol>
<h2 id="Mybatis-一级缓存和二级缓存"><a href="#Mybatis-一级缓存和二级缓存" class="headerlink" title="Mybatis 一级缓存和二级缓存"></a>Mybatis 一级缓存和二级缓存</h2><ul>
<li>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，其生命周期与 SQLSession 一致。存在多个 SQLSession 或分布式环境中，可能会出现脏数据。</li>
<li>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，存储作用域为 Mapper 级别。可以由多个 SQLSession 共享缓存。</li>
</ul>
<h2 id="Mybatis-插件的实现原理"><a href="#Mybatis-插件的实现原理" class="headerlink" title="Mybatis 插件的实现原理"></a>Mybatis 插件的实现原理</h2><p>插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h2 id="数据库的三范式是什么"><a href="#数据库的三范式是什么" class="headerlink" title="数据库的三范式是什么"></a>数据库的三范式是什么</h2><ol>
<li>第一范式（1NF）：数据表中的每一列都是不可再分的原子数据项。</li>
<li>第二范式（2NF）：数据表中的非主键字段完全依赖于主键字段。</li>
<li>第三范式（3NF）：数据表中的非主键字段之间不存在函数依赖。</li>
</ol>
<h2 id="如何获取当前数据库的版本"><a href="#如何获取当前数据库的版本" class="headerlink" title="如何获取当前数据库的版本"></a>如何获取当前数据库的版本</h2><ul>
<li>进入 MySQL 输入 <code>select version();</code></li>
<li>进入 cmd 输入 <code>mysql -V</code></li>
</ul>
<p>以下是重新排版后的内容：</p>
<h2 id="ACID-是什么"><a href="#ACID-是什么" class="headerlink" title="ACID 是什么"></a>ACID 是什么</h2><p>ACID 是指在可靠数据库管理系统（DBMS）中，事务（transaction）应具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>
<ul>
<li><strong>原子性：</strong> 数据库中的事务执行是作为原子，要么执行整个语句，要么不执行。</li>
<li><strong>一致性：</strong> 在事务开始和结束后，数据库的完整性约束没有被破坏。</li>
<li><strong>隔离性：</strong> 事务的执行是互不干扰的，一个事务不可能看到其他事务运行时的中间某一时刻的数据。</li>
<li><strong>持久性：</strong> 在事务完成后，该事务对数据库所做的更改持久保存在数据库中，并不会被回滚。</li>
</ul>
<h2 id="char-和-varchar-的区别"><a href="#char-和-varchar-的区别" class="headerlink" title="char 和 varchar 的区别"></a>char 和 varchar 的区别</h2><ul>
<li><strong>长度不同：</strong><ul>
<li><code>char</code>：长度设置后不可变。</li>
<li><code>varchar</code>：长度可动态改变。</li>
</ul>
</li>
<li><strong>效率不同：</strong><ul>
<li><code>char</code>：每次修改的数据长度相同，效率更高。</li>
<li><code>varchar</code>：每次修改的数据长度不同，效率更低。</li>
</ul>
</li>
<li><strong>存储不同：</strong><ul>
<li><code>char</code>：存储时初始预计字符串再加上一个记录字符串长度的字节，占用空间较大。</li>
<li><code>varchar</code>：存储时是实际字符串再加上一个记录字符串长度的字节，占用空间较小。</li>
</ul>
</li>
</ul>
<h2 id="float-和-double-的区别"><a href="#float-和-double-的区别" class="headerlink" title="float 和 double 的区别"></a>float 和 double 的区别</h2><ul>
<li>在数据库中的所有计算都使用双精度完成，使用 <code>float</code>（单精度）会有误差，可能导致意想不到的结果。</li>
<li>MySQL浮点型和定点型可以用类型名称后加（M，D）来表示，其中 M 表示该值的总长度，D 表示小数点后面的长度。</li>
<li><code>FLOAT</code> 和 <code>DOUBLE</code> 在不指定精度时，默认按照实际的精度来显示，而 <code>DECIMAL</code> 在不指定精度时，默认整数为 10，小数为 0。</li>
</ul>
<h2 id="MySQL-内连接、左连接、右连接有什么区别"><a href="#MySQL-内连接、左连接、右连接有什么区别" class="headerlink" title="MySQL 内连接、左连接、右连接有什么区别"></a>MySQL 内连接、左连接、右连接有什么区别</h2><ul>
<li><strong>内连接 (<code>INNER JOIN ... ON</code>)：</strong> 只显示两表中有关联的数据。</li>
<li><strong>左连接 (<code>LEFT JOIN ... ON</code>)：</strong> 显示左表所有数据，右表没有对应的数据用 <code>NULL</code> 补齐，多了的数据删除。</li>
<li><strong>右连接 (<code>RIGHT JOIN ... ON</code>)：</strong> 显示右表所有数据，左表没有对应的数据用 <code>NULL</code> 对齐，多了的数据删除。</li>
</ul>
<h2 id="MySQL-的索引是怎么实现的"><a href="#MySQL-的索引是怎么实现的" class="headerlink" title="MySQL 的索引是怎么实现的"></a>MySQL 的索引是怎么实现的</h2><ul>
<li>由于B+Tree数据结构的优势，目前 MySQL 基本都采用 B+Tree 方式实现索引。</li>
<li>MySQL 索引实现的数据结构：两种存储引擎都使用 B+Tree（B-Tree的变种）作为索引结构。</li>
<li>在 MyISAM 中，索引叶子节点存放的是数据的地址；在 InnoDB 中，主键索引叶子节点存放的是数据本身，辅助索引叶子节点上存放的是主键值。</li>
</ul>
<h2 id="MySQL-索引设计原则"><a href="#MySQL-索引设计原则" class="headerlink" title="MySQL 索引设计原则"></a>MySQL 索引设计原则</h2><ul>
<li>适合索引的列是出现在 <code>WHERE</code> 子句中的列，或者连接子句中指定的列。</li>
<li>基数较小的列，索引效果较差，没有必要在此列建立索引。</li>
<li>使用短索引，对长字符串列进行索引时，应指定一个前缀长度以节省索引空间。</li>
<li>不要过度索引，因为索引会增加磁盘空间需求，并降低写操作性能。</li>
</ul>
<h2 id="如何验证-MySQL-的索引是否满足需求"><a href="#如何验证-MySQL-的索引是否满足需求" class="headerlink" title="如何验证 MySQL 的索引是否满足需求"></a>如何验证 MySQL 的索引是否满足需求</h2><ul>
<li>使用 <code>EXPLAIN</code> 函数验证索引是否有效。</li>
</ul>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul>
<li><strong>Read Uncommitted（读未提交）：</strong> 最低级别。</li>
<li><strong>Read Committed（读已提交）：</strong> 读已提交，可避免脏读情况发生。</li>
<li><strong>Repeatable Read（可重复读）：</strong> 确保事务可以多次从一个字段中读取相同的值，可以避免脏读和不可重复读，但仍会出现幻读问题。</li>
<li><strong>Serializable（串行化）：</strong> 最严格的事务隔离级别，要求所有事务被串行执行，可避免脏读、不可重复读、幻读情况的发生。</li>
</ul>
<h2 id="MySQL-常用的引擎"><a href="#MySQL-常用的引擎" class="headerlink" title="MySQL 常用的引擎"></a>MySQL 常用的引擎</h2><ul>
<li><code>InnoDB</code> 和 <code>MyISAM</code> 都使用 B+Tree 存储数据。</li>
<li><code>InnoDB</code> 支持事务，且支持四种隔离级别（读未提交、读已提交、可重复读、串行化），默认的为可重复读。</li>
<li><code>MyISAM</code> 只支持表锁，不支持事务，但由于有单独的索引文件，在读取数据方面性能较高。</li>
</ul>
<h2 id="MySQL-的行锁、表锁、页锁"><a href="#MySQL-的行锁、表锁、页锁" class="headerlink" title="MySQL 的行锁、表锁、页锁"></a>MySQL 的行锁、表锁、页锁</h2><ul>
<li><strong>行级锁：</strong> 锁定粒度最细，针对当前操作的行进行加锁，分为共享锁和排他锁。开销大，加锁慢，但锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li><strong>表级锁：</strong> 锁定粒度最大，对整张表加锁，分为表共享读锁和表独占写锁。开销小，加锁快，但锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li><strong>页级锁：</strong> 锁定粒度介于行级锁和表级锁之间，一次锁定相邻的一组记录。开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度一般。 MyISAM 和 MEMORY 采用表级锁，BDB 采用页面锁或表级锁（默认为页面锁），InnoDB 支持行级锁和表级锁，默认为行级锁。</li>
</ul>
<p>以下是重新排版后的内容：</p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p><strong>乐观锁：</strong></p>
<ul>
<li>认为数据不会经常冲突，检测冲突在数据提交时进行。</li>
<li>常见实现方式有版本号控制和时间戳控制。</li>
</ul>
<p><strong>悲观锁：</strong></p>
<ul>
<li>对数据被外界修改持保守态度，整个数据处理过程中将数据处于锁定状态。</li>
<li>实现通常依赖数据库提供的锁机制，例如 <code>SELECT ... FOR UPDATE</code>。</li>
</ul>
<h2 id="MySQL-问题排查手段"><a href="#MySQL-问题排查手段" class="headerlink" title="MySQL 问题排查手段"></a>MySQL 问题排查手段</h2><ol>
<li>使用 <code>SHOW PROCESSLIST</code> 命令查看当前所有连接信息。</li>
<li>使用 <code>EXPLAIN</code> 命令查询 SQL 语句执行计划。</li>
<li>开启慢查询日志，查看慢查询的 SQL。</li>
</ol>
<h2 id="MySQL-性能优化"><a href="#MySQL-性能优化" class="headerlink" title="MySQL 性能优化"></a>MySQL 性能优化</h2><ol>
<li>创建索引，避免全盘扫描，尤其在 <code>WHERE</code> 和 <code>ORDER BY</code> 涉及的列上创建索引。</li>
<li>避免在索引上使用计算，注意 <code>IN</code> 关键字不走索引。</li>
<li>使用预编译防止 SQL 注入。</li>
<li>将多条 SQL 语句压缩到一条中，避免使用 <code>*</code>，注意不要在 <code>WHERE</code> 条件中判断 <code>NULL</code>。</li>
<li>尽量不使用前置百分比的 <code>LIKE</code>。</li>
<li>对于连续的数值，使用 <code>BETWEEN</code> 而不是 <code>IN</code>。</li>
<li>选择正确的存储引擎。</li>
<li>考虑垂直/水平分割、分库分表、读写分离。</li>
</ol>
<h2 id="Redis-面试题"><a href="#Redis-面试题" class="headerlink" title="Redis 面试题"></a>Redis 面试题</h2><h3 id="Redis-是什么？"><a href="#Redis-是什么？" class="headerlink" title="Redis 是什么？"></a>Redis 是什么？</h3><ul>
<li>Redis是一个完全开源、用C语言编写的高性能(key/value)分布式内存数据库。</li>
<li>支持持久化，提供多种数据结构的存储。</li>
</ul>
<h3 id="Redis-的优点和使用场景"><a href="#Redis-的优点和使用场景" class="headerlink" title="Redis 的优点和使用场景"></a>Redis 的优点和使用场景</h3><p><strong>优点：</strong></p>
<ul>
<li>支持数据持久化。</li>
<li>提供多种数据结构的存储。</li>
<li>支持数据备份，如master-slave模式。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>内存存储和持久化。</li>
<li>取最新N个数据的操作。</li>
<li>发布、订阅消息系统。</li>
<li>定时器、计数器等。</li>
</ul>
<h3 id="为什么-Redis-是单线程的？"><a href="#为什么-Redis-是单线程的？" class="headerlink" title="为什么 Redis 是单线程的？"></a>为什么 Redis 是单线程的？</h3><ul>
<li>Redis基于内存操作，CPU不是瓶颈。</li>
<li>单线程实现简单，且不会使CPU成为瓶颈。</li>
</ul>
<h3 id="Redis-的缓存预热是什么，如何解决缓存雪崩和缓存穿透？"><a href="#Redis-的缓存预热是什么，如何解决缓存雪崩和缓存穿透？" class="headerlink" title="Redis 的缓存预热是什么，如何解决缓存雪崩和缓存穿透？"></a>Redis 的缓存预热是什么，如何解决缓存雪崩和缓存穿透？</h3><p><strong>缓存预热：</strong></p>
<ul>
<li>在项目启动前访问可能的数据，加载到缓存中。</li>
</ul>
<p><strong>缓存雪崩解决方案：</strong></p>
<ul>
<li>Redis高可用，搭建集群。</li>
<li>限流降级，每个key只能一个线程查询，其他线程等待。</li>
<li>数据预热，提前加载缓存。</li>
</ul>
<p><strong>缓存穿透解决方案：</strong></p>
<ul>
<li>缓存空对象，设置过期时间。</li>
<li>布隆过滤器。</li>
<li>数据预热。</li>
</ul>
<h3 id="Redis-支持的数据类型和Java客户端"><a href="#Redis-支持的数据类型和Java客户端" class="headerlink" title="Redis 支持的数据类型和Java客户端"></a>Redis 支持的数据类型和Java客户端</h3><ul>
<li>数据类型：String、List、Set、Hash、ZSet。</li>
<li>Java客户端：Redisson、Jedis、Lettuce。</li>
</ul>
<h3 id="Jedis-与-Redisson-的区别"><a href="#Jedis-与-Redisson-的区别" class="headerlink" title="Jedis 与 Redisson 的区别"></a>Jedis 与 Redisson 的区别</h3><ul>
<li>Jedis是简单的Redis客户端，Redisson封装了更多数据结构和功能。</li>
<li>Redisson相对更大更灵活，Jedis更原生和灵活。</li>
</ul>
<h3 id="如何保证缓存与数据库数据一致性？"><a href="#如何保证缓存与数据库数据一致性？" class="headerlink" title="如何保证缓存与数据库数据一致性？"></a>如何保证缓存与数据库数据一致性？</h3><ul>
<li>对删除缓存进行重试。</li>
<li>定期全量更新缓存。</li>
<li>给所有缓存设置失效期。</li>
</ul>
<h2 id="Redis-持久化方式"><a href="#Redis-持久化方式" class="headerlink" title="Redis 持久化方式"></a>Redis 持久化方式</h2><ol>
<li><p><strong>快照方式（RDB）：</strong></p>
<ul>
<li>内存数据定期写入磁盘。</li>
</ul>
</li>
<li><p><strong>文件追加方式（AOF）：</strong></p>
<ul>
<li>记录所有操作命令，以文本形式追加到文件。</li>
</ul>
</li>
<li><p><strong>混合持久化方式：</strong></p>
<ul>
<li>结合了RDB和AOF，先写入RDB形式，再追加AOF形式。提高Redis重启速度，减小数据丢失风险。</li>
</ul>
</li>
</ol>
<p>以下是重新排版后的内容：</p>
<h2 id="Redis-怎么实现分布式锁"><a href="#Redis-怎么实现分布式锁" class="headerlink" title="Redis 怎么实现分布式锁"></a>Redis 怎么实现分布式锁</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line"><span class="comment"># EX second: 设置键的过期时间为second秒</span></span><br><span class="line"><span class="comment"># PX millisecond: 设置键的过期时间为millisecond毫秒</span></span><br><span class="line"><span class="comment"># NX: 只在键不存在时，才对键进行设置操作</span></span><br><span class="line"><span class="comment"># XX: 只在键已经存在时，才对键进行设置操作</span></span><br><span class="line"><span class="comment"># SET操作成功完成时，返回OK，否则返回nil</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Redis-分布式锁的缺陷"><a href="#Redis-分布式锁的缺陷" class="headerlink" title="Redis 分布式锁的缺陷"></a>Redis 分布式锁的缺陷</h3><ol>
<li><p><strong>死锁：</strong></p>
<ul>
<li>解决：设置锁的过期时间，保证setNx和设置过期时间的操作原子性。</li>
</ul>
</li>
<li><p><strong>错位解锁：</strong></p>
<ul>
<li>解决：加锁时记录当前线程ID，解锁时判断ID是否一致，使用Lua脚本保持原子性。</li>
</ul>
</li>
<li><p><strong>业务并发执行问题：</strong></p>
<ul>
<li>解决：加锁成功后开启守护线程，临近过期时续时，重复此步骤直到业务完成。</li>
</ul>
</li>
</ol>
<h2 id="Redis-如何做内存优化"><a href="#Redis-如何做内存优化" class="headerlink" title="Redis 如何做内存优化"></a>Redis 如何做内存优化</h2><ol>
<li><p><strong>缩减键值对象：</strong></p>
<ul>
<li>保持业务要求下，使key越短越好，对value适当压缩。</li>
</ul>
</li>
<li><p><strong>共享对象池：</strong></p>
<ul>
<li>Redis内部维护[0-9999]的整数对象池，尽量使用整数对象以节省内存。</li>
</ul>
</li>
<li><p><strong>尽可能使用散列表(hashes)。</strong></p>
</li>
<li><p><strong>编码优化，控制编码类型。</strong></p>
</li>
<li><p><strong>控制key的数量。</strong></p>
</li>
</ol>
<h2 id="Redis-淘汰策略有哪些"><a href="#Redis-淘汰策略有哪些" class="headerlink" title="Redis 淘汰策略有哪些"></a>Redis 淘汰策略有哪些</h2><ol>
<li><code>noeviction</code>: 不删除策略，达到最大内存限制时，如果需要更多内存，直接返回错误信息。</li>
<li><code>allkeys-lru</code>: 所有key通用；优先删除最近最少使用(LRU)的key。</li>
<li><code>volatile-lru</code>: 只限于设置了expire的部分；优先删除LRU的key。</li>
<li><code>allkeys-random</code>: 所有key通用；随机删除一部分key。</li>
<li><code>volatile-random</code>: 只限于设置了expire的部分；随机删除一部分key。</li>
<li><code>volatile-ttl</code>: 只限于设置了expire的部分；优先删除剩余时间(TTL)短的key。</li>
</ol>
<h2 id="Redis-常见问题及解决"><a href="#Redis-常见问题及解决" class="headerlink" title="Redis 常见问题及解决"></a>Redis 常见问题及解决</h2><h3 id="缓存和数据库双写一致性问题"><a href="#缓存和数据库双写一致性问题" class="headerlink" title="缓存和数据库双写一致性问题"></a>缓存和数据库双写一致性问题</h3><ul>
<li>解决：采取正确的更新策略，先更新数据库，再删缓存，并提供补偿措施，如利用消息队列。</li>
</ul>
<h3 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h3><ul>
<li>解决：利用互斥锁，在缓存失效时先获取锁，请求数据库。采用异步更新策略，进行缓存预热。</li>
</ul>
<h3 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h3><ul>
<li>解决：给缓存失效时间加上随机值，使用互斥锁，或者双缓存策略。</li>
</ul>
<h3 id="缓存的并发竞争问题"><a href="#缓存的并发竞争问题" class="headerlink" title="缓存的并发竞争问题"></a>缓存的并发竞争问题</h3><ul>
<li>解决：根据需求使用分布式锁，保持业务的灵活变通。</li>
</ul>
<h2 id="RabbitMQ-部分面试题"><a href="#RabbitMQ-部分面试题" class="headerlink" title="RabbitMQ 部分面试题"></a>RabbitMQ 部分面试题</h2><h3 id="RabbitMQ-使用场景"><a href="#RabbitMQ-使用场景" class="headerlink" title="RabbitMQ 使用场景"></a>RabbitMQ 使用场景</h3><ul>
<li>多个应用之间的耦合。</li>
<li>跨系统的异步通信。</li>
<li>流量削峰，如注册用户、发送激活邮件、订单下单等。</li>
</ul>
<h3 id="RabbitMQ-的重要角色"><a href="#RabbitMQ-的重要角色" class="headerlink" title="RabbitMQ 的重要角色"></a>RabbitMQ 的重要角色</h3><ol>
<li><strong>生产者：</strong> 消息的创建者，负责创建和推送数据到消息服务器。</li>
<li><strong>消费者：</strong> 消息的接收方，负责处理数据和确认消息。</li>
<li><strong>代理：</strong> RabbitMQ本身，不生产不消费，只是消息的快递。</li>
</ol>
<h3 id="RabbitMQ-的重要组件"><a href="#RabbitMQ-的重要组件" class="headerlink" title="RabbitMQ 的重要组件"></a>RabbitMQ 的重要组件</h3><ol>
<li><strong>ConnectionFactory（连接管理器）：</strong> 应用程序与Rabbit之间建立连接的管理器。</li>
<li><strong>Channel（信道）：</strong> 消息推送使用的通道。</li>
<li><strong>Exchange（交换器）：</strong> 用于接受、分配消息。</li>
<li><strong>Queue（队列）：</strong> 用于存储生产者的消息。</li>
<li><strong>RoutingKey（路由键）：</strong> 将生成者的数据分配到交换器上。</li>
<li><strong>BindingKey（绑定键）：</strong> 将交换器的消息绑定到队列上。</li>
</ol>
<h3 id="RabbitMQ-的消息存储方式"><a href="#RabbitMQ-的消息存储方式" class="headerlink" title="RabbitMQ 的消息存储方式"></a>RabbitMQ 的消息存储方式</h3><p>RabbitMQ对于queue中的message的保存方式有两种：<code>disc</code> 和 <code>ram</code>。<code>disc</code>方式将消息存储到磁盘，而<code>ram</code>方式存储在内存中。</p>
<h3 id="RabbitMQ-中-vhost-的作用"><a href="#RabbitMQ-中-vhost-的作用" class="headerlink" title="RabbitMQ 中 vhost 的作用"></a>RabbitMQ 中 vhost 的作用</h3><ul>
<li>vhost本质上是一个mini版的RabbitMQ服务器，拥有自己的队列、绑定、交换器和权限控制。</li>
<li>在全局角度，vhost可以作为不同权限隔离的手段，例如不同应用可以跑在不同的vhost中。</li>
</ul>
<h3 id="RabbitMQ-的消息发送过程"><a href="#RabbitMQ-的消息发送过程" class="headerlink" title="RabbitMQ 的消息发送过程"></a>RabbitMQ 的消息发送过程</h3><ol>
<li>生产者将消息通过channel发送到Exchange。</li>
<li>Exchange通过绑定的routing key选择Queue。</li>
<li>消费者监听到Queue上有新的消息，消费该消息。</li>
</ol>
<h3 id="RabbitMQ-如何保证消息的稳定性"><a href="#RabbitMQ-如何保证消息的稳定性" class="headerlink" title="RabbitMQ 如何保证消息的稳定性"></a>RabbitMQ 如何保证消息的稳定性</h3><ul>
<li>提供了事务的功能，通过将channel设置为confirm（确认模式）。</li>
</ul>
<h3 id="RabbitMQ-如何避免丢失消息"><a href="#RabbitMQ-如何避免丢失消息" class="headerlink" title="RabbitMQ 如何避免丢失消息"></a>RabbitMQ 如何避免丢失消息</h3><ol>
<li>消息持久化。</li>
<li>消费端的ack签收机制。</li>
<li>设置集群镜像模式。</li>
<li>消息补偿机制。</li>
</ol>
<h3 id="RabbitMQ-持久化的缺点"><a href="#RabbitMQ-持久化的缺点" class="headerlink" title="RabbitMQ 持久化的缺点"></a>RabbitMQ 持久化的缺点</h3><ul>
<li>持久化的缺点是降低了服务器的吞吐量，因为使用磁盘而非内存存储，可以使用SSD硬盘来缓解。</li>
</ul>
<h3 id="RabbitMQ-的广播方式"><a href="#RabbitMQ-的广播方式" class="headerlink" title="RabbitMQ 的广播方式"></a>RabbitMQ 的广播方式</h3><ul>
<li><code>fanout</code>广播模式：所有bind到此exchange的queue都可以接收消息。</li>
<li><code>direct</code>直接交换：通过routingKey和exchange决定的那个唯一的queue可以接收消息。</li>
<li><code>topic</code>通配符模式：所有符合routingKey的routingKey所bind的queue可以接收消息。</li>
</ul>
<h3 id="RabbitMQ-如何实现延迟消息队列"><a href="#RabbitMQ-如何实现延迟消息队列" class="headerlink" title="RabbitMQ 如何实现延迟消息队列"></a>RabbitMQ 如何实现延迟消息队列</h3><ul>
<li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能。</li>
<li>使用<code>RabbitMQ-delayed-message-exchange</code>插件实现延迟功能。</li>
</ul>
<h3 id="RabbitMQ-集群的作用"><a href="#RabbitMQ-集群的作用" class="headerlink" title="RabbitMQ 集群的作用"></a>RabbitMQ 集群的作用</h3><ul>
<li>高可用：某个服务器出现问题，整个RabbitMQ仍可以继续使用。</li>
<li>高容量：集群可以承载更多的消息量。</li>
</ul>
<h3 id="RabbitMQ-节点的类型"><a href="#RabbitMQ-节点的类型" class="headerlink" title="RabbitMQ 节点的类型"></a>RabbitMQ 节点的类型</h3><ol>
<li><strong>磁盘节点：</strong> 消息存储到磁盘，重启后消息仍在。</li>
<li><strong>内存节点：</strong> 消息存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li>
</ol>
<h3 id="RabbitMQ-集群搭建注意事项"><a href="#RabbitMQ-集群搭建注意事项" class="headerlink" title="RabbitMQ 集群搭建注意事项"></a>RabbitMQ 集群搭建注意事项</h3><ol>
<li>各节点之间使用–link连接。</li>
<li>各节点使用相同的erlang cookie值，用于节点认证。</li>
<li>必须包含一个磁盘节点。</li>
</ol>
<h3 id="RabbitMQ-每个节点是否是其他节点的完整拷贝"><a href="#RabbitMQ-每个节点是否是其他节点的完整拷贝" class="headerlink" title="RabbitMQ 每个节点是否是其他节点的完整拷贝"></a>RabbitMQ 每个节点是否是其他节点的完整拷贝</h3><ul>
<li>不是。每个节点并不拥有所有队列的完全拷贝，避免增加冗余数据。</li>
</ul>
<h3 id="RabbitMQ-唯一一个磁盘节点崩溃的影响"><a href="#RabbitMQ-唯一一个磁盘节点崩溃的影响" class="headerlink" title="RabbitMQ 唯一一个磁盘节点崩溃的影响"></a>RabbitMQ 唯一一个磁盘节点崩溃的影响</h3><ul>
<li>集群可以保持运行，但无法更改任何配置、添加用户、添加和删除集群节点等。</li>
</ul>
<h3 id="RabbitMQ-集群停止顺序要求"><a href="#RabbitMQ-集群停止顺序要求" class="headerlink" title="RabbitMQ 集群停止顺序要求"></a>RabbitMQ 集群停止顺序要求</h3><ul>
<li>先关闭内存节点，最后关闭磁盘节点，确保顺序正确以防消息丢失。</li>
</ul>
<h2 id="JVM-部分面试题"><a href="#JVM-部分面试题" class="headerlink" title="JVM 部分面试题"></a>JVM 部分面试题</h2><h3 id="JVM-主要组成部分及作用"><a href="#JVM-主要组成部分及作用" class="headerlink" title="JVM 主要组成部分及作用"></a>JVM 主要组成部分及作用</h3><ol>
<li><strong>类加载器（Class Loader）：</strong> 加载类文件到内存。</li>
<li><strong>执行引擎（Execution Engine）：</strong> 解释命令，交由操作系统执行。</li>
<li><strong>本地库接口（Native Interface）：</strong> 融合不同语言为Java所用。</li>
<li><strong>运行时数据区（Runtime Data Area）：</strong> 包括方法区、堆、栈等。</li>
</ol>
<h3 id="JVM-常见问题及解决"><a href="#JVM-常见问题及解决" class="headerlink" title="JVM 常见问题及解决"></a>JVM 常见问题及解决</h3><ol>
<li><p><strong>内存溢出（OutOfMemoryError）：</strong></p>
<ul>
<li>解决：增大堆内存、优化代码、检查是否存在内存泄漏。</li>
</ul>
</li>
<li><p><strong>栈溢出（StackOverflowError）：</strong></p>
<ul>
<li>解决：增大栈内存、优化递归算法。</li>
</ul>
</li>
<li><p><strong>方法区溢出：</strong></p>
<ul>
<li>解决：增大方法区内存、减少类的加载。</li>
</ul>
</li>
<li><p><strong>死锁：</strong></p>
<ul>
<li>解决：分析死锁原因，合理设计锁的获取顺序。</li>
</ul>
</li>
<li><p><strong>高CPU占用：</strong></p>
<ul>
<li>解决：优化代码、检查是否存在无限循环。</li>
</ul>
</li>
<li><p><strong>Full GC频繁：</strong></p>
<ul>
<li>解决：调整堆大小、优化GC算法。</li>
</ul>
</li>
<li><p><strong>类加载问题：</strong></p>
<ul>
<li>解决：检查类路径、冲突等问题。</li>
</ul>
</li>
<li><p><strong>JVM调优：</strong></p>
<ul>
<li>解决：调整堆内存大小、设置垃圾回收器、分析内存使用情况。</li>
</ul>
</li>
<li><p><strong>PermGen空间溢出：</strong></p>
<ul>
<li>解决：升级JVM版本、使用元空间替代。</li>
</ul>
</li>
<li><p><strong>线程问题：</strong></p>
<ul>
<li>解决：分析线程堆栈信息、合理设计线程池。</li>
</ul>
</li>
</ol>
<p><strong>JVM 运行时数据区是什么</strong></p>
<ul>
<li><p><strong>堆</strong>：Java对象的存储区域。任何使用<code>new</code>分配的Java对象实例和数组都在堆上分配。Java堆可通过<code>-Xms</code>和<code>-Xmx</code>进行内存控制。</p>
</li>
<li><p><strong>常量池</strong>：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。JDK 1.7以后，运行时常量池从方法区移到了堆上。</p>
</li>
<li><p><strong>方法区</strong>：用于存储已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码等数据。</p>
</li>
<li><p><strong>虚拟机栈</strong>：虚拟机栈中执行每个方法时，都会创建一个栈桢用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
</li>
<li><p><strong>本地方法栈</strong>：与虚拟机栈发挥的作用相似。相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的Native方法服务。执行每个本地方法时，都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
</li>
<li><p><strong>程序计数器</strong>：指示Java虚拟机下一条需要执行的字节码指令。</p>
</li>
</ul>
<p><strong>堆和栈的区别</strong></p>
<ul>
<li><p><strong>栈内存</strong>用来存储局部变量和方法调用。</p>
</li>
<li><p><strong>堆内存</strong>用来存储Java中的对象。无论是成员变量、局部变量还是类变量，它们指向的对象都存储在堆内存中。</p>
</li>
<li><p>栈内存归属单个线程，一个栈对应一个线程。储存的变量只能在该线程中访问，也可以理解为私有内存。</p>
</li>
<li><p>堆内存中的对象所有线程均可见，堆内存中对象可以被所有线程访问。</p>
</li>
<li><p>栈内存要远小于堆内存。</p>
</li>
</ul>
<p><strong>队列和栈是什么?有什么区别</strong></p>
<ul>
<li><p>队列和栈是两种不同的数据结构。</p>
</li>
<li><p><strong>队列</strong>：插入称为入队，删除称为出队。在队尾入队、队头出队。两边都可操作。先进先出（FIFO）。</p>
</li>
<li><p><strong>栈</strong>：插入称为进栈，删除称为出栈。在栈顶进行操作。后进先出（LIFO）。</p>
</li>
</ul>
<p><strong>类加载器有哪些？什么是双亲委派模型</strong></p>
<ul>
<li><p><strong>启动类加载器（Bootstrap ClassLoader）</strong>：加载<code>&lt;JAVA_HOME&gt;\lib</code>目录下核心库。</p>
</li>
<li><p><strong>扩展类加载器（Extension ClassLoader）</strong>：加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下扩展包。</p>
</li>
<li><p><strong>应用程序类加载器（Application ClassLoader）</strong>：加载用户路径（classpath）上指定的类库。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/11/26/FWiV8LEHvKlemDy.png"></p>
<p><strong>双亲委派</strong>的意思是，如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成。每一层都是如此，一直递归到顶层。当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实指的是父类，没有mother。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。</p>
<p><strong>类加载的执行过程</strong></p>
<ol>
<li><p><strong>加载</strong>：指将class字节码文件从各个来源通过类加载器装载入内存中。</p>
<ul>
<li>字节码来源：从本地路径下编译生成的<code>.class</code>文件、从JAR包中的<code>.class</code>文件、从远程网络以及动态代理实时编</li>
</ul>
</li>
</ol>
<p>译类加载器。包括启动类加载器、扩展类加载器、应用类加载器以及用户的自定义类加载器。</p>
<ol start="2">
<li><p><strong>链接</strong></p>
<ul>
<li><p><strong>验证</strong>：主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误，包括对文件格式的验证。</p>
</li>
<li><p><strong>准备</strong>：为类变量（注意，不是实例变量）分配内存，并赋予初值。初值不是代码中具体写的初始化值，而是Java虚拟机根据不同变量类型的默认初始值：8种基本类型的初值默认为0，引用类型的初值为null。</p>
</li>
<li><p><strong>解析</strong>：将常量池内的符号引用替换为直接引用。在解析阶段，虚拟机会把所有的类名、方法名、字段名这些符号引用替换为具体的内存地址或偏移量，即直接引用。</p>
</li>
</ul>
</li>
<li><p><strong>初始化</strong>：对类变量初始化，执行类构造器的过程。</p>
</li>
</ol>
<p><strong>如何判断对象是否可以收回</strong></p>
<ul>
<li><p><strong>引用计数算法</strong>：</p>
<ul>
<li><p>判断对象的引用数量。</p>
</li>
<li><p>通过判断对象的引用数量来决定对象是否可以被回收。</p>
</li>
<li><p>每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1。</p>
</li>
<li><p>任何引用计数为0的对象实例可以被当作垃圾收集。</p>
</li>
<li><p>优点：执行效率高，程序执行受影响较小；缺点：无法检测出循环引用的情况，导致内存泄漏。</p>
</li>
</ul>
</li>
<li><p><strong>可达性分析算法</strong>：</p>
<ul>
<li><p>通过判断对象的引用链是否可达来决定对象是否可以被回收。</p>
</li>
<li><p>可以作为GC Root对象的对象有：虚拟机栈中引用的对象（栈帧中的本地变量表）、方法区中的常量引用对象、方法区中类静态属性引用对象、本地方法栈中JNI（Native方法）的引用对象、活跃线程中的引用对象。</p>
</li>
</ul>
</li>
</ul>
<p><strong>Java中有哪些引用类型</strong></p>
<ul>
<li><p><strong>强引用（strong reference）</strong>：在程序代码中普遍存在，类似<code>Object obj = new Object()</code>这类的引用。只要强引用还存在，垃圾收集器永远不会回收被引用的对象实例。</p>
</li>
<li><p><strong>软引用（soft reference）</strong>：用来描述一些还有用但非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象实例列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了<code>SoftReference</code>类来实现软引用。</p>
</li>
<li><p><strong>弱引用（weak reference）</strong>：用来描述非必需对象，强度比软引用更弱。被弱引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。在JDK 1.2之后，提供了<code>WeakReference</code>类来实现弱引用。</p>
</li>
<li><p><strong>虚引用（phantom reference）</strong>：也称为幽灵引用或幻影引用，是最弱的引用关系。一个对象实例是否有虚引用的存在完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是能在这个对象实例被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了<code>PhantomReference</code>类来实现虚引用。</p>
</li>
</ul>
<h2 id="JVM-中垃圾回收算法"><a href="#JVM-中垃圾回收算法" class="headerlink" title="JVM 中垃圾回收算法"></a>JVM 中垃圾回收算法</h2><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记。标记完毕后，再扫描整个空间中未被标记的对象，进行回收。该算法不需要进行对象的移动，只需对不存活的对象进行处理。在存活对象比较多的情况下，极为高效。然而，由于直接回收不存活的对象，可能导致内存碎片。</p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它将堆分成一个对象面和多个空闲面。程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾收集就从根集合中扫描活动对象，将每个活动对象复制到空闲面，使得活动对象所占的内存之间没有空闲洞。这样空闲面变成了对象面，原来的对象面变成了空闲面。</p>
<h2 id="标记-整理（压缩）算法"><a href="#标记-整理（压缩）算法" class="headerlink" title="标记-整理（压缩）算法"></a>标记-整理（压缩）算法</h2><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同。在回收不存活的对象占用的空间后，该算法将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但解决了内存碎片的问题。</p>
<h2 id="JVM-有哪些垃圾回收器"><a href="#JVM-有哪些垃圾回收器" class="headerlink" title="JVM 有哪些垃圾回收器"></a>JVM 有哪些垃圾回收器</h2><h2 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h2><ul>
<li>Serial</li>
<li>ParNew</li>
<li>Parallel Scavenge</li>
</ul>
<h2 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><ul>
<li>CMS</li>
<li>Serial Old</li>
<li>Parallel Old</li>
</ul>
<h2 id="整堆收集器"><a href="#整堆收集器" class="headerlink" title="整堆收集器"></a>整堆收集器</h2><ul>
<li>G1</li>
</ul>
<h2 id="介绍一下-CMS-垃圾回收器"><a href="#介绍一下-CMS-垃圾回收器" class="headerlink" title="介绍一下 CMS 垃圾回收器"></a>介绍一下 CMS 垃圾回收器</h2><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。它基于标记-清除算法实现，并发收集，具有低停顿的特点。适用于注重服务的响应速度，希望系统停顿时间最短的场景，如web程序、b/s服务。</p>
<p>CMS收集器的运行过程分为以下4步：</p>
<ol>
<li>初始标记：标记GC Roots能直接到达的对象，速度很快但仍存在Stop The World问题。</li>
<li>并发标记：进行GC Roots Tracing的过程，找出存活对象且用户线程可并发执行。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题。</li>
<li>并发清除：对标记的对象进行清除回收。</li>
</ol>
<p>CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>缺点：</p>
<ul>
<li>对CPU资源敏感。</li>
<li>无法处理浮动垃圾，可能导致Concurrent Model Failure失败而导致另一次Full GC的产生。</li>
<li>存在空间碎片的问题，导致大对象无法分配空间，不得不提前触发一次Full GC。</li>
</ul>
<h2 id="新生代垃圾回收器和老生代垃圾回收器有哪些？有什么区别"><a href="#新生代垃圾回收器和老生代垃圾回收器有哪些？有什么区别" class="headerlink" title="新生代垃圾回收器和老生代垃圾回收器有哪些？有什么区别"></a>新生代垃圾回收器和老生代垃圾回收器有哪些？有什么区别</h2><h2 id="新生代收集器-1"><a href="#新生代收集器-1" class="headerlink" title="新生代收集器"></a>新生代收集器</h2><ul>
<li>Serial</li>
<li>ParNew</li>
<li>Parallel Scavenge</li>
</ul>
<h2 id="老年代收集器-1"><a href="#老年代收集器-1" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><ul>
<li>CMS</li>
<li>Serial Old</li>
<li>Parallel Old</li>
</ul>
<p>区别：</p>
<ul>
<li>新生代垃圾回收器一般采用复制算法，效率高，但内存利用率低。</li>
<li>老年代垃圾回收器一般采用标记-整理的算法，用于垃圾回收。</li>
</ul>
<h2 id="简述分代垃圾回收器是怎么工作的"><a href="#简述分代垃圾回收器是怎么工作的" class="headerlink" title="简述分代垃圾回收器是怎么工作的"></a>简述分代垃圾回收器是怎么工作的</h2><p>分代回收器有两个分区：老生代和新生代。新生代使用复制算法，分为Eden、To Survivor、From Survivor三个分区。对象在Eden分区分配，当对象满了后，基于copying算法将活动对象复制到To Survivor区，清空Eden和From Survivor区，然后交换From Survivor和To Survivor分区。每次移动都使对象年龄加1，当年龄达到一定值（默认15）时，升级为老生代。</p>
<p>老生代当空间占用达到某个值时，触发全局垃圾收回，使用标记-整理算法进行垃圾回收。整个过程循环往复，构成分代垃圾回收的整体执行流程。</p>
<h2 id="JVM调优的工具有哪些"><a href="#JVM调优的工具有哪些" class="headerlink" title="JVM调优的工具有哪些"></a>JVM调优的工具有哪些</h2><ul>
<li>jconsole：基于JMX的GUI性能监测工具。</li>
<li>VisualVM：提供可视界面，用于查看Java虚拟机上运行的Java应用程序的详细信息。</li>
<li>MAT（Memory Analyzer Tool）：基于Eclipse的内存分析工具，用于查找内存泄漏和减少内存消耗。</li>
<li>GChisto：分析gc日志的工具，通过gc日志分析Minor GC、Full GC的时间、频率等。</li>
<li>gcviewer：可视化查看由Sun/Oracle、IBM、HP和BEA Java虚拟机产生的垃圾收集器的日志。</li>
</ul>
<h2 id="JVM调优的参数有哪些"><a href="#JVM调优的参数有哪些" class="headerlink" title="JVM调优的参数有哪些"></a>JVM调优的参数有哪些</h2><p>（待完善，因篇幅限制）</p>
<h2 id="Api接口如何实现？"><a href="#Api接口如何实现？" class="headerlink" title="Api接口如何实现？"></a>Api接口如何实现？</h2><p>在类中使用<code>implements</code>关键字实现Api接口。</p>
<h2 id="MySQL链接数据库常用的几"><a href="#MySQL链接数据库常用的几" class="headerlink" title="MySQL链接数据库常用的几"></a>MySQL链接数据库常用的几</h2><p>种方式</p>
<ol>
<li>Mybatis框架</li>
<li>Hibernate框架</li>
<li>JDBC技术</li>
<li>c3p0连接池</li>
<li>dbcp连接池</li>
</ol>
<h2 id="SpringBoot如何集成Redis"><a href="#SpringBoot如何集成Redis" class="headerlink" title="SpringBoot如何集成Redis"></a>SpringBoot如何集成Redis</h2><p>在<code>pom.xml</code>文件引入Redis依赖：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>在<code>application</code>配置文件中书写Redis配置：</p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="comment"># spring.redis.password=</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="SpringCloud的优点"><a href="#SpringCloud的优点" class="headerlink" title="SpringCloud的优点"></a>SpringCloud的优点</h2><ol>
<li>服务之间采用轻量级通讯，如Restful。</li>
<li>精准的制定优化服务方案，提高系统的可维护性。</li>
<li>服务之间拆分细致，资源可重复利用，提高开发效率。</li>
</ol>
<h2 id="SpringCloud用了哪些组件"><a href="#SpringCloud用了哪些组件" class="headerlink" title="SpringCloud用了哪些组件"></a>SpringCloud用了哪些组件</h2><ol>
<li>Netflix Eureka 注册中心</li>
<li>Netflix Ribbon 负载均衡</li>
<li>Netflix Zuul 网关</li>
<li>Netflix Hystrix 熔断器</li>
<li>Feign 服务调用</li>
</ol>
<h2 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h2><ul>
<li>List允许有多个重复对象，而Set不允许有重复对象。</li>
<li>List允许有多个NULL值，而Set只允许有一个NULL值。</li>
<li>List是一个有序的容器，输出顺序即是输入顺序。</li>
<li>Set是一个无序的容器，无法保证每个元素的顺序，但可以用TreeSet通过Comparator或Comparable维护排序顺序。</li>
<li>List的实现类有ArrayList、LinkedList、Vector。</li>
<li>Set的实现类有HashSet、TreeSet、LinkedHashSet。</li>
</ul>
<h2 id="Java中static的作用"><a href="#Java中static的作用" class="headerlink" title="Java中static的作用"></a>Java中static的作用</h2><p><code>static</code>表示全局或静态，用来修饰成员变量和成员方法。它可以形成静态代码块，实现不用实例化就可以使用被<code>public static</code>修饰的变量或方法。</p>
<h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>单例模式保证整个项目中一个类只有一个对象的实例。它的好处包括节省公共资源和方便控制。要保证是单例模式，需要构造私有化、以静态方法返回实例，确保对象实例只有一个。</p>
<h2 id="单例模式有哪几种？"><a href="#单例模式有哪几种？" class="headerlink" title="单例模式有哪几种？"></a>单例模式有哪几种？</h2><ol>
<li>饿汉模式：在类加载时就创建好对象，需要时直接使用。</li>
<li>懒汉模式：等需要时再创建对象，后续不再创建。</li>
</ol>
<h2 id="SpringBoot常用的几个注解"><a href="#SpringBoot常用的几个注解" class="headerlink" title="SpringBoot常用的几个注解"></a>SpringBoot常用的几个注解</h2><ol>
<li><code>@SpringBootApplication</code>：SpringBoot的核心注解，用于标识启动类。</li>
<li><code>@EnableAutoConfiguration</code>：开启SpringBoot自动配置。</li>
<li><code>@RestController</code>：在控制层，是<code>@ResponseBody</code>和<code>@Controller</code>注解的合集。</li>
<li><code>@RequestMapping</code>：处理请求地址映射的注解。</li>
<li><code>@RequestParam</code>：获取URL上传过来的参数。</li>
<li><code>@Configuration</code>：声明配置类。</li>
<li><code>@Component</code>：通用注解。</li>
<li><code>@Service</code>：业务逻辑层。</li>
</ol>
<h2 id="Java八大数据类型"><a href="#Java八大数据类型" class="headerlink" title="Java八大数据类型"></a>Java八大数据类型</h2><ol>
<li><p>char：字符型</p>
</li>
<li><p>byte：字节型</p>
</li>
<li><p>boolean：布尔型</p>
</li>
<li><p>float：单浮点型</p>
</li>
<li><p>double：双浮点型</p>
</li>
<li><p>int：整数型</p>
</li>
<li><p>short：短整数型</p>
</li>
<li><p>long：长整数型</p>
</li>
</ol>
<h2 id="MySQL分页和升序降序如何实现"><a href="#MySQL分页和升序降序如何实现" class="headerlink" title="MySQL分页和升序降序如何实现"></a>MySQL分页和升序降序如何实现</h2><p>分页使用<code>limit</code>，升序使用<code>order by xx asc</code>，降序使用<code>order by xx desc</code>。</p>
<p>例子：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 分页</span></span><br><span class="line"><span class="keyword">select</span> name, age, sex <span class="keyword">from</span> t_student limit <span class="number">0</span>, <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 升序</span></span><br><span class="line"><span class="keyword">select</span> name, age, sex <span class="keyword">from</span> t_student <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 降序</span></span><br><span class="line"><span class="keyword">select</span> name, age, sex <span class="keyword">from</span> t_student <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Maven是干什么的，它有什么好处？"><a href="#Maven是干什么的，它有什么好处？" class="headerlink" title="Maven是干什么的，它有什么好处？"></a>Maven是干什么的，它有什么好处？</h2><p>Maven是专门构建和管理Java项目的工具。它的好处在于可以将项目过程规范化、自动化、高效化以及具有强大的可扩展性。</p>
<h2 id="MySQL如何添加索引？"><a href="#MySQL如何添加索引？" class="headerlink" title="MySQL如何添加索引？"></a>MySQL如何添加索引？</h2><ol>
<li>主键索引：<code>PRIMARY KEY</code></li>
<li>普通索引：<code>INDEX</code>，使用<code>ALTER TABLE table_name ADD INDEX index_name ( column )</code></li>
<li>唯一索引：<code>UNIQUE INDEX</code>，使用<code>ALTER TABLE table_name ADD UNIQUE index_name ( column )</code></li>
<li>全文索引：<code>FULLTEXT INDEX</code>，使用<code>ALTER TABLE table_name ADD FULLTEXT ( column)</code></li>
<li>多列索引：<code>INDEX</code>，使用<code>ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3 )</code></li>
</ol>
<h2 id="MySQL索引的实现方式"><a href="#MySQL索引的实现方式" class="headerlink" title="MySQL索引的实现方式"></a>MySQL索引的实现方式</h2><p>MySQL索引底层的实现方式是B+Tree，具体可查看B+Tree的实现方式。</p>
<h2 id="Vue的数据双向绑定原理"><a href="#Vue的数据双向绑定原理" class="headerlink" title="Vue的数据双向绑定原理"></a>Vue的数据双向绑定原理</h2><p>Vue的数据双向绑定原理是使用<code>v-model</code>属性，利用了<code>Object.defineProperty()</code>方法重新定义了对象获取属性值（get）和设置属性值（set）的操作。</p>
<h2 id="ActiveMQ的消息存储方式"><a href="#ActiveMQ的消息存储方式" class="headerlink" title="ActiveMQ的消息存储方式"></a>ActiveMQ的消息存储方式</h2><p>ActiveMQ采取先进先出模式，同一时间，消息只会发送给某一个消费者，只有当该消息被消费并告知已收到时，它才能在代理的存储中被删除。对于持久性订阅，每个消费者都会获取消息的拷贝。为了节约空间，代理的存储介质中只存储了一份消息，存储介质的持久订阅对象为其以后的被存储的消息维护了一个指针，消费者消费时，从存储介质中复制一个消息。消息被所有订阅者获取后才能删除。</p>
<h2 id="KahaDB消息存储"><a href="#KahaDB消息存储" class="headerlink" title="KahaDB消息存储"></a>KahaDB消息存储</h2><p>基于文件的消息存储机制，为了提高消息存储的可靠性和可恢复性，它整合了一个事务日志.KahaDB拥有高性能和可扩展性等特点.由于KahaDB使用的是基于文件的存储，所以不需要使用第三方数据库</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://risingrode.github.io">fcw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://risingrode.github.io/post/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/%E9%9D%A2%E7%BB%8F-%E6%89%93%E5%8D%B0%E7%89%88.html">https://risingrode.github.io/post/面试/八股文/面经-打印版.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://risingrode.github.io" target="_blank">代码有点萌</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><div class="post_share"><div class="social-share" data-image="https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BD%A0%E7%9A%84%E9%87%8E%E5%BF%83%E8%A6%81%E9%85%8D%E5%BE%97%E4%B8%8A%E4%BD%A0%E7%9A%84%E5%8A%AA%E5%8A%9B.html" title="你的野心要配得上你的努力"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">你的野心要配得上你的努力</div></div></a></div><div class="next-post pull-right"><a href="/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-%E6%84%9F%E6%82%9F.html" title="认知觉醒-感悟"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i0.hippopx.com/photos/356/657/107/beach-beverage-caribbean-cocktail-thumb.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">认知觉醒-感悟</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/girl.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">fcw</div><div class="author-info__description">一个收藏回忆与分享技术的地方！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">47</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Risingrode"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到cwRising的博客</div></div><div class="card-widget"><div class="item-headline"><i></i><span></span></div><div class="item-content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E7%BB%8F"><span class="toc-number">1.</span> <span class="toc-text">面经</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">请求一个网页链接的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8Cmysql%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">Redis 将数据存储在内存中，mysql把数据存在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E%E7%A3%81%E7%9B%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">内存与磁盘的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-number">1.4.</span> <span class="toc-text">B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%92%8Chttps%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">http和https区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.6.</span> <span class="toc-text">Socket是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET%E5%92%8CPOST%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.7.</span> <span class="toc-text">GET和POST区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.8.</span> <span class="toc-text">HTTP和HTTPS区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">1.9.</span> <span class="toc-text">十进制和二进制的转换：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E8%B0%83%E4%BC%98%EF%BC%9A"><span class="toc-number">1.10.</span> <span class="toc-text">MySQL调优：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9A"><span class="toc-number">1.11.</span> <span class="toc-text">IO多路复用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HAVING%E5%92%8CWHERE%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.12.</span> <span class="toc-text">HAVING和WHERE区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">1.13.</span> <span class="toc-text">Redis数据类型和数据结构：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%ACK%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">1.14.</span> <span class="toc-text">第K大算法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E9%BB%98%E8%AE%A4%E5%BC%95%E6%93%8E%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.15.</span> <span class="toc-text">MySQL默认引擎，解决了什么问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC"><span class="toc-number">1.16.</span> <span class="toc-text">MVCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%86%99%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.17.</span> <span class="toc-text">MySQL写一个死锁场景：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%84%E6%9C%89%E5%BA%8F%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%95%B0%E7%BB%84%E6%89%BE%E5%88%B0%E6%9F%90%E4%B8%AA%E6%9C%80%E5%90%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89%EF%BC%9A"><span class="toc-number">1.18.</span> <span class="toc-text">一组有序可重复数组找到某个最后出现的数的索引（二分）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">1.19.</span> <span class="toc-text">线程安全机制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%9A"><span class="toc-number">1.20.</span> <span class="toc-text">JVM类加载：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-x2F-IP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%9A"><span class="toc-number">1.21.</span> <span class="toc-text">TCP/IP如何实现可靠的数据传输：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">1.22.</span> <span class="toc-text">static关键字：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">1.23.</span> <span class="toc-text">类加载机制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%EF%BC%9A"><span class="toc-number">1.24.</span> <span class="toc-text">反射：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%EF%BC%9A"><span class="toc-number">1.25.</span> <span class="toc-text">HashMap：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">1.26.</span> <span class="toc-text">TCP和UDP的区别及介绍：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%9A"><span class="toc-number">1.27.</span> <span class="toc-text">TCP如何保证可靠的数据传输：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.28.</span> <span class="toc-text">说一下数组和列表是什么，以及区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A"><span class="toc-number">1.29.</span> <span class="toc-text">Spring Bean 生命周期：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot-Starter-factorys%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-number">1.30.</span> <span class="toc-text">Spring Boot Starter .factorys文件：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%89%E4%B8%AA%E8%8C%83%E5%BC%8F%E5%92%8C%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%EF%BC%9A"><span class="toc-number">1.31.</span> <span class="toc-text">MySQL三个范式和索引建立与查询：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACID"><span class="toc-number">1.32.</span> <span class="toc-text">ACID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.33.</span> <span class="toc-text">Redis缓存穿透、缓存击穿和缓存雪崩的解决方法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E8%A7%A3%E5%86%B3set-nx%E5%91%BD%E4%BB%A4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.34.</span> <span class="toc-text">Redis实现分布式锁和解决set nx命令的问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMS%EF%BC%88Concurrent-Mark-Sweep%EF%BC%89%EF%BC%9A"><span class="toc-number">1.35.</span> <span class="toc-text">CMS（Concurrent Mark Sweep）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Full-GC%E7%9A%84%E5%8F%91%E7%94%9F%E6%97%B6%E6%9C%BA%EF%BC%9A"><span class="toc-number">1.36.</span> <span class="toc-text">Full GC的发生时机：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%8D%95%E8%8E%B7OOM%E5%BC%82%E5%B8%B8%EF%BC%9A"><span class="toc-number">1.37.</span> <span class="toc-text">在代码中捕获OOM异常：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%80%90%E8%A1%8C%E8%87%AA%E5%A2%9E%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BEtarget%EF%BC%9A"><span class="toc-number">1.38.</span> <span class="toc-text">算法题：二维数组逐行自增快速查找target：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8%EF%BC%88ConcurrentModificationException%EF%BC%89"><span class="toc-number">1.39.</span> <span class="toc-text">ArrayList的并发修改异常（ConcurrentModificationException）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84happens-before%EF%BC%9A"><span class="toc-number">1.40.</span> <span class="toc-text">Java的happens-before：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">1.41.</span> <span class="toc-text">Redis的持久化机制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">1.42.</span> <span class="toc-text">Redis集群方案：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84IOC%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">1.43.</span> <span class="toc-text">Spring的IOC容器的作用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9Spring%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-number">1.44.</span> <span class="toc-text">对Spring的理解：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.45.</span> <span class="toc-text">适配器、装饰器和代理模式的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-x2F-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.46.</span> <span class="toc-text">TCP/IP四层模型：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9A"><span class="toc-number">1.47.</span> <span class="toc-text">三次握手和四次挥手：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9E%84%E6%88%90%EF%BC%9A"><span class="toc-number">1.48.</span> <span class="toc-text">HTTP请求的构成：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8CRabbitMQ%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A"><span class="toc-number">1.49.</span> <span class="toc-text">消息队列的作用和RabbitMQ的设计：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">1.50.</span> <span class="toc-text">最长无重复子串算法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%81%8D%E5%8E%86%E5%92%8C%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%E6%98%AF%E4%B8%B2%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">1.51.</span> <span class="toc-text">什么是遍历和修改操作是串行执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E7%85%A7"><span class="toc-number">1.52.</span> <span class="toc-text">什么是快照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC"><span class="toc-number">1.53.</span> <span class="toc-text">IOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%BC%82%E6%AD%A5%E8%BF%99%E4%B8%AA%E4%B8%9C%E8%A5%BF%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B8%BE%E4%B8%AA%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90"><span class="toc-number">1.54.</span> <span class="toc-text">为什么要有异步这个东西，解决了什么问题，举个代码例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="toc-number">1.55.</span> <span class="toc-text">什么是编程范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.56.</span> <span class="toc-text">Spring Bean 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RESTful"><span class="toc-number">1.57.</span> <span class="toc-text">RESTful</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET%E3%80%81POST%E3%80%81PUT%E3%80%81DELETE"><span class="toc-number">1.58.</span> <span class="toc-text">GET、POST、PUT、DELETE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBEAN"><span class="toc-number">1.59.</span> <span class="toc-text">什么是BEAN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9D%BE%E8%80%A6%E5%90%88"><span class="toc-number">1.60.</span> <span class="toc-text">什么是松耦合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.61.</span> <span class="toc-text">什么是事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-number">1.62.</span> <span class="toc-text">什么是分布式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.63.</span> <span class="toc-text">分布式数据库系统、分布式文件系统、分布式缓存系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%8Cc"><span class="toc-number">1.64.</span> <span class="toc-text">希尔排序，c++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%9C%E7%94%A8%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.65.</span> <span class="toc-text">CPU三级缓存的作用如下：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.66.</span> <span class="toc-text">进程和线程的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E6%98%AFCPU%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E6%97%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.67.</span> <span class="toc-text">用户态和内核态是CPU执行指令时的两种工作模式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFmysql%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.68.</span> <span class="toc-text">什么是mysql的索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88Sorted-Set%EF%BC%89"><span class="toc-number">1.69.</span> <span class="toc-text">有序集合（Sorted Set）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.70.</span> <span class="toc-text">底层是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81"><span class="toc-number">1.71.</span> <span class="toc-text">怎么解决死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%9A%84binlog%E5%92%8Credolog%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">1.72.</span> <span class="toc-text">MySQL的binlog和redolog如何保证一致性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6class%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%88%B0JVM%E7%9A%84%E4%BB%80%E4%B9%88%E5%8C%BA%E5%9F%9F%EF%BC%9F"><span class="toc-number">1.73.</span> <span class="toc-text">类加载时class文件加载到JVM的什么区域？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%83%BD%E8%AE%BF%E9%97%AE%E5%AD%90%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%90%97%EF%BC%9F%E5%8F%8D%E8%BF%87%E6%9D%A5%E5%91%A2%EF%BC%9F"><span class="toc-number">1.74.</span> <span class="toc-text">父类加载器能访问子类加载器吗？反过来呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AE%E5%AD%90%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.75.</span> <span class="toc-text">父类怎么访问子类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%AE%9E%E7%8E%B0%E5%BA%95%E5%B1%82%EF%BC%9F"><span class="toc-number">1.76.</span> <span class="toc-text">synchronized实现底层？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E6%AD%BB%E9%94%81%EF%BC%9F%E5%86%99%E5%87%BASQL%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E3%80%82"><span class="toc-number">1.77.</span> <span class="toc-text">什么叫死锁？写出SQL模拟一个死锁。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.78.</span> <span class="toc-text">保证分布式一致性的所有方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%8C%E8%AF%B4%E5%BE%97%E8%B6%8A%E5%BA%95%E5%B1%82%E8%B6%8A%E5%A5%BD%E3%80%82"><span class="toc-number">1.79.</span> <span class="toc-text">一条Java代码执行会发生什么，说得越底层越好。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%89%E5%BE%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E7%9C%9F%E7%9A%84%E5%BF%85%E8%A6%81%E5%90%97%EF%BC%9F"><span class="toc-number">1.80.</span> <span class="toc-text">觉得设计模式的意义是什么，真的必要吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.81.</span> <span class="toc-text">容器部分面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%AE%B9%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.82.</span> <span class="toc-text">Java 容器都有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collecion-%E5%92%8C-Collections-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.83.</span> <span class="toc-text">Collecion 和 Collections 有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E3%80%81Set%E3%80%81Map-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.84.</span> <span class="toc-text">List、Set、Map 之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-%E4%B8%8E-List-%E7%9B%B8%E6%AF%94%E8%BE%83"><span class="toc-number">1.85.</span> <span class="toc-text">Set 与 List 相比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.86.</span> <span class="toc-text">HashMap 和 HashTable 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.87.</span> <span class="toc-text">多线程部分面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-bean-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="toc-number">1.88.</span> <span class="toc-text">Spring 自动装配 bean 有哪些方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.89.</span> <span class="toc-text">Spring 事务实现方式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.90.</span> <span class="toc-text">Spring 的事务隔离是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Mvc-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.91.</span> <span class="toc-text">Spring Mvc 的运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Mvc-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6"><span class="toc-number">1.92.</span> <span class="toc-text">Spring Mvc 有哪些组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequestMapping-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.93.</span> <span class="toc-text">@RequestMapping 的作用是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autowired-%E4%B8%8E-Resource-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.94.</span> <span class="toc-text">@Autowired 与 @Resource 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis-%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.95.</span> <span class="toc-text">Mybatis 中 #{} 和 ${} 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis-%E6%9C%89%E5%87%A0%E7%A7%8D%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.96.</span> <span class="toc-text">Mybatis 有几种分页方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">1.97.</span> <span class="toc-text">Mybatis 一级缓存和二级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis-%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.98.</span> <span class="toc-text">Mybatis 插件的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.99.</span> <span class="toc-text">数据库的三范式是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">1.100.</span> <span class="toc-text">如何获取当前数据库的版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACID-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.101.</span> <span class="toc-text">ACID 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#char-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.102.</span> <span class="toc-text">char 和 varchar 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#float-%E5%92%8C-double-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.103.</span> <span class="toc-text">float 和 double 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.104.</span> <span class="toc-text">MySQL 内连接、左连接、右连接有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E7%9A%84%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.105.</span> <span class="toc-text">MySQL 的索引是怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.106.</span> <span class="toc-text">MySQL 索引设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81-MySQL-%E7%9A%84%E7%B4%A2%E5%BC%95%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E9%9C%80%E6%B1%82"><span class="toc-number">1.107.</span> <span class="toc-text">如何验证 MySQL 的索引是否满足需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.108.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%95%E6%93%8E"><span class="toc-number">1.109.</span> <span class="toc-text">MySQL 常用的引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E7%9A%84%E8%A1%8C%E9%94%81%E3%80%81%E8%A1%A8%E9%94%81%E3%80%81%E9%A1%B5%E9%94%81"><span class="toc-number">1.110.</span> <span class="toc-text">MySQL 的行锁、表锁、页锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.111.</span> <span class="toc-text">乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%89%8B%E6%AE%B5"><span class="toc-number">1.112.</span> <span class="toc-text">MySQL 问题排查手段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.113.</span> <span class="toc-text">MySQL 性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.114.</span> <span class="toc-text">Redis 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.114.1.</span> <span class="toc-text">Redis 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.114.2.</span> <span class="toc-text">Redis 的优点和使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">1.114.3.</span> <span class="toc-text">为什么 Redis 是单线程的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F"><span class="toc-number">1.114.4.</span> <span class="toc-text">Redis 的缓存预热是什么，如何解决缓存雪崩和缓存穿透？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8CJava%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.114.5.</span> <span class="toc-text">Redis 支持的数据类型和Java客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis-%E4%B8%8E-Redisson-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.114.6.</span> <span class="toc-text">Jedis 与 Redisson 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">1.114.7.</span> <span class="toc-text">如何保证缓存与数据库数据一致性？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.115.</span> <span class="toc-text">Redis 持久化方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.116.</span> <span class="toc-text">Redis 怎么实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">1.116.1.</span> <span class="toc-text">Redis 分布式锁的缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">1.117.</span> <span class="toc-text">Redis 如何做内存优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.118.</span> <span class="toc-text">Redis 淘汰策略有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">1.119.</span> <span class="toc-text">Redis 常见问题及解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.119.1.</span> <span class="toc-text">缓存和数据库双写一致性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98"><span class="toc-number">1.119.2.</span> <span class="toc-text">缓存穿透问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98"><span class="toc-number">1.119.3.</span> <span class="toc-text">缓存雪崩问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98"><span class="toc-number">1.119.4.</span> <span class="toc-text">缓存的并发竞争问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.120.</span> <span class="toc-text">RabbitMQ 部分面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.120.1.</span> <span class="toc-text">RabbitMQ 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E9%87%8D%E8%A6%81%E8%A7%92%E8%89%B2"><span class="toc-number">1.120.2.</span> <span class="toc-text">RabbitMQ 的重要角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="toc-number">1.120.3.</span> <span class="toc-text">RabbitMQ 的重要组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.120.4.</span> <span class="toc-text">RabbitMQ 的消息存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E4%B8%AD-vhost-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.120.5.</span> <span class="toc-text">RabbitMQ 中 vhost 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B"><span class="toc-number">1.120.6.</span> <span class="toc-text">RabbitMQ 的消息发送过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">1.120.7.</span> <span class="toc-text">RabbitMQ 如何保证消息的稳定性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF"><span class="toc-number">1.120.8.</span> <span class="toc-text">RabbitMQ 如何避免丢失消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.120.9.</span> <span class="toc-text">RabbitMQ 持久化的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E5%B9%BF%E6%92%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">1.120.10.</span> <span class="toc-text">RabbitMQ 的广播方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.120.11.</span> <span class="toc-text">RabbitMQ 如何实现延迟消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.120.12.</span> <span class="toc-text">RabbitMQ 集群的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E8%8A%82%E7%82%B9%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.120.13.</span> <span class="toc-text">RabbitMQ 节点的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.120.14.</span> <span class="toc-text">RabbitMQ 集群搭建注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E6%98%AF%E5%85%B6%E4%BB%96%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.120.15.</span> <span class="toc-text">RabbitMQ 每个节点是否是其他节点的完整拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E5%94%AF%E4%B8%80%E4%B8%80%E4%B8%AA%E7%A3%81%E7%9B%98%E8%8A%82%E7%82%B9%E5%B4%A9%E6%BA%83%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.120.16.</span> <span class="toc-text">RabbitMQ 唯一一个磁盘节点崩溃的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E9%9B%86%E7%BE%A4%E5%81%9C%E6%AD%A2%E9%A1%BA%E5%BA%8F%E8%A6%81%E6%B1%82"><span class="toc-number">1.120.17.</span> <span class="toc-text">RabbitMQ 集群停止顺序要求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.121.</span> <span class="toc-text">JVM 部分面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">1.121.1.</span> <span class="toc-text">JVM 主要组成部分及作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">1.121.2.</span> <span class="toc-text">JVM 常见问题及解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.122.</span> <span class="toc-text">JVM 中垃圾回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">1.123.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.124.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%EF%BC%88%E5%8E%8B%E7%BC%A9%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">1.125.</span> <span class="toc-text">标记-整理（压缩）算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.126.</span> <span class="toc-text">JVM 有哪些垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.127.</span> <span class="toc-text">新生代收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.128.</span> <span class="toc-text">老年代收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%A0%86%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.129.</span> <span class="toc-text">整堆收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.130.</span> <span class="toc-text">介绍一下 CMS 垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E8%80%81%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.131.</span> <span class="toc-text">新生代垃圾回收器和老生代垃圾回收器有哪些？有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8-1"><span class="toc-number">1.132.</span> <span class="toc-text">新生代收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8-1"><span class="toc-number">1.133.</span> <span class="toc-text">老年代收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">1.134.</span> <span class="toc-text">简述分代垃圾回收器是怎么工作的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98%E7%9A%84%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.135.</span> <span class="toc-text">JVM调优的工具有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.136.</span> <span class="toc-text">JVM调优的参数有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Api%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.137.</span> <span class="toc-text">Api接口如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0"><span class="toc-number">1.138.</span> <span class="toc-text">MySQL链接数据库常用的几</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90Redis"><span class="toc-number">1.139.</span> <span class="toc-text">SpringBoot如何集成Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringCloud%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.140.</span> <span class="toc-text">SpringCloud的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringCloud%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6"><span class="toc-number">1.141.</span> <span class="toc-text">SpringCloud用了哪些组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E5%92%8CSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.142.</span> <span class="toc-text">List和Set的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%ADstatic%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.143.</span> <span class="toc-text">Java中static的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.144.</span> <span class="toc-text">什么是单例模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.145.</span> <span class="toc-text">单例模式有哪几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.146.</span> <span class="toc-text">SpringBoot常用的几个注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%85%AB%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.147.</span> <span class="toc-text">Java八大数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%88%86%E9%A1%B5%E5%92%8C%E5%8D%87%E5%BA%8F%E9%99%8D%E5%BA%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.148.</span> <span class="toc-text">MySQL分页和升序降序如何实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maven%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%8C%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">1.149.</span> <span class="toc-text">Maven是干什么的，它有什么好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">1.150.</span> <span class="toc-text">MySQL如何添加索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.151.</span> <span class="toc-text">MySQL索引的实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">1.152.</span> <span class="toc-text">Vue的数据双向绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ActiveMQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.153.</span> <span class="toc-text">ActiveMQ的消息存储方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KahaDB%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8"><span class="toc-number">1.154.</span> <span class="toc-text">KahaDB消息存储</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/%E6%AF%94%E8%B5%9B/2024%E7%BE%8E%E8%B5%9B-%E6%A0%A1%E8%B5%9B/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF.html" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"></a><div class="content"><a class="title" href="/post/%E6%AF%94%E8%B5%9B/2024%E7%BE%8E%E8%B5%9B-%E6%A0%A1%E8%B5%9B/%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF.html" title="无题">无题</a><time datetime="2024-01-18T00:28:28.292Z" title="发表于 2024-01-18 08:28:28">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E9%A1%B9%E7%9B%AE/AI_image/React.html" title="React"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/11/22/Y65fK7QPnFLEzjs.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React"></a><div class="content"><a class="title" href="/post/%E9%A1%B9%E7%9B%AE/AI_image/React.html" title="React">React</a><time datetime="2024-01-12T01:04:55.000Z" title="发表于 2024-01-12 09:04:55">2024-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E9%A1%B9%E7%9B%AE/AI_image/TS.html" title="TypeScript"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/11/22/Y65fK7QPnFLEzjs.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript"></a><div class="content"><a class="title" href="/post/%E9%A1%B9%E7%9B%AE/AI_image/TS.html" title="TypeScript">TypeScript</a><time datetime="2024-01-12T00:04:55.000Z" title="发表于 2024-01-12 08:04:55">2024-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/FinalSummary/Three-plus/asm_chaoxing.html" title="汇编语言-学习通"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cwrisingimage.oss-cn-beijing.aliyuncs.com/img/102449qZEI8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="汇编语言-学习通"></a><div class="content"><a class="title" href="/post/FinalSummary/Three-plus/asm_chaoxing.html" title="汇编语言-学习通">汇编语言-学习通</a><time datetime="2024-01-01T03:51:18.000Z" title="发表于 2024-01-01 11:51:18">2024-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/Interview%2075.html" title="leetcode75"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cwrisingimage.oss-cn-beijing.aliyuncs.com/img/122641xazMi.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="leetcode75"></a><div class="content"><a class="title" href="/post/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/Interview%2075.html" title="leetcode75">leetcode75</a><time datetime="2023-12-31T09:16:26.000Z" title="发表于 2023-12-31 17:16:26">2023-12-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2023 - 2024 By fcw</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><br>
<imgsrc="https: haiyong.site="" img="" icp.png"="">
<a href="https://beian.miit.gov.cn/#/Integrated/index" style="color:white" target="_blank">豫ICP备2023032527号</a></imgsrc="https:></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://risingrode.github.io/post/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/%E9%9D%A2%E7%BB%8F-%E6%89%93%E5%8D%B0%E7%89%88.html'
    this.page.identifier = '/post/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/%E9%9D%A2%E7%BB%8F-%E6%89%93%E5%8D%B0%E7%89%88.html'
    this.page.title = '面经'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><link rel="stylesheet" href="/dist/APlayer.min.css"> <div id="aplayer"></div> <script type="text/javascript" src="/dist/APlayer.min.js"></script> <script type="text/javascript" src="/js/aplayer/music.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>